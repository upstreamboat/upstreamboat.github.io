[{"id":"e1fde2b6ab187d28ef20a6d8029bdfa3","title":"软路由","content":"软路由定义：具备路由器功能的软件系统，可以装在电脑上模拟成路由器。\n运用：在已有网络中，使用软路由新建一个子网。用到两个网卡，一个连接当前网络，用作外网；一个连接交换机或电脑形成子局域网，用作内网。\n实现：这里介绍 ros、openwrt几款软路由的区别\nRouterOS硬件中安装 ros 系统略\nros 配置图形化界面软件winbox64.exe\n\n配置上网配置上网教程\n对上面链接的教程进行详解\n\n\n配置完成后，可以查看网络连接详细日志配置防火墙-连接菜单；配置过滤规则在日志设置的 topic 中添加 firewall\nOpenWrt硬件中安装 openwrt 系统\n下载 openwrt：https://openwrt.org/zh/downloads经验证可用的版本\n\n下载 etcher下载地址如果烧录出错：可能是 etcher 软件版本不对，也可能是没开管理员权限 参考\n\n烧录成功启动电脑进入 bois，设置从 U 盘启动：在首选启动项里设置（可能）\n\n\n配置上网\n\n设置 lan：   \n  局域网设置好后，将电脑连接到该 openwrt 路由，可设置电脑 ip 为 192.168.50.50，网关为 192.168.50.10。设置好后即可登录 192.168.50.10 进入管理界面。\n  注意：  \n\n\n\n\n\n\n\n\n\n\n\ntxt哪个网口是 eth0、eth1，可以插上网线后，用 ip address 命令查看\n\n设置 wan：  wan 默认是 DHCP 的，可不用再设置，也可设置成静态的    静态 ip 设置\n\n_到这里就可以上网了_。\n查看网络连接日志\n其它设置\n设置中文\n 123opkg update # 如果出错，多试几次opkg list \\| grep luci-i18nopkg install luci-i18n-base-zh-cn\n vim /etc/config/system \n\n设置 wan 口所在的外网访问 openwrt 管理界面\n 编辑： \n\n配置网络vim /etc/config/network重启/etc/init.d/network restart 或 service network restart\n\n日志级别配置 # 这里日志级别不配置也不影响下面的网络连接日志vim /etc/config/system\n\noption log_file ‘&#x2F;var&#x2F;log&#x2F;mylog’option log_level ‘7’\n 配置好后重启：  /etc/init.d/log restart  /etc/init.d/system restart\n\n\n","slug":"杂学/未分类/软路由","date":"2024-10-26T05:48:33.715Z","categories_index":"未分类","tags_index":"技术","author_index":"upstreamboat"},{"id":"e6e1453cdfe4f5f0de0ef61a786e055f","title":"ip address解释","content":"ip address 解释https://blog.csdn.net/weixin_41960890&#x2F;article&#x2F;details&#x2F;104934585\n","slug":"杂学/未分类/ip address解释","date":"2024-10-26T01:18:37.602Z","categories_index":"未分类","tags_index":"技术","author_index":"upstreamboat"},{"id":"985bbc40ff9d7125fbbb59564cd4f397","title":"done","content":"done context\n sync thread\n io\n gorm database\n gin web\n os\n gin-vue-admin\n TCP 粘包\n ES6：https://es6.ruanyifeng.com/#docs/let\n  为 手把手封装 gin 整理笔记\n go 实现各种算法、数据结构\n sync.Pool：https://zhuanlan.zhihu.com/p/663583910\n InnoDB：最流行的数据库引擎，规定数据的存储方式，支持事务、索引等\n redis 库\n time 库\n  单元测试\n  设计模式：工厂、代理、装饰器、适配器、观察者\n  打包项目到服务器\n  索引\n git\n idea 中的 git\n  手写 GMP 过程\n  程序运行的堆栈\n Sql\n  分布式\n  正则\n TypeScript\n axios\n async、await\n  内聚耦合\n  数据结构  二叉树、红黑树、b+树\n  时间复杂度\n  事务\n  广度优先遍历\n  设计模式\n netstat\n","slug":"莫其名妙/Todo/done","date":"2024-10-21T03:53:13.263Z","categories_index":"","tags_index":"技术","author_index":"upstreamboat"},{"id":"6ef0385d3d994d110b0e4b6502ab3a5e","title":"golang进阶","content":"golang 进阶https://www.bilibili.com/video/BV1Nx4y1C72r/?spm_id_from&#x3D;333.337.search-card.all.click&amp;vd_source&#x3D;507d1879a78d5f28fa1ac6c38dbc28d0\nhttps://space.bilibili.com/567195437?spm_id_from&#x3D;333.788.0.0\nhttps://www.yuque.com/aceld/golang/sdgfgu\n","slug":"莫其名妙/记事/golang进阶","date":"2024-10-21T03:52:25.616Z","categories_index":"莫其名妙","tags_index":"技术","author_index":"upstreamboat"},{"id":"a18fee6d7aa0466d3377e2bc2e135045","title":"已学","content":"已学\ngolangiocontextGMP切片扩容\nginRestFul API\ngorm\njs\nes6\nvue3Cookie、Session、Tokenelement plus\nmysql\nredis\nkafka\nlinuxshell\ndocker\nmarkdown\n数据结构与算法\n计算机网络\n正则表达式\nnginx\n\n","slug":"莫其名妙/记事/已学","date":"2024-10-21T03:49:30.696Z","categories_index":"莫其名妙","tags_index":"技术","author_index":"upstreamboat"},{"id":"b42220c3c27fd84768e1d30a55aa0150","title":"安装了哪些","content":"安装了哪些go 环境golandmysqlsnipastepostmannodejs（js 环境）gitvscodeofficenavicatpython 环境网易有道翻译QQbindzipnotepad++vmwareMobaXtermcentos7redisdockerjetbrain Toolboxwebstormeolink – 卸载mitmproxyxmindpycharmxshellxftpAstrillwiresharkonemarkAnother Redis Desktop Manager – 卸载typorautoolsgoogle 浏览器（Chrome）onemorefirefox 火狐浏览器OpenSSL内网通pixpinfittenCodeBitwarden（密码管理器） – 卸载javaobsidiango 框架–blueprint、wailsProxifierstreamMuMu 模拟器米哈游启动器魔灵召唤重返未来星穹铁道PowerShell7choco\n","slug":"莫其名妙/记事/安装了哪些","date":"2024-10-21T03:48:06.678Z","categories_index":"莫其名妙","tags_index":"技术","author_index":"upstreamboat"},{"id":"0e9e046f01aac9c55b643076706dd73f","title":"账密","content":"账密\n\n\n应用\n账号\n密码\n关联\n说明\n\n\n\nmysql\nroot\nroot\n\n\n\n\nVMWare\nroot\nroot\n\n\n\n\ngithub\nTC240524upstreamboat\nToC@12345\n3q\n\n\n\nwsl 中的 ubuntu\ntc\n123456\n\n\n\n\nxshell\nToC\n\n3q\n\n\n\n电脑 PIN\n\n123456\n\n\n\n\ngitlab\ntangcheng\nTC@12345\n\nhttps://192.168.2.11/dashboard/projects\n\n\n通义千问\n131****1711\n\n\n\n\n\n通义灵码\n1Q\nTC0123456789\n\n\n\n\ncodeuim\n1Q\n\n\n用户名 cheng tang\n\n\nFittenCode\n131****1711\nTC0*\n\n用户名 ToChange\n\n\nBitwarden\n3q\nTC+11 位那个手机号\n\n密码管理软件，已卸载\n\n\nhttps://redocly.com/\n3Q\n\n\n\n\n\nhttp://xiaoyaoji.cn/dashboard?personal\n1Q\n\n\n在线接口文档管理：swagger 转 pdf\n\n\nfifa 游戏交易平台\n\n\n\nXBOX 邮箱\nEA 密码\n邮箱密码\n辅助邮箱\n16 位码\n\n\n\n&#109;&#121;&#x6c;&#111;&#110;&#x69;&#116;&#101;&#x35;&#53;&#53;&#64;&#x68;&#x6f;&#116;&#109;&#97;&#x69;&#108;&#x2e;&#99;&#111;&#x6d;\nAb34r6d21\nln8HIf9L\n&#115;&#111;&#x72;&#106;&#x65;&#x6b;&#64;&#102;&#101;&#x6e;&#x67;&#x73;&#104;&#105;&#106;&#105;&#x73;&#104;&#117;&#46;&#x63;&#x6f;&#x6d;\n4HOT7LZJEBQVRBT6\n\n\n&#108;&#101;&#115;&#x68;&#x65;&#97;&#110;&#101;&#112;&#x61;&#x73;&#103;&#64;&#104;&#111;&#x74;&#x6d;&#x61;&#105;&#108;&#x2e;&#99;&#111;&#x6d;\nAv88k1734\n\n\nBILZEY7P6ZPXNFN7\n\n\n服务器 fifa 项目前台登录密码\n\n\n\n\n\n\n\n\n\n195.206.167.2:8085账号：admin，密码：fifaadmin账号：user123，密码：user123\n公司的 stream 账号：但是绑定的是我 1Q\n\n\n\n\n\n\n\n\n\n&#70;&#x6a;&#108;&#86;&#x37;&#x37;&#52;&#x31;&#x36;&#x33;&#x2d;&#45;&#x2d;&#45;&#76;&#107;&#121;&#86;&#48;&#51;&#54;&#49;&#x2d;&#45;&#x2d;&#x2d;&#x65;&#118;&#111;&#107;&#x64;&#x65;&#64;&#100;&#x39;&#x38;&#x79;&#x67;&#97;&#109;&#101;&#x2e;&#99;&#111;&#x6d;&#x2d;&#x2d;&#45;&#45;&#x39;&#x33;&#53;&#x38;&#x32;&#52;\n","slug":"莫其名妙/记事/账密","date":"2024-10-21T03:44:54.091Z","categories_index":"莫其名妙","tags_index":"技术","author_index":"upstreamboat"},{"id":"0d80a338b0b4d9b9f9a1dce7083f74c8","title":"问题","content":"问题\n \n匿名函数实现接口\n\n\n\n\n\n\n\n\n\n参见\n\n \nvue 中$符号的用法\n\n \ngin-vue-admin：如何重新初始化\n\n \n虚拟机 ip 自动改变\n\n \n没有 ipconfig 命令\n\n \n以太网适配器 vEthernet (WSL) 是什么\n\n \nhttps://blog.csdn.net/xiaobaijinhuaji/article/details/125872141\n\n \ngo 如何创建一个 nil 对象\n\n\n\n\n\n\n\n\n\n声明为引用类型\n\n \nhttp 持久连接和 websocket\n\n\n\n\n\n\n\n\n\nhttp 持久连接：只能单向发送请求或响应websocket：双向请求\n\n \n镜像下载失败\n\n\n\n\n\n\n\n\n\n\n开启 vpn 下载\n更换源仓库\n\n\n\n","slug":"莫其名妙/问题/问题","date":"2024-10-21T03:25:23.365Z","categories_index":"莫其名妙","tags_index":"技术","author_index":"upstreamboat"},{"id":"5abb58fe4e99e9018406fa7efb246d4c","title":"计算机软硬件","content":"计算机软硬件交互图示：软硬件交互图.excalidraw软硬件交互图\n","slug":"杂学/未分类/计算机软硬件","date":"2024-10-21T02:51:20.586Z","categories_index":"未分类","tags_index":"技术","author_index":"upstreamboat"},{"id":"6d1ccee031cb0e2e8267eb98a1d50de6","title":"编译器与解释器","content":"编译器与解释器编译器将整个源代码翻译成机器代码一次性执行，而解释器逐行读取翻译和执行代码。编译器会生成更快的执行文件（中间文件），而解释器不生成中间文件，更灵活，便于调试和开发。\n","slug":"杂学/未分类/编译器与解释器","date":"2024-10-21T02:03:57.202Z","categories_index":"未分类","tags_index":"技术","author_index":"upstreamboat"},{"id":"2ad9a85d6ea45863d39523b11181e06f","title":"扩展运算符","content":"\nCode\n  1234567891011121314151617181920// 1）...int ：点号放在前面表示合并，将多个int类型的参数合并为一个切片func sum(nums ...int) &#123;for _, num := range nums &#123;fmt.Print(num)&#125;fmt.Println()&#125;func Test01(t *testing.T) &#123;sum(1, 2, 3, 4) // 可直接传入多个参数// 2）slice... ：点号放在后面表示拆分，将切片拆分为多个参数（拆分必须由合并接收）sum([]int&#123;1, 2, 3, 4&#125;...) // 也可拆分切片作为参数&#125;\n\n运用\n  12345678910func Test01(t *testing.T) &#123;// 两种运用ints:= append([]int&#123;1, 2, 3&#125;, []int&#123;4, 5, 6&#125;...)byts:= append([]byte(&quot;hello&quot;), &quot;fuck&quot;...)t.Log(ints, byts)&#125;\n\n额外用法\n  12// 定义数组： 使用[...]可以创建一个数组，而不需要手动指定大小。Go会根据提供的元素自动计算数组的长度var arr = [...]int&#123;1, 2, 3&#125;\n问题\n  12345678910111213141516171819func Test01(t *testing.T) &#123;//func append(slice []Type, elems ...Type) []Typebyts := append([]byte(&quot;hello&quot;), &quot;fuck&quot;...)sum(&quot;fuck&quot;...)  // 报错！为什么上面的append可以用...，而sum却不能用？sum([]byte(&quot;hello&quot;)...)fmt.Println(byts)&#125;func sum(nums ...byte) &#123;fmt.Println(nums)&#125;\n\n","slug":"GO语言/基础/扩展运算符","date":"2024-10-14T02:45:18.741Z","categories_index":"GO语言","tags_index":"技术","author_index":"upstreamboat"},{"id":"b182f88fd395043811440e94f84026e9","title":"windows激活","content":"windows 激活管理员模式打开终端，依次执行：\n\n\n\n\n\n\n\n\n\nslmgr &#x2F;ipk NPPR9-FWDCX-D2C8J-H872K-2YT43slmgr &#x2F;skms kms.03k.org （或 slmgr &#x2F;skms Kms.loli.best）slmgr &#x2F;ato\n激活码：https://www.bilibili.com/read/cv16094664/\n","slug":"杂学/未分类/windows激活","date":"2024-10-12T08:49:02.814Z","categories_index":"未分类","tags_index":"技术","author_index":"upstreamboat"},{"id":"13ad556c4b7fd14f881ddc5f3a4c5e46","title":"特殊文件地址","content":"特殊文件地址git 全局配置文件地址：C:\\Users\\唐成\\.gitconfiggit 当前本地仓库局部配置文件地址：例如：D:\\Code\\MyProject\\study-01-golang\\.git\\config\nssh 配置文件地址：C:\\Users\\唐成\\.ssh\\config\nhosts 文件地址：C:\\Windows\\System32\\drivers\\etc\\\ngitlab 内部配置文件：/etc/gitlab/gitlab.rb/opt/gitlab/embedded/service/gitlab-rails/config/gitlab.yml\n","slug":"杂学/未分类/特殊文件地址","date":"2024-10-12T08:47:32.435Z","categories_index":"未分类","tags_index":"技术","author_index":"upstreamboat"},{"id":"be29bb0db4085d04ddb5f9bb082efc87","title":"hexo使用","content":"hexo 使用\n创建 hexo 和 gitpage\n使用 stellar 主题\n\n创建“文档”分类\n创建一个全新分类\n\n\n\n\n\n\n\n\n\nmd 文档中如果有 title 标签，那么该文档也会出现在“文档”分类中。\n","slug":"杂学/未分类/hexo使用","date":"2024-10-12T08:45:20.282Z","categories_index":"未分类","tags_index":"技术","author_index":"upstreamboat"},{"id":"d9cc7a9a859bba4487926796a7a19256","title":"git-03-gitlab","content":"git-03-gitlab\n特殊文件：参考/etc/gitlab/gitlab.rb/opt/gitlab/embedded/service/gitlab-rails/config/gitlab.yml\n\n启动 gitlab 容器：\n 123456789101112131415docker run -d -p 8443:443 -p 8090:80 -p 8022:22 --restart always --name myGitlab -v /usr/local/gitlab/etc:/etc/gitlab -v /usr/local/log:/var/log/gitlab -v /usr/local/gitlab/data:/var/opt/gitlab --privileged=true twang2218/gitlab-ce-zh# 解释：docker run-d #后台运行，全称：detach-p 8443:443 #将容器内端口向外映射-p 8090:80 #将容器内80端口映射至宿主机809端口，这是访问git1ab的端口-p 8022:22 #将容器内22端口映射至宿主机，8022端口，这是访问ssh的端口--restart always #容器自启动--name gitlab #设置容器名称为gitlab-v /usr/local/gitlab/etc:/etc/gitlab #将容器/etc/gitlab目录挂载到宿主机/usr/1ocal/gitlab/etc目录下，若宿主机内此目录7-v /usr/local/gitlab/log:/var/log/gitlab #与上面一样-v /usr/local/gitlab/data:/var/opt/gitlab #与上面一样--privileged=true #让容器获取宿主机root权限twang2218/gitlab-ce-zh #镜像的名称，这里也可以写镜像ID\n\n进入容器： docker exec -it myGitlab bash\n\n容器内重启 gitlab：gitlab-ctl restart\n\n\n","slug":"命令/git/git-03-gitlab","date":"2024-10-12T08:41:46.520Z","categories_index":"命令","tags_index":"技术","author_index":"upstreamboat"},{"id":"8f45e67ec22c8ab717fbba50f4923e8f","title":"git-02-ssh地址无效","content":"git-02-ssh 地址无效https://blog.csdn.net/xb_zed/article/details/111357020\n\n生成公、私钥：ssh-keygen -t rsa -C &quot;1434329543@qq.com&quot;windows 目录：C:\\Users\\唐成\\.sshlinux 目录：/home/User/.ssh/密钥账密：root=root\n设置 gitlab 网站的公钥：详见上面网址\n配置 ssh 的配置文件\n\n","slug":"命令/git/git-02-ssh地址无效","date":"2024-10-12T08:41:46.508Z","categories_index":"命令","tags_index":"技术","author_index":"upstreamboat"},{"id":"44054c4b24deb794b261449477fecc9c","title":"git-01-常用命令","content":"git-01-常用命令一、首次推送本地项目代码流程\n在项目目录下，创建本地仓库：\n1git init\n\n将文件加入到本地仓库：\n1git add * 或者 git add .\n\n将加入的文件提交到本地仓库：\n1git commit -m &#x27;tc&#x27; // -m &#x27;tc&#x27;表示添加本次提交的说明内容为 tc\n\n建立远程连接：\n1git remote add origin http://192.168.2.80:8090/root/study-01-golang.git\n\n建立本地仓库分支与远程仓库分支的连接：\n1git branch --set-upstream-to=origin/&lt;branch&gt; master\n\n推送本地仓库代码到远程仓库：\n1git push\n\n\n\n\n\n\n\n\n\n\n或者直接合并 5、6 两步：\n1git push --set-upstream origin master\n\n二、非首次推送的几种情况\n本地修改：直接：git push\n\n远程修改：则需先执行：git pull\n\n本地修改 + 远程修改：正确操作：二选一\n\n\n\n\n\n\n\n\n\n\nadd-&gt;git stash-&gt;git pull-&gt;git stash apply-&gt;处理本地代码冲突-&gt;add-&gt;commit-&gt;push\n\n只会留下一条记录\n\nadd-&gt;commit-&gt;git pull-&gt;处理本地代码冲突-&gt;add-&gt;commit-&gt;push\n\n\n\n\n\n\n\n\n\n第一次 add-commit，是将本地修改的代码提交到本地仓库中，记为代码 A第二次 add-commit，是将处理冲突后的代码提交到本地仓库中，记为代码 B（B 才是我们最终需要的代码）会留下两条记录（详见下面的错误 3）\n\n\n\n 错误操作：\n\n\n\n\n\n\n\n\n\n\n直接 git pull：失败，报错提示本地修改会被覆盖\nadd-&gt;commit-&gt;git push：失败，报错\nadd-&gt;commit-&gt;git pull-&gt;处理本地代码冲突-&gt;push：失败，报错（与错误 2 其实是同一种错误操作）\n\n\n这一步报错是因为此时 push 的是代码 A，而 A 与远程冲突无法推送需要再次 add-&gt;commit，此时本地仓库中就有两条记录（代码 A、代码 B），然后 push 便可成功\n\npush 后远程仓库中也有两条记录（与本地仓库对应），一条是将远程代码修改为代码 A，一条是再次修改为代码 B，最终呈现代码 B\n\n\n\n\n三、常用命令\n\n\n类属\n详细命令\n作用\n备注\n\n\n\npull\ngit pull –allow-unrelated-histories\n忽略不相干的文件\n如果远程仓库新代码，但与本地代码不存在冲突时，在拉取需要执行\n\n\n\ngit pull origin master\n获取远程分支 master 并 merge 到当前分支\n\n\n\npush\ngit push -u origin master\n-u：记录本次推送的分支。相当于执行 2 条命令：git push origin mastergit branch –set-upstream master origin&#x2F;master\n\n\n\n\ngit push  \n推送到指定分支\n\n\n\n\ngit push origin :\n删除远程仓库的分支\n\n\n\n\ngit push origin –delete dev-tc2\n删除远程仓库的分支\n\n\n\n\ngit push –set-upstream origin dev\n远程 dev 分支不存在时，创建并提交\n\n\n\nbranch\ngit branch\n显示本地分支\n\n\n\n\ngit branch -a\n显示所有分支，包括已关联的远程分支\n\n\n\n\ngit branch \n根据当前分支创建分支\n\n\n\n\ngit branch -d \n删除分支\n\n\n\n\ngit branch -D \n强制删除\n\n\n\ncheckout\ngit checkout \n切换分支\n\n\n\n\ngit checkout -b \n根据当前分支创建后切换到新分支\n\n\n\n\ngit checkout -b  origin&#x2F;master\n根据某个指定分支（可以是远程的或本地的）创建后切换到新分支\n\n\n\ndiff\ngit diff\n比较未提交的修改与当前版本的区别\n\n\n\n\ngit diff head^\n比较与上一个版本的区别\n\n\n\n\ngit diff origin&#x2F;master..master\n比较远程分支 master 上有但本地分支 master 上没有的\n\n\n\n\ngit diff origin&#x2F;master..master –stat\n只显示差异的文件，不显示具体内容\n\n\n\nremote\ngit remote add origin git+ssh:&#x2F;&#x2F;&#103;&#105;&#116;&#x40;&#x31;&#57;&#50;&#46;&#49;&#x36;&#x38;&#x2e;&#53;&#51;&#x2e;&#x31;&#x36;&#56;&#x2F;VT.git\n添加远程仓库\n\n\n\n\ngit remote -v\n显示远程版本\n\n\n\n\ngit remote show \n显示远程信息\n\n\n\n\ngit remote remove origin\n删除远程仓库\n\n\n\nrestore\ngit restore \n清除本地修改\n\n\n\n\ngit restore .\n清除所有修改\n\n\n\nrevert\ngit revert \n回滚代码，但不会删除原提交记录，而且会创建一个新的提交记录\n相当于修改了代码，然后再次提交，只不过代码内容和以前某个版本一样\n\n\nreset\n–soft：撤销 commit 操作，代码保留–mixed：撤销 add、commit 操作，代码保留–hard：撤销 add、commit 操作，代码不保留！\n\n撤销后提交记录是否保留（本地不保留，远程保留）\n\n\n\ngit reset –hard\n回滚代码到指定的提交记录点\n可以用 git log 命令获得\n\n\n\ngit reset –hard HEAD\n将当前版本重置为 HEAD\n通常用于 merge 失败回退\n\n\n\ngit reset –hard head^\n回滚代码到第二新的记录点\n注意最后有个符号^是必须的,，它表示上一个版本\n\n\nmerge\ngit merge \n合并其它分支至当前分支。（如果是远程分支：git merge origin&#x2F;master）\n\n\n\n\ngit merge –allow-unrelated-histories origin&#x2F;\n忽略不相干的文件\n\n\n\nls\ngit ls-files\n查看列出仓库文件\n\n\n\n\ngit ls-tree HEAD\n显示某个 git 对象\n\n\n\nstash\ngit stash\n暂存当前修改，将所有文件至为 HEAD 状态\n与 commit 属于两种不同的操作\n\n\n\ngit stash pop\n弹出并应用最新一条暂存的修改\n弹出后会删除该条暂存记录\n\n\n\ngit stash apply\n应用最新一条暂存的修改\n应用后不会删除该条暂存记录\n\n\n\ngit stash clear\n清空暂存\n\n\n\n\ngit stash drop stash@{0}\n删除某条暂存记录\n\n\n\n\ngit stash list\n查看所有暂存\n\n\n\n\ngit stash show -p stash@{0}\n查看第一次暂存\n\n\n\nconfig\ngit config –global user.name “username”\n配置用户名\n–global 表示配置全局变量，去掉则只在当前有效\n\n\n\ngit config –global user.password “password”\n配置密码\n\n\n\n\ngit config –global user.email “email”\n配置用户邮箱\n\n\n\n\ngit config –global credential.helper store\n保存认证信息\n\n\n\ngit log\n\n查看提交记录\n如果记录条数过多，可以按 q 退出查看\n\n\nshow\ngit show \n显示某次提交的详细内容\n\n\n\ngit status\n\n查看有修改的文件\n\n\n\nrm\ngit rm \n删除已 add 但未 commit 的文件\n\n\n\nadd\ngit add -u\n是 git add –update 的简写，只添加已修改的文件，并忽略未跟踪的文件\n\n\n\ncommit\ngit commit -am ‘xxx’\n将 add 和 commit 合为一步\n\n\n\n\ngit commit –amend -m “新的注释”\n覆盖最后一次 commit 的注释，上一次的注释记录会消失\ngit commit –amend 不加-m 会进入命令行模式，然后修改注释\n\n\n四、删除远程文件，但不删除本地对应文件\n法一：\n  123git rm -r --cached  tests # --cached不会把本地的tests删除git commit -m &#x27;delete tests&#x27;git push -u origin master\n\n法二：修改.gitignore 文件,将不需要的文件过滤掉，然后执行命令\n  1234git rm -r --cached .git add .git commitgit push  -u origin master\n\n五、git 放弃当前修改\n不保留改动的代码，但是未 add 的文件无法放弃\n  123git checkout -- tests/one_test.gogit restore tests/one_test.gogit reset --hard\n\n要删除未 add 的文件，如下：\n  12git clean -f  # 删除所有文件git clean -fd  # 删除所有文件和目录\n\n六、git reset 撤销\n\n\n\n\n\n\n\n\n问：撤销后提交记录是否保留？\n\n解：本地不保留，远程保留\n\n–soft：该命令表示撤销代码到暂存区之后和 commit 之前，代码在本地不会改变。–mixed：该命令表示撤销代码到暂存区和 commit 之前，代码在本地不会改变。–hard：该命令表示回退代码到某个版本下，代码在本地会改变到指定版本下，谨慎操作。\n图示：\n","slug":"命令/git/git-01-常用命令","date":"2024-10-12T08:41:46.479Z","categories_index":"命令","tags_index":"技术","author_index":"upstreamboat"},{"id":"d1606efea8d5cfe2a8c493a980499133","title":"docker-05-volume","content":"docker-05-volume\n参考\n\n参考\n\n参考\n\n参考\n\n使用方式：\n\n启动容器时：docker run -v /A:/B\n\n\n\n\n\n\n\n\n\n\n将宿主机的&#x2F;A 目录挂载到容器内的&#x2F;B 目录。如果&#x2F;B 目录下在挂载前有东西，那这些东西会消失。但&#x2F;A 中的不会。\n\n此时 A 或 B 目录都能看到 A 中的内容，并且 A 和 B 都可以修改里面的内容，内容会保持一致。\n即使容器被删除，&#x2F;A 目录依然存在。\n\n\nDockerfile 中：使用 volume 指令\ndocker-compose 中：volumes: - D:\\Doc\\DockerMounts\\redis:/data \n\n\n挂载的必须是目录，不能是文件\n\n要删除数据卷 volume，需要删除对应容器\n\n数据卷两种形式：\n\n\n\n\n\n\n\n\n\n\n一种是宿主机目录挂载到容器目录。例：docker run -v D:\\Doc\\DockerMounts\\redis:/data\n一种是创建一个数据卷，而非宿主机目录，该数据卷是独立于宿主机的文件系统外、属于 docker 管理的（linux 位置在&#x2F;var&#x2F;lib&#x2F;docker&#x2F;volumes）。例：docker run -v volume_name:/data\n\n\n\n","slug":"命令/docker/docker-05-volume","date":"2024-10-12T08:41:16.500Z","categories_index":"命令","tags_index":"技术","author_index":"upstreamboat"},{"id":"7b43371a8d59a1a9537e4018c317ac7b","title":"docker-04-compose","content":"docker-04-compose\n参考 1\n\n参考 2\n\n配置 Dockerfile\n 1234567891011121314151617FROM golang:alpine as builderENV GO111MODULE=on \\    CGO_ENABLED=0 \\    GOOS=linux \\    GOARCH=amd64 \\    GOPROXY=&quot;https://goproxy.cn,direct&quot;WORKDIR /COPY . .RUN go build -o server .EXPOSE 8090CMD [&quot;./server&quot;]\n\n配置 docker-compose.yml\n 1234567891011121314151617181920212223242526272829303132version: &quot;3.7&quot;services:  app:    build:      context: ./ # 要构建的程序代码目录      dockerfile: ./Dockerfile # 指定Dockerfile所在位置，相对路径为context配置的路径    ports:      - 8088:8888    volumes:      - ./data:/app/data  # 宿主机当前目录下的/data目录映射到容器中    depends_on:      - redis      - mysql    restart: on-failure  # 失败重启，避免mysql未启动完全，app便启动可能带来的报错    links:      - redis      - mysql  redis:    image: redis    volumes:      - D:\\Doc\\DockerMounts\\redis:/data  # 容器内的data目录挂载到宿主机的D:\\Doc\\DockerMounts\\redis    ports:      - &quot;6379:6379&quot;  mysql:    image: mysql    ports:      - &quot;3306:3306&quot;  # host物理直接映射端口为3306    environment:      MYSQL_DATABASE: &#x27;test&#x27; # 初始化启动时要创建的数据库的名称      MYSQL_ROOT_PASSWORD: &quot;root&quot; # root管理员用户密码volumes:  redis:\n\n修改应用的连接配置host 必须配成 redis，不能是 127.0.0.1；mysql 也是同理\n 12345redis:  host: redis  port: 6379  db: 0  password:\n\n启动：在 docker-compose.yml 目录下执行命令：docker-compose up &#x2F;&#x2F; 如果是 linux：则是：docker compose up成功后会创建一个镜像，并自动创建运行一个容器组\n\n\n","slug":"命令/docker/docker-04-compose","date":"2024-10-12T08:41:16.478Z","categories_index":"命令","tags_index":"技术","author_index":"upstreamboat"},{"id":"060e99f1c1b45532c920b0f655e0f17d","title":"docker-03-Dockerfile","content":"docker-03-Dockerfile\n参考\n\n关于 CMD 指令\n 12CMD [ &quot;sh&quot;, &quot;-c&quot;, &quot;echo $HOME&quot; ] // 可以获取环境变量CMD [ &quot;echo&quot;, &quot;$HOME&quot; ] // 无法获取环境变量\n如要将项目打包成镜像在 docker 中运行，需要 Dockerfile 文件，其写法如下：（以 golang 项目为例）\n 123456789101112131415161718192021FROM golang:alpine as builderENV GO111MODULE=on \\    CGO_ENABLED=0 \\    GOOS=linux \\    GOARCH=amd64 \\    GOPROXY=&quot;https://goproxy.cn,direct&quot;WORKDIR /appCOPY . .RUN go build -o server .WORKDIR /distRUN cp /app/server .EXPOSE 8090CMD [&quot;/dist/server&quot;]\n\n构建镜像命令docker build -t test:v1 .\n\n多阶段构建：从上一阶段的镜像中复制文件（也可以从任意镜像复制，–from&#x3D;镜像）COPY --from=0 /app .\n\n\n","slug":"命令/docker/docker-03-Dockerfile","date":"2024-10-12T08:41:16.448Z","categories_index":"命令","tags_index":"技术","author_index":"upstreamboat"},{"id":"a3350072c5c3ce337874d5fb082092b7","title":"docker-02-更换镜像仓库","content":"docker-02-更换镜像仓库golang:alpine\n\n\n\n\n\n\n\n\n\n后面的 alpine 是镜像版本，不同版本镜像由不同底层操作系统构建成。alpine 版本有更快的启动速度和更小的磁盘占用\n当无法下载镜像时，可能是镜像仓库无法访问，可通过修改配置来修改源仓库：\n\n\n\n\n\n\n\n\n\n配置文件地址位置可能在：\n\nwindows：C:\\Users\\唐成\\.docker\\daemon.jsonlinux：/etc/docker/daemon.json\n\n\n\n\n\n\n\n\n\n\n配置内容：\n\n &quot;registry-mirrors&quot;: \\[ &quot;[https://registry.docker-cn.com](https://registry.docker-cn.com)&quot;, &quot;[http://hub-mirror.c.163.com](http://hub-mirror.c.163.com)&quot;, &quot;[https://dockerhub.azk8s.cn](https://dockerhub.azk8s.cn)&quot;, &quot;[https://mirror.ccs.tencentyun.com](https://mirror.ccs.tencentyun.com)&quot;, &quot;[https://registry.cn-hangzhou.aliyuncs.com](https://registry.cn-hangzhou.aliyuncs.com)&quot;, &quot;[https://docker.mirrors.ustc.edu.cn](https://docker.mirrors.ustc.edu.cn)&quot;, &quot;[https://docker.m.daocloud.io](https://docker.m.daocloud.io)&quot;, &quot;[https://noohub.ru](https://noohub.ru)&quot;, &quot;[https://huecker.io](https://huecker.io)&quot;, &quot;[https://dockerhub.timeweb.cloud](https://dockerhub.timeweb.cloud)&quot; ]\n\n","slug":"命令/docker/docker-02-更换镜像仓库","date":"2024-10-12T08:41:16.433Z","categories_index":"命令","tags_index":"技术","author_index":"upstreamboat"},{"id":"b970f9374d336d7d394fca1ede742477","title":"docker-01-命令","content":"docker-01-命令\n\n\n\n\n\n\n\nsystemctl start docker\n启动docker服务\n\n\ndocker ps -a\n-a包含非运行的容器\n\n\ndocker images\n查看镜像\n\n\ndocker search XXX\n搜索在线镜像\n\n\ndocker pull 镜像\n下载镜像\n\n\ndocker exec -it myGitlab bash\n进入容器。myGitlab是容器名，可以换成容器id\n\n\ndocker stop $(docker ps -q)\n停止所有容器。-q：显示id\n\n\ndocker run\n启动容器，详见“git-03-gitlab”\n\n\ndocker run --rm\n退出容器后删除该容器（相当于建了个临时容器）\n\n\ndocker run -it --rm --name myTemp 镜像名 sh\n直接通过镜像创建临时容器并进入容器内\n\n\ndocker logs -t --since=&quot;2017-05-31T07:10:40&quot; --until=&quot;2017-05-31T08:30:40&quot; edu_web_1\n查询时间段内的日志\n\n\ndocker build -t test:v1 .\n构建镜像，在当前目录需要Dockerfile文件。注意最后有个&quot;.&quot;\n\n\ndocker-compose -f ./docker-compose.yml -d -p myName up\n-f：指定配置文件-d：后台运行-p：起个名up：启动；down：关闭；restart：重启\n\n\ndocker cp fifa23-server-1:/go/src/github.com/flipped-aurora/gin-vue-admin/server/log .\ndocker cp 容器名:容器内文件路径 宿主机路径\n\n\n","slug":"命令/docker/docker-01-命令","date":"2024-10-12T08:41:16.418Z","categories_index":"命令","tags_index":"技术","author_index":"upstreamboat"},{"id":"583fd4c2e87f2a473e7c280c1d8d4480","title":"查看进程及其网络信息","content":"查看进程及其网络信息\nwindows 下：\n  12netstat -ano|findstr 9091tasklist|findstr 12220\n\nlinux 下：\n  12netstat -tanp|grep 9091ps -ef|grep 12220\n\n查看系统内核：\n  1uname -a\n\nDebian 系统：\n  12lsof -nP -iTCP -sTCP:LISTENss -tulpn\n\n测试连接：\n  1telnet ip port\n\n","slug":"命令/linux/查看进程及其网络信息","date":"2024-10-12T08:40:34.887Z","categories_index":"命令","tags_index":"技术","author_index":"upstreamboat"},{"id":"36563c8b2d75028349bf04379c8b6f5d","title":"linux-06-虚拟机修改静态ip","content":"linux-06-虚拟机修改静态 ip12345vim /etc/sysconfig/network-scripts/ifcfg-ens331. BOOTPROTO=dhcp 改成 BOOTPROTO=static2. 添加 ip、网关、DNS 地址3. service network restart\n\n修改为静态 ip 后，主机此时无法访问虚拟机，需要修改主机的 vmnet8 地址，使其与虚拟机地址在同一网段。\n","slug":"命令/linux/linux-06-虚拟机修改静态ip","date":"2024-10-12T08:40:34.875Z","categories_index":"命令","tags_index":"技术","author_index":"upstreamboat"},{"id":"193aa955af75ccada54a8d817c5caaf0","title":"linux-05-虚拟机网络连接模式","content":"linux-05-虚拟机网络连接模式\nvmnet0  桥接模式，主机虚拟出一个交换机，使虚拟机和主机处在同一个局域网，虚拟机也占用路由器的 IP\n\nvmnet1  仅主机模式，仅主机和虚拟机通信的专用网络\n\nvmnet8  nat 模式，网络地址转换，主机内部虚拟出一个局域网\n\n\n参考\n","slug":"命令/linux/linux-05-虚拟机网络连接模式","date":"2024-10-12T08:40:34.866Z","categories_index":"命令","tags_index":"技术","author_index":"upstreamboat"},{"id":"b4bdc08e8683d28fc8919e60c11f9d85","title":"linux-04-软硬链接","content":"linux-04-软硬链接\n特点：   源文件、软链接、硬链接，一改具改。   删除源文件只会对软链接文件有影响。\n\n\n\n\n\n\n\n\n\n因为源文件和硬链接指向的都是内存中的文件节点，而软链接指向的是源文件。类似于：源文件、硬链接中保存的都是数据本身的内存地址，而软链接保存的是源文件的内存地址\n\n创建软链接\n  1ln -s ./test/info linfo\n创建硬链接\n  1ln ./test/info ylinfo\n\n","slug":"命令/linux/linux-04-软硬链接","date":"2024-10-12T08:40:34.854Z","categories_index":"命令","tags_index":"技术","author_index":"upstreamboat"},{"id":"0a174f27aab9bc96fb6b45bb12b6fd32","title":"linux-03-shell脚本","content":"linux-03-shell 脚本shell 脚本局部变量仅在当前 shell 中可以访问；全局变量在父子 shell 中都可以访问但是，子 shell 中的更改，在父 shell 中不生效（类似于 go 的值传递，作用域随着子 shell 的关闭而消失）\n执行 shell 脚本的方法\nsource xxx.sh（等价于. xxx.sh（空格不能少））在当前 shell 进程中执行脚本\nsh xxx.sh（等价于 bash xxx.sh（因为 sh 是连接到 bash 的））开启一个子 shell，在子 shell 中执行脚本。因为是在子 shell 中，所以创建或修改的变量，回到父 shell 后不生效\n./xxx.sh开启一个子 shell，在子 shell 中执行脚本，但是需要先赋予脚本可执行权限\n\n$的使用123456$var：调用变量$n：获取命令的第几个参数。$0是命令本身$#：获取参数个数。包含本身吗？$*：获取所有的参数作为一个整体$@：获取所有的参数作为多个参数$?：获取上一个命令的执行是否成功（0：成功；1：失败）\n\n语法\n计算表达式的值\n  1234echo $[1+2]echo $((1+2))echo $(expr 1 \\* 2)echo `expr 1 \\* 2`\n\n条件判断\n  123[ 2 = 2 ][ 1 = 1 ] &amp;&amp; [ 2 = 2 ][ 2 = 3 ] &amp;&amp; echo &quot;true&quot; || echo &quot;false&quot;\n\n流程控制\n  1234ifcaseforwhile\n\nread 读取输入\n  1read -t 5 -p &quot;your name: &quot; NN\n\n函数：略\n\n\n文本处理三剑客\ncut：文本内容剪切-d：指定分隔符-f：指定获取第几部分\n12cut test.txt -d &quot; &quot; -f 1cat /etc/passwd |grep bash$|cut -d &quot;/&quot; -f 1-\n\nawk：文本内容处理格式：awk -F &quot;分隔符&quot; &#39;/正则表达式/&#123;执行语句&#125;&#39;\n1234567891011121314151617// 默认以空格分隔cat /etc/passwd |awk &#x27;&#123;print $1&#125;&#x27;// -F：指定分隔符cat /etc/passwd |awk -F &quot;:&quot; &#x27;&#123;print $6&quot;,&quot;$7&#125;&#x27;// 匹配文件中以root开头的行cat /etc/passwd |awk -F &quot;:&quot; &#x27;/^root/&#123;print $6$7&#125;&#x27;// 显示结果中添加首尾行信息cat /etc/passwd |awk -F &quot;:&quot; BEGIN&#123;print &quot;begin&quot;&#125; &#x27;&#123;print $1&quot;,&quot;$7&#125;&#x27; END&#123;print &quot;end&quot;&#125;// -v 定义变量cat /etc/passwd |awk -v i=2 -F &quot;:&quot; &#x27;&#123;print $3+i&#125;// 系统内置变量：文件名、行号、分隔后的列数awk &#x27;&#123;print FILENAME&quot;,&quot;NR&quot;,&quot;NF&#125;&#x27; /etc/passwd\n\nsed：文本内容增删改\n123// Hello替换成Hi// s：表示替换操作；g：表示全部替换sed &#x27;s/Hello/Hi/g&#x27; data.txt\n\n","slug":"命令/linux/linux-03-shell脚本","date":"2024-10-12T08:40:34.840Z","categories_index":"命令","tags_index":"技术","author_index":"upstreamboat"},{"id":"9a4dc773c6431e348c90624ba1cd5533","title":"linux-02-命令","content":"linux-02-命令\n\n\nA\nB\n\n\n\nwhich + 命令\n查看命令在哪\n\n\nsystemctl start + 服务\n启动服务\n\n\nfind &#x2F; -name file\n查找文件在哪\n\n\ncd -\n回退到上一次目录\n\n\ncd – 或 cd ~\n进入~目录\n\n\n! + 命令首字母\n执行之前的某个命令\n\n\n","slug":"命令/linux/linux-02-命令","date":"2024-10-12T08:40:34.804Z","categories_index":"命令","tags_index":"技术","author_index":"upstreamboat"},{"id":"6839177aa32604fdb2b106479a7056e3","title":"linux-01-快捷键","content":"linux-01-快捷键\n\n\nA\nB\n\n\n\nctrl+u\n清空光标之前的输入\n\n\nctrl+l\n清屏\n\n\nctrl+w\n删除输入的前一个单词\n\n\n","slug":"命令/linux/linux-01-快捷键","date":"2024-10-12T08:40:34.789Z","categories_index":"命令","tags_index":"技术","author_index":"upstreamboat"},{"id":"26cf5333f386846f9a13aec070a0730c","title":"代码规范","content":"代码规范\n命名：包名（mypackage）、常量名（ItemCount）\n\n需要管理的错误、常量，定义到独立文件中；\n\n边界要准确：确认是 if len(cids) &lt;= 0 还是 if len(cids) == 0；\n\n错误日志打印：\n\n\n\n\n\n\n\n\n\n信息+字段+错误c.Error(gameerror.QuickSellErrMsg, zap.Any(&quot;id&quot;, id), zap.Error(err))\n\n错误对象捕捉：fmt.Errorf(gameerror.GetUnassignedItemsErrMsg+&quot;：%w&quot;, err)\n\n底层功能方法直接抛出 error，在业务方法中处理\n\n减少嵌套：\n  123// 推荐：if len(miscItems) == 0 &#123;return nil&#125;for&#123;&#125;\n\n  12// 不推荐：if len(miscItems) &gt; 0 &#123;for&#123;&#125;&#125;\n\n单一返回值写成一行：\n  1if err = c.sellItem(&amp;item); err != nil &#123;return err&#125;\n错误处理：打印堆栈  自测下来还是建议使用。虽然网上有说法（说法来源）说不推荐使用 github.com&#x2F;pkg&#x2F;errors 该包。\n\n\n\n\n\n\n\n\n\n\n\nimport &quot;github.com/pkg/errors&quot;最底层创建：err := errors.New(&quot;aaa&quot;)调用层包装：err = errors.WithMessagef(err, &quot;error occurred, id=%d&quot;, 3)\n\n为什么不用 errors.Wrapf：会多打印一份 Wrapf 返回值的堆栈信息\n最上层打印：\n\n\n\n\n\n\n\n\n\nfmt.Printf(&quot;%+v\\n&quot;, err) &#x2F;&#x2F;打印堆栈fmt.Printf(&quot;%v\\n&quot;, err) &#x2F;&#x2F;不打印堆栈\n最上层获取错误：err.Error()\n\n","slug":"GO语言/项目/代码规范","date":"2024-10-12T02:29:30.432Z","categories_index":"GO语言","tags_index":"技术","author_index":"upstreamboat"},{"id":"a161ef1c1cef77773912987d7ea38734","title":"项目层次","content":"项目层次\n","slug":"GO语言/项目/项目层次","date":"2024-10-12T02:29:30.394Z","categories_index":"GO语言","tags_index":"技术","author_index":"upstreamboat"},{"id":"153f0c004c5220ceab94f02849aa399b","title":"常量自动匹配类型","content":"常量自动匹配类型\n\n\n\n\n\n\n\n\n\n问：常量可以自动匹配类型，变量不行？\n\n解：不指定类型的常量叫 Untyped 常量，可以作不同类型使用\n\n","slug":"GO语言/问答/常量自动匹配类型","date":"2024-10-12T02:28:51.592Z","categories_index":"GO语言","tags_index":"技术","author_index":"upstreamboat"},{"id":"ec7107eccfd5005eda9701b5f6d963a9","title":"interface的nil问题","content":"interface 的 nil 问题12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879type People interface &#123;Show()&#125;type Student struct&#123;&#125;func (stu *Student) Show() &#123;&#125;func live() Student &#123;var stu Studentreturn stu&#125;func live2() *Student &#123;var stu *Studentreturn stu&#125;func live3() People &#123;  // 为什么People可以接收*Student：因为是*Student实现的接口方法var stu *Studentreturn stu&#125;func Test05180839(t *testing.T) &#123;r1 := live()r2 := live2()r3 := live3()fmt.Println(&quot;==&gt;&quot;, r1)  // 结果：&#123;&#125;fmt.Println(&quot;==&gt;&quot;, r2)  // 结果：&lt;nil&gt;fmt.Println(&quot;==&gt;&quot;, r3)  // 结果：&lt;nil&gt;//if r1 == nil &#123;  // 编译出错，无法使用==运算符//        fmt.Println(&quot;AAAAAAA&quot;)//&#125; else &#123;//        fmt.Println(&quot;BBBBBBB&quot;)//&#125;if r2 == nil &#123;fmt.Println(&quot;AAAAAAA&quot;)  // 结果：AAAAAAA&#125; else &#123;fmt.Println(&quot;BBBBBBB&quot;)&#125;if r3 == nil &#123;fmt.Println(&quot;AAAAAAA&quot;)&#125; else &#123;fmt.Println(&quot;BBBBBBB&quot;)  // 结果：BBBBBBB&#125;&#125;\n\n\n\n\n\n\n\n\n\n\n问：为什么 r3 &#x3D;&#x3D; nil 的结果是 BBBBBBB？\n\n解：因为 interface 内部构造包含自身元信息+数据信息，这里的 live3()将空的结构体拷贝给了 r3，此时 r3 的数据信息是空的，但是整个 r3 不是空的。如果直接声明一个接口变量 r4，不通过 live()3 赋值，那么 r4 才会等于 nil\n\n","slug":"GO语言/问答/interface的nil问题","date":"2024-10-12T02:28:51.571Z","categories_index":"GO语言","tags_index":"技术","author_index":"upstreamboat"},{"id":"f321918f24ed0ca9b54a2e68f5429a12","title":"map的struct成员不能修改的问题","content":"map 的 struct 成员不能修改的问题1234567891011121314151617181920212223242526272829303132333435type Student struct &#123;Name string&#125;func Test05180839(t *testing.T) &#123;list := make(map[string]Student)student := Student&#123;&quot;Aceld&quot;&#125;list[&quot;student&quot;] = studentlist[&quot;student&quot;].Name = &quot;LDB&quot; // 编译出错&#125;// 解法一：改成指针list := make(map[string]*Student)student := &amp;Student&#123;&quot;Aceld&quot;&#125;list[&quot;student&quot;] = studentlist[&quot;student&quot;].Name = &quot;LDB&quot;// 解法二：中间实例s := list[&quot;student&quot;]list[&quot;student&quot;].Name = &quot;LDB&quot;list[&quot;student&quot;] = s\n","slug":"GO语言/问答/map的struct成员不能修改的问题","date":"2024-10-12T02:28:51.553Z","categories_index":"GO语言","tags_index":"技术","author_index":"upstreamboat"},{"id":"b10f4b877ab4f05d777f7ae5095a9bb3","title":"test文件调用对象nil","content":"test 文件调用对象 nil\n解：因为不是同一个入口：\n\n\n\n\n\n\n\n\n\n因为 global.GVA_DB 是在 main 为入口的程序中初始化的。而 test 文件的入口程序是 Test01()函数，入口进入后，程序重走了一遍，调用的 global.GVA_DB 并未被初始化。\n","slug":"GO语言/问答/test文件调用对象nil","date":"2024-10-12T02:28:51.536Z","categories_index":"GO语言","tags_index":"技术","author_index":"upstreamboat"},{"id":"97c6a169e2ff75f5b4f863321f9f5b4d","title":"context.Done()","content":"context.Done()12345678910funcTest01(t*testing.T)&#123;\tctx,cancel:=context.WithCancel(context.Background())\tcancel()\ta:=&lt;-ctx.Done()\tt.Log(a)\tb:=&lt;-ctx.Done()\tt.Log(b)&#125;\n\n\n\n\n\n\n\n\n\n\n问：\n\na 已经从 Done()返回的通道中接收了值，为什么 b 还可以接收？\n解：\n\n\n\n\n\n\n\n\n\n因为返回的通道是被关闭的，而读取关闭的通道始终能得到类型零值。\n详细说明：\n\n\n\n\n\n\n\n\n\n&lt;-ctx.Done() 返回的是一个只读通道，正常来说读取该通道会被阻塞。而当 cancel()调用时，通道便会被关闭，因此可以读到零值，阻塞解除。 |\n\n","slug":"GO语言/问答/context.Done()","date":"2024-10-12T02:28:51.526Z","categories_index":"GO语言","tags_index":"技术","author_index":"upstreamboat"},{"id":"6e337a8c91273b0f45d11e4949bfd853","title":"几种for循环的区别","content":"几种 for 循环的区别for：遍历字符串和数组for in：遍历对象：遍历对象和数组for of：遍历迭代：遍历可迭代的对象，如：字符串 String、数组 Array、集合 Set、字典 Map、arguments 对象、DOM NodeList 对象foreach：遍历数组：遍历数组for range：go 中语法，range 可以遍历字符串、数组、切片、集合、通道等\n","slug":"GO语言/问答/几种for循环的区别","date":"2024-10-12T02:28:51.514Z","categories_index":"GO语言","tags_index":"技术","author_index":"upstreamboat"},{"id":"70eb90bd33afd4a54f7d747c7178def6","title":"变量存放在栈还是堆","content":"变量存放在栈还是堆\n内存的四个分区：栈：局部变量、参数、返回值\n\n\n\n\n\n\n\n\n\n栈内存会在函数结束时由编译器自动分配和释放\n 堆：如果变量过大（超出栈空间）、大小不定、生命周期超出当前函数（逃逸）\n\n\n\n\n\n\n\n\n\n由 GC 清除机制自动回收Go 编译器会尽可能将变量分配在栈上，但以下例外：\n\n逃逸到堆（涉及到引用类型、超出作用域等情况容易发生逃逸）\n变量很大\n变量大小不固定\n\n 数据段：全局变量、静态变量、常量\n 代码段：程序要执行的指令\n\n逃逸模拟\n 1234func escapeTest() *int &#123;    a := 1    return &amp;a&#125;\n\n\n\n\n\n\n\n\n\n\na 会逃逸到堆，因为函数返回值是指针，指向了函数内部的变量，使得其作用域超出了函数本身。如果将返回值由&amp;a 改成 a，那么便不会逃逸。\n\n逃逸分析命令\n 12345678910111213go run -gcflags &quot;-m -l -N&quot; main.go// -m 用于输出编译器的优化细节// -l 禁用函数的内联（可以缩小程序）// -N 禁止编译优化go build -gcflags &#x27;-m-l&#x27; main.gogo test -gcflags &#x27;-m-l&#x27; my_test.gogo tool compile -m main.go\n\n","slug":"GO语言/问答/变量存放在栈还是堆","date":"2024-10-12T02:28:51.505Z","categories_index":"GO语言","tags_index":"技术","author_index":"upstreamboat"},{"id":"39ce52d8ec0fae0e220b1a2a3082dbfb","title":"Fori循环的坑","content":"Fori 循环的坑为什么 go3 和 go4 循环的结果不一样？\n123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263func TestForI(t *testing.T) &#123;i := 0for ; i &lt; 20; i++ &#123;go func(a int) &#123;t.Log(&quot;go1: &quot;, a)&#125;(i)&#125;for i := 0; i &lt; 20; i++ &#123;go func(a int) &#123;t.Log(&quot;go2: &quot;, a)&#125;(i)&#125;i2 := 0for ; i2 &lt; 20; i2++ &#123;go func() &#123;t.Log(&quot;go3: &quot;, i2) //打印结果可能会出现多个i2为20的情况&#125;()&#125;for i := 0; i &lt; 20; i++ &#123;go func() &#123;t.Log(&quot;go4: &quot;, i)&#125;()&#125;i3 := 0for ; i3 &lt; 20; i3++ &#123;go t.Log(&quot;go5: &quot;, i3)&#125;for i := 0; i &lt; 20; i++ &#123;go t.Log(&quot;go6: &quot;, i)&#125;time.Sleep(time.Second * 5)&#125;\n\n\n\n\n\n\n\n\n\n\n解：\n123456789for i:=0;;&#123;&#125;：每次添加协程，i 都是&quot;新对象&quot;t.Log(&quot;fun: &quot;, sum, &quot; &quot;, i1)t.Log(&quot;fun: &quot;, sum, &quot; &quot;, i2)t.Log(&quot;fun: &quot;, sum, &quot; &quot;, i3)i:=0 for ;;&#123;&#125;：每次添加协程，i 都是&quot;同一个对象&quot;\n","slug":"GO语言/问答/Fori循环的坑","date":"2024-10-12T02:28:51.483Z","categories_index":"GO语言","tags_index":"技术","author_index":"upstreamboat"},{"id":"1c1e8ce0944fee3c20334dec36a45e99","title":"main包下文件不互通","content":"main 包下文件不互通对于非 main 包，程序执行时会加载所有文件。但是对于 main 包，执行时仅加载当前文件，不会加载该包下的其它文件。所以：\n\n\n\n\n\n\n\n\n\nmain 包的当前文件，无法调用 main 包下的其它文件的函数；\n\n解法一：修改配置\n \n\n解法二：全部运行：go run .\n 每个 main 包下的文件，都可以有 main()，它们互不干扰。\n\n\n","slug":"GO语言/问答/main包下文件不互通","date":"2024-10-12T02:28:51.458Z","categories_index":"GO语言","tags_index":"技术","author_index":"upstreamboat"},{"id":"5417553676d67c4e978d7829b36bfe4c","title":"序列化不成功问题","content":"序列化不成功问题\n问题  序列化或反序化时，未报错，但是结果为零值\n原因  结构体内字段首字母未大写  如果是组合结构体，结构体本身的首字母是否大写，不影响序列化\n\n","slug":"GO语言/问答/序列化不成功问题","date":"2024-10-12T02:28:51.449Z","categories_index":"GO语言","tags_index":"技术","author_index":"upstreamboat"},{"id":"fbe3f451ef3390fe6d95e71a94904614","title":"go get错误解决","content":"go get 错误解决windows 系统，配置 GOPROXY 环境变量：\n\n\n\n\n\n\n\n\n\n$env:GOPROXY&#x3D;”https://goproxy.io“\n配置完成后即可进行 go get，例如下载 gin 框架：\n\n\n\n\n\n\n\n\n\ngo get -u github.com&#x2F;gin-gonic&#x2F;gin\n详情参见：https://shockerli.net/post/go-get-golang-org-x-solution/https://blog.csdn.net/qq_43442524&#x2F;article&#x2F;details&#x2F;104900180\n\nidea 中无法自动下载依赖包时，也需要配置代理：\n","slug":"GO语言/问答/go get错误解决","date":"2024-10-12T02:28:51.427Z","categories_index":"GO语言","tags_index":"技术","author_index":"upstreamboat"},{"id":"7a177bd1af93650606e76e93be1a4e1c","title":"chromedp","content":"chromedp跳过人机验证\n123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105package testsimport (&quot;context&quot;&quot;fmt&quot;&quot;github.com/chromedp/chromedp&quot;&quot;testing&quot;&quot;time&quot;)func TestChromedp(t *testing.T) &#123;ctx, _ := chromedp.NewExecAllocator(context.Background(),append(chromedp.DefaultExecAllocatorOptions[:],chromedp.Flag(&quot;user-agent&quot;, &quot;Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/129.0.0.0 Safari/537.36&quot;),chromedp.Flag(&quot;headless&quot;, true),chromedp.Flag(&quot;disable-gpu&quot;, true),chromedp.Flag(&quot;enable-automation&quot;, false), // 去掉自动测试控制chromedp.Flag(&quot;disable-blink-features&quot;, &quot;AutomationControlled&quot;),//chromedp.Flag(&quot;args&quot;, &quot;--proxy-server=socks5://xiren:123456@192.168.2.99:9797&quot;),)...,)ctx, cancel := context.WithTimeout(ctx, 60*time.Second)defer cancel()ctx, _ = chromedp.NewContext(ctx,)defer chromedp.Cancel(ctx) // 可以关闭浏览器if err := chromedp.Run(ctx, chromedp.Tasks&#123;chromedp.ActionFunc(func(ctx context.Context) error &#123;navCtx, _ := context.WithTimeout(ctx, 1*time.Millisecond)err := chromedp.Navigate(&quot;https://www.futbin.com/players&quot;).Do(navCtx)if err != nil &#123;t.Log(err)&#125;return nil&#125;),chromedp.WaitReady(&quot;body&quot;, chromedp.ByQuery),chromedp.ActionFunc(func(ctx context.Context) error &#123;// 获取页面的 HTML 内容var html stringif err := chromedp.Evaluate(`document.documentElement.outerHTML`, &amp;html).Do(ctx); err != nil &#123;return err&#125;// 打印页面的 HTML 内容fmt.Println(html[:500])return nil&#125;),&#125;); err != nil &#123;t.Fatal(err)return&#125;t.Log(&quot;over&quot;)&#125;\n","slug":"GO语言/运用/chromedp","date":"2024-10-12T02:28:09.472Z","categories_index":"GO语言","tags_index":"技术","author_index":"upstreamboat"},{"id":"8c24a3dca6426e0028a82015bf9322f2","title":"selenium","content":"selenium自动化网页控制\n\n下载 chromedriver（这里是 google 浏览器的 webDriver，如果是其它浏览器，则安装对应的 driver）。配置 Path 变量\n下载 selenium-server-standalone.jar\n安装配置 java 环境\n启动服务：java -jar selenium-server-standalone.jar\n运行下面代码：（注：selenium-server-standalone.jar 可以写在代码中）\n\n12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455package testsimport (\t&quot;fmt&quot;\t&quot;github.com/tebeka/selenium&quot;\t&quot;github.com/tebeka/selenium/chrome&quot;\t&quot;log&quot;\t&quot;testing&quot;\t&quot;time&quot;)func TestSelenium(t *testing.T) &#123;\tcaps := selenium.Capabilities&#123;&quot;browserName&quot;: &quot;chrome&quot;&#125;\tchromeCaps := chrome.Capabilities&#123;\t\t//Args: []string&#123;\t\t//        &quot;--disable-blink-features=AutomationControlled&quot;, // 隐藏 WebDriver\t\t//&#125;,\t\tExcludeSwitches: []string&#123;\t\t\t&quot;enable-automation&quot;, // 禁用 Chrome 的自动化控制提示\t\t&#125;,\t&#125;\tcaps.AddChrome(chromeCaps)\twd, err := selenium.NewRemote(caps, &quot; [http://localhost:4444/wd/hub](http://localhost:4444/wd/hub)&quot;)\tif err != nil &#123;\t\tlog.Fatalf(&quot;Error creating new remote session: %v&quot;, err)\t&#125;\tdefer wd.Quit()\t// 打开 Google\tif err := wd.Get(&quot;https://www.futbin.com/players&quot;); err != nil &#123;\t\tlog.Fatalf(&quot;Error navigating to URL: %v&quot;, err)\t&#125;\t// 等待页面加载\ttime.Sleep(2 * time.Second)\tbutton, err := wd.FindElement(selenium.ByName, &quot;cf-turnstile-response&quot;)\tif err != nil &#123;\t\tlog.Fatalf(&quot;Error finding div element with ID &#x27;BQxuW7&#x27;: %v&quot;, err)\t&#125;\tbutton.Click()\twd.Refresh()\t// 等待一段时间，确保页面加载完成（可根据需要调整时间）\ttime.Sleep(2 * time.Second)\t// 获取页面源代码\tsource, err := wd.PageSource()\tif err != nil &#123;\t\tfmt.Println(err)\t&#125;\tfmt.Println(&quot;=============================&gt;&quot;, source)&#125;\n","slug":"GO语言/运用/selenium","date":"2024-10-12T02:28:09.447Z","categories_index":"GO语言","tags_index":"技术","author_index":"upstreamboat"},{"id":"5c3b75c5b899f560262001ebe9925700","title":"切片修改问题","content":"切片修改问题\n正确处理方式\n\n12345678910111213141516171819202122232425262728293031323334353637# 方式一func TestOne(t *testing.T) &#123;var aa = make([]int, 0)oneSet(&amp;aa)t.Log(&quot;result:&quot;, aa) // result:[1]&#125;func oneSet(aa *[]int) &#123;*aa = append(*aa, 1)&#125;# 方式二func TestTwo(t *testing.T) &#123;var aa = make([]int, 0)aa = twoSet(aa)t.Log(&quot;result:&quot;, aa) // result:[1]&#125;func twoSet(aa []int) []int &#123;aa = append(aa, 1)return aa&#125;\n\n\n错误！\n\n123456789101112131415func TestTwo(t *testing.T) &#123;var aa = make([]int, 0)twoSet(aa)t.Log(&quot;result:&quot;, aa) // result:[]&#125;func twoSet(aa []int) &#123;aa = append(aa, 1)&#125;\n\n对上面错误问题分析：\n123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475package testsimport (&quot;fmt&quot;&quot;reflect&quot;&quot;testing&quot;&quot;unsafe&quot;)func TestThree(t *testing.T) &#123;// 创建一个 sliceslice := make([]int, 1, 3)myAppend(slice)fmt.Printf(&quot;数组地址: %p\\t，数组指针: %p\\t，切片地址: %p\\n&quot;, &amp;slice[0], slice, &amp;slice) // 数组地址: 0xc0000141c8        ，数组指针: 0xc0000141c8        ，切片地址: 0xc000008198fmt.Println(&quot;result: &quot;, slice)                                           // result: [2]printArray(slice)&#125;func myAppend(slice2 []int) &#123;  // 分析：地址改变了，说明该slice2是一个拷贝对象slice2 = append(slice2, 1)  // 分析：改变了底层数组内容，但是TestThree()中读取不到slice2[0] = 2  // 分析：改变了底层数组内容，并且TestThree()中能读取到。fmt.Printf(&quot;数组地址: %p\\t，数组指针: %p\\t，切片地址: %p\\n&quot;, &amp;slice2[0], slice2, &amp;slice2) // 数组地址: 0xc0000141c8        ，数组指针: 0xc0000141c8        ，切片地址: 0xc000008180fmt.Println(&quot;myAppend: &quot;, slice2) // myAppend:  [2 1]&#125;// 打印切片对应的底层数组中的内容func printArray(slice []int) &#123;// 获取底层数组的反射值sliceValue := reflect.ValueOf(slice)// 通过反射获取底层数组的指针arrayPtr := sliceValue.Pointer()// 计算底层数组的地址和元素大小elementSize := int(sliceValue.Type().Elem().Size())capacity := sliceValue.Cap()for i := 0; i &lt; capacity; i++ &#123;// 计算元素地址elementAddr := arrayPtr + uintptr(i)*uintptr(elementSize)// 使用 reflect.Value 读取元素值elemValue := reflect.NewAt(sliceValue.Type().Elem(), unsafe.Pointer(elementAddr)).Elem()fmt.Printf(&quot;Element at index %d: %d\\n&quot;, i, elemValue.Interface())&#125;&#125;\n\n\n\n\n\n\n\n\n\n\n输出\ntxt数组地址: 0xc0000141c8        ，数组指针: 0xc0000141c8        ，切片地址: 0xc000008198\nmyAppend:  [2 1]\n数组地址: 0xc0000141c8        ，数组指针: 0xc0000141c8        ，切片地址: 0xc000008180\nresult:  [2]\nElement at index 0: 2\nElement at index 1: 1\nElement at index 2: 0\n\n\n\n\n\n\n\n\n分析\ntxt为什么修改的值能被外层的slice读取到，另一个追加的值却读取不到？\nslice2 = append(slice2, 1)  // 这里需要注意：一旦 append 时导致扩容，那么底层数组就不再是原来的底层数组了\nslice2[0] = 2\n\n\n\n\n\n\n\n\n\n解：\n\ntxt因为slice2和slice虽然不是同一个对象，但其指向的底层数组是同一个，所以slice2追加及修改元素后，底层数组的内容也被改变了。当外层slice读取时，其实此时底层数组中是有两个值的，但是因为slice的len=1，所以只能读取到第一个元素。","slug":"GO语言/运用/切片修改问题","date":"2024-10-12T02:28:09.418Z","categories_index":"GO语言","tags_index":"技术","author_index":"upstreamboat"},{"id":"f57fb855db7eaea05e9d5b8ce9d06bbe","title":"Sprintf","content":"Sprintffmt.Sprintf(&quot;%2d&quot;, i) &#x2F;&#x2F; 输出结果至少占 2 位，不足则在前面补空格，即右对齐fmt.Sprintf(&quot;%-2d&quot;, i) &#x2F;&#x2F; 不足则在后面补空格，即左对齐fmt.Sprintf(&quot;%02d&quot;, i) &#x2F;&#x2F; 不足则在前面补 0\n","slug":"GO语言/运用/Sprintf","date":"2024-10-12T02:28:09.363Z","categories_index":"GO语言","tags_index":"技术","author_index":"upstreamboat"},{"id":"dd2bc7c73e291c4cb3aee29142c35901","title":"响应压缩程度分析","content":"响应压缩程度分析启用压缩：req.Header[“Accept-Encoding”] &#x3D; []string{“br”, “gzip”}\nhttps://www.futbin.com/players?page=1压缩前（字节数）：1382348压缩后（字节数）：129792\nhttps://www.futbin.org/futbin/api/25/fetchPlayerInformation?ID=38110&amp;ap=1.0.1&amp;platform=PC压缩前（字节数）：7694压缩后（字节数）：1652\n","slug":"GO语言/运用/响应压缩程度分析","date":"2024-10-12T02:28:09.341Z","categories_index":"GO语言","tags_index":"技术","author_index":"upstreamboat"},{"id":"5062473f6dc367d31d0bfb5d80270fee","title":"装饰器实例","content":"装饰器实例1234567891011121314151617181920212223242526272829303132333435func add(x, y int) &#123;fmt.Println(x + y)&#125;func sub(x, y int) &#123;fmt.Println(x - y)&#125;func TestAddAndSub(t *testing.T) &#123;decorator(add)(1, 2)decorator(sub)(1, 2)&#125;type handler func(int, int)func decorator(h handler) handler &#123;return func(x int, y int) &#123;fmt.Println(&quot;Before&quot;)h(x, y)fmt.Println(&quot;After&quot;)&#125;&#125;\n","slug":"GO语言/运用/装饰器实例","date":"2024-10-12T02:28:09.329Z","categories_index":"GO语言","tags_index":"技术","author_index":"upstreamboat"},{"id":"65fc3bead86a0d6e48bba450457036ac","title":"有默认值的结构体","content":"有默认值的结构体123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109package testsimport &quot;testing&quot;func TestPerson(t *testing.T) &#123;//p := NewPerson(&quot;Alice&quot;, 25, &quot;alice@example.com&quot;, &quot;1234567890&quot;)p := newPerson2(withName(&quot;Alice&quot;), withAge(25))t.Log(p)&#125;type Person struct &#123;Name  stringAge   intemail stringphone string&#125;func NewPerson(name string, age int, email string, phone string) *Person &#123;return &amp;Person&#123;Name:  name,Age:   age,email: email,phone: phone,&#125;&#125;// Option patterntype Option func(*Person)func newPerson2(options ...Option) *Person &#123;p := &amp;Person&#123;Name:  &quot;fuck&quot;,Age:   1,email: &quot;email&quot;,phone: &quot;phone&quot;,&#125;for _, option := range options &#123;option(p)&#125;return p&#125;func withName(name string) func(*Person) &#123;return func(p *Person) &#123;p.Name = name&#125;&#125;func withAge(age int) func(*Person) &#123;return func(p *Person) &#123;p.Age = age&#125;&#125;func withEmail(email string) func(*Person) &#123;return func(p *Person) &#123;p.email = email&#125;&#125;func withPhone(phone string) func(*Person) &#123;return func(p *Person) &#123;p.phone = phone&#125;&#125;\n","slug":"GO语言/运用/有默认值的结构体","date":"2024-10-12T02:28:09.313Z","categories_index":"GO语言","tags_index":"技术","author_index":"upstreamboat"},{"id":"e7d194280cea056de0f746d5c82db848","title":"目录相关实例","content":"目录相关实例\n遍历目录下的文件，但不遍历子目录\n\n1234567891011121314151617181920212223242526272829303132333435363738394041package mainimport (    &quot;fmt&quot;    &quot;os&quot;    &quot;path/filepath&quot;)func main() &#123;    rootDir := &quot;./your_directory&quot; // 替换为你要遍历的目录    // 打开指定目录    entries, err := os.ReadDir(rootDir)    if err != nil &#123;        fmt.Println(&quot;Error:&quot;, err)        return    &#125;    for _, entry := range entries &#123;        // 仅处理文件，排除目录        if !entry.IsDir() &#123;            fmt.Println(filepath.Join(rootDir, entry.Name())) // 打印文件路径        &#125;    &#125;&#125;\n\n\n确保目录存在\n\n123456789101112131415161718192021222324252627282930313233343536373839// EnsureDir 检查目录是否存在，如果不存在则创建该目录func EnsureDir(path string) error &#123;        fi, err := os.Stat(path)        if err == nil &#123;                // 如果是目录，直接返回                if fi.IsDir() &#123;                        return nil // 目录存在                &#125;                // 目录不存在，但是存在同名文件                return errors.New(&quot;存在同名文件，无法创建目录&quot;)        &#125;        if os.IsNotExist(err) &#123;                // 目录不存在，尝试创建                err := os.MkdirAll(path, os.ModePerm) // 创建目录                if err != nil &#123;                        return err // 返回创建目录时的错误                &#125;        &#125;        return nil // 成功处理&#125;\n","slug":"GO语言/运用/目录相关实例","date":"2024-10-12T02:28:09.284Z","categories_index":"GO语言","tags_index":"技术","author_index":"upstreamboat"},{"id":"35abbd806d5efafaff1901d4654f89d1","title":"易错知识","content":"易错知识\nstrings.Clone\n\n12345678910111213141516171819// 假设输入的log长度为1000字节// uuid新分配了36字节，但是已经无用的log仍然占用1000字节没有释放，导致内存泄漏func handleLog(log string)&#123;uuid := log[:36]...&#125;// strings.CLone()可以自动释放内存func handleLog(log string)&#123;uuid :=strings.Clone(log[:36])...&#125;\n\n\nnil 调用方法\n\n123456789101112131415type Foo struct &#123;&#125;func （foo *Foo)Bar() string &#123;return &quot;bar&quot;&#125;func main（）&#123;var foo *Foofmt.Println（foo.Bar()）// 可以成功调用并打印。因为foo的值虽然是nil，但其类型是*Foo，是可以调用方法的，只是传入Bar()方法中的foo是nil罢了&#125;\n","slug":"GO语言/运用/易错知识","date":"2024-10-12T02:28:09.260Z","categories_index":"GO语言","tags_index":"技术","author_index":"upstreamboat"},{"id":"7b61dbd7da63db21b1595dbf2fd4ec11","title":"切片运用","content":"切片运用\n去重\n\n1234567891011121314151617181920212223func removeDuplicates(s []int) []int &#123; // 使用一个 map 来记录出现过的元素 seen := make(map[int]bool) result := []int&#123;&#125; for _, v := range s &#123; if !seen[v] &#123; seen[v] = true result = append(result, v) &#125; &#125; return result &#125;\n\n\n有序切片查找\n  sort.Find()：二分查找，查找有序切片中的元素，返回当前元素应该插入的索引位置和是否已存在该元素\n  sort.Search()：二分查找，仅返回插入位置，无法判断是否已存在\n  slices.Contains：遍历查找，切片无需是有序的\n\n\n","slug":"GO语言/运用/切片运用","date":"2024-10-12T02:28:09.243Z","categories_index":"GO语言","tags_index":"技术","author_index":"upstreamboat"},{"id":"cc48c84a0b269510bff4cfddc4b4c58f","title":"http使用代理","content":"http 使用代理学习\n\nhttp1.1 使用代理：\n\n12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879package mainimport (  &quot;io&quot;  &quot;log&quot;  &quot;net/http&quot;  &quot;net/url&quot;)func main() &#123;  // 代理服务器地址  proxyURL, err := url.Parse(&quot;http://proxy.example.com:8080&quot;)  if err != nil &#123;    log.Fatal(err)  &#125;  // 创建Transport对象  // 客户端最重要的是配置Transport，所谓Transport就是底层的连接管理器，包括了协议的处理能力。  transport := &amp;http.Transport&#123;    Proxy: http.ProxyURL(proxyURL),  &#125;  // 创建Client对象  client := &amp;http.Client&#123;    Transport: transport,  &#125;  // 创建HTTP请求  req, err := http.NewRequest(&quot;GET&quot;, &quot; [http://restricted-website.com/video](http://restricted-website.com/video)&quot;, nil)  if err != nil &#123;    log.Fatal(err)  &#125;  // 发送请求  resp, err := client.Do(req)  if err != nil &#123;    log.Fatal(err)  &#125;  defer resp.Body.Close()  // 读取响应  body, err := io.ReadAll(resp.Body)  if err != nil &#123;    log.Fatal(err)  &#125;  log.Println(string(body))&#125;\n\n\nhttp2 客户端代码：  参考 1  参考 2\n\n1234567// 配置TLSClientConfig，跳过TLS验证transport = &amp;http.Transport&#123;\tTLSClientConfig: &amp;tls.Config&#123;InsecureSkipVerify: true,&#125;&#125;// 启动HTTP/2协议http2.ConfigureTransport(transport)\n\n\nhttps 生成证书：  https://learnku.com/articles/84875\n\n","slug":"GO语言/运用/http使用代理","date":"2024-10-12T02:28:09.228Z","categories_index":"GO语言","tags_index":"技术","author_index":"upstreamboat"},{"id":"138178ff8fefae8d453b88a44dba3762","title":"库--local_cache","content":"库–local_cache12345678910111213141516171819202122232425262728293031323334353637import &quot;github.com/songzhibin97/gkit/cache/local_cache&quot;func Test071904(t *testing.T) &#123;// local_cache.Cache是一个可以存储k、v及其过期时间的对象ch := local_cache.NewCache(// 设置自动检测是否过期的间隔时间local_cache.SetInternal(6*time.Second),// 设置默认过期时间local_cache.SetDefaultExpire(100*time.Second),// 当key被删除时，调用该函数local_cache.SetCapture(func(k string, v interface&#123;&#125;) &#123; log.Println(k, v) &#125;),)// 添加k、v、过期时间ch.Add(&quot;haha&quot;, &quot;dd&quot;, 10*time.Second)// 根据k获取vt.Log(ch.Get(&quot;haha&quot;)) // 如果k已过期，但又尚未被自动删除，调用Get会返回nil并删除ktime.Sleep(11 * time.Second)// 当过期自动删除后，再次获取便是nil了t.Log(ch.Get(&quot;haha&quot;))&#125;\n\n\ntxt别人发布的库，可以看下原码\n","slug":"GO语言/运用/库--local_cache","date":"2024-10-12T02:28:09.201Z","categories_index":"GO语言","tags_index":"技术","author_index":"upstreamboat"},{"id":"0363533ce4954d4e525c36bb03abdb08","title":"库--rand","content":"库–rand使用有种子的随机数，不可以放在循环内部，否则 1s 内产生的数是一样的\n1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253func Test071903(t *testing.T) &#123;\t// 有种子的随机数\tr := rand.New(rand.NewSource(time.Now().Unix()))\tfor i := 0; i &lt; 10; i++ &#123;\t\tfmt.Printf(&quot;%d &quot;, r.Int31())\t&#125;\tfmt.Println()\t// 注意：这个循环生成的10个随机数是一样的\tfor i := 0; i &lt; 10; i++ &#123;\tr2 := rand.New(rand.NewSource(time.Now().Unix()))\tfmt.Printf(&quot;%d &quot;, r2.Int31n(100))\t&#125; // 输出：10 10 10 10 10 10 10 10 10 10\tfmt.Println()\t// 注意：这个又不一样了\tfor i := 0; i &lt; 10; i++ &#123;\tr2 := rand.New(rand.NewSource(time.Now().Unix()))\ttime.Sleep(1 * time.Second)\tfmt.Printf(&quot;%d &quot;, r2.Int31n(100))\t&#125; // 输出：10 43 37 11 64 45 12 21 27 0\tfmt.Println()\t// 无种子的随机数\tfor i := 0; i &lt; 10; i++ &#123;\tfmt.Printf(&quot;%f &quot;, rand.Float32())\t&#125;\t// 为m填充[0，255]的随机数\tm := make([]byte, 5)\tr.Read(m)\tfmt.Println(m)&#125;\n","slug":"GO语言/运用/库--rand","date":"2024-10-12T02:28:09.181Z","categories_index":"GO语言","tags_index":"技术","author_index":"upstreamboat"},{"id":"f96eba7199e848384d3be5daad87b13c","title":"time.NewTicker","content":"time.NewTicker123456789101112131415161718192021func Test071801(t *testing.T) &#123;\tticker := time.NewTicker(2 * time.Second)\tdefer ticker.Stop()\tdone := make(chan struct&#123;&#125;)\tgo func() &#123;\t\ttime.Sleep(10 * time.Second)\t\tdone &lt;- struct&#123;&#125;&#123;&#125;\t&#125;()\tfor &#123;\t\tselect &#123;\t\tcase &lt;-done:\t\t\tfmt.Println(&quot;Done!&quot;)\t\t\treturn\t\tcase t := &lt;-ticker.C:\t\t\tfmt.Println(&quot;Current time: &quot;, t)\t\t&#125;\t&#125;&#125;\n","slug":"GO语言/运用/time.NewTicker","date":"2024-10-12T02:28:09.162Z","categories_index":"GO语言","tags_index":"技术","author_index":"upstreamboat"},{"id":"0b61b6d43976c230e2053566cae9a303","title":"fmt换行才打印","content":"fmt 换行才打印12345678910111213func Test071902(t *testing.T) &#123;\tfmt.Print(&quot;code1 &quot;, &quot;\\t&quot;) // 不会立即打印\tfmt.Printf(&quot;code2 \\t&quot;)    // 不会立即打印\ttime.Sleep(2 * time.Second)\tfmt.Println(&quot;code3 &quot;) // 立即打印，且先打印出code1、code2\tfmt.Print(&quot;code4 &quot;, &quot;\\t&quot;) // 不会立即打印\ttime.Sleep(2 * time.Second)\tfmt.Printf(&quot;code5 \\n&quot;) // 立即打印，且先打印出code4&#125;// fmt只有遇到换行时才会打印，它输出的是：所记录的一整行的内容\n\n\ntxt结论：fmt只有遇到换行时才会打印，它输出的是：所记录的一整行的内容\n","slug":"GO语言/运用/fmt换行才打印","date":"2024-10-12T02:28:09.149Z","categories_index":"GO语言","tags_index":"技术","author_index":"upstreamboat"},{"id":"290315f829352024de0eee0b027da398","title":"select-case随机","content":"select-case 随机1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071var (c1   = make(chan int, 5)c2   = make(chan int, 5)c3   = make(chan int, 5)done = make(chan struct&#123;&#125;))func Test071901(t *testing.T) &#123;go func() &#123;for i := 0; i &lt; 5; i++ &#123;c1 &lt;- 1c2 &lt;- 2c3 &lt;- 3time.Sleep(2 * time.Second)&#125;&#125;()go func() &#123;time.Sleep(10 * time.Second)done &lt;- struct&#123;&#125;&#123;&#125;&#125;()fuck()t.Log(&quot;game over&quot;)&#125;func fuck() &#123;for &#123;select &#123;case n := &lt;-c1:fmt.Println(n)case m := &lt;-c2:fmt.Println(m)case l := &lt;-c3:fmt.Println(l)case &lt;-done:return&#125;&#125;&#125;\n\n输出：\ntxt1\n1\n3\n2\n3\n1\n1\n3\n3\n// 解析：1、2、3的分布不均、且顺序不一致，可见是随机的","slug":"GO语言/运用/select-case随机","date":"2024-10-12T02:28:09.137Z","categories_index":"GO语言","tags_index":"技术","author_index":"upstreamboat"},{"id":"dfcfc60acea6f8943904320d565ee8ae","title":"创建client实例","content":"创建 client 实例mysqlClient\n123456789101112131415161718192021222324252627282930313233func initDB() *gorm.DB &#123;username := &quot;root&quot;password := &quot;root&quot;host := &quot;127.0.0.1&quot;port := 3306dbName := &quot;myDB&quot;timeout := &quot;10s&quot;dsn := fmt.Sprintf(&quot;%s:%s@tcp(%s:%d)/%s?&quot;+&quot;charset=utf8&amp;parseTime=True&amp;loc=Local&amp;timeout=%s&quot;,username, password, host, port, dbName, timeout)//连接数据库db, err := gorm.Open(mysql.Open(dsn), &amp;gorm.Config&#123;&#125;)if err != nil &#123;panic(&quot;database connect failed&quot;)&#125;return db&#125;\n\nredisClient\n12345678910111213141516171819202122232425262728293031// initRedis 创建redis客户端func initRedis() *redis.Client &#123;client := redis.NewClient(&amp;redis.Options&#123;Addr:     &quot;127.0.0.1:6379&quot;,Password: &quot;&quot;, // no password setDB:       0,  // use default DB&#125;)pong, err := client.Ping(context.Background()).Result()if err != nil &#123;fmt.Println(&quot;redis :&quot;, err)return nil&#125; else &#123;fmt.Println(pong)&#125;return client&#125;\n\nCloudByPassClient\n123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051type CloudByPassClient struct &#123;apiKey     string        // 穿云密钥redis      *redis.Client // 使用redis缓存ctx        context.ContexthttpClient *http.Clientprefix     string        // 保存前缀expiration time.Duration // 缓存时间retryCount int           // 重试次数proxy      string        // 代理字符串形式&#125;// newFutbinClient 创建穿云代理客户端func newFutbinClient() *futbinclient.CloudByPassClient &#123;redisClient := initRedis()ctx := context.Background()cloudByPassClient := futbinclient.NewCloudByPass(&quot;2e05e7b9516249499197ad0c5ee79266&quot;,redisClient,ctx,futbinclient.PrefixKaku,7200*time.Second,5,7200*time.Second,&quot;socks5://77691636-dat_TR:bvxjdvxt@gw.cloudbypass.com:1288&quot;,)return cloudByPassClient&#125;\n","slug":"GO语言/运用/创建client实例","date":"2024-10-12T02:28:09.112Z","categories_index":"GO语言","tags_index":"技术","author_index":"upstreamboat"},{"id":"93f99ad47b857fa13d267d1a61a27ce9","title":"内联优化_内存对齐","content":"内联优化&#x2F;内存对齐\n**内联优化**：就是把一些简短的函数在调用它的地方展开。因为调用函数会有性能开销，内联优化后可以缩短代码运行时间。【 https://studygolang.com/articles/28335】\n\n1234567891011121314151617181920212223242526272829// go:noinlinefunc max(a, b int) int &#123;if a &gt; b &#123;return a&#125;return b&#125;func BenchmarkMax(b *testing.B) &#123;var r intfor i := 0; i &lt; b.N; i++ &#123;r = max(-1, i)&#125;_ = r&#125;// 解除首行注释go:noinline，执行时间会大幅缩短\n\n\ntxt解除首行注释go:noinline，执行时间会大幅缩短\n\n**内存对齐**：是为了适应 CPU 对结构体数据进行快速访问。cpu 一次访问数据位数（即字长）是固定的，32 位系统是 4 字节，64 位系统是 8 字节。对齐规则：略使用：知道编译器会进行内存对齐即可，无需特意关注【 https://segmentfault.com/a/1190000045042365】\n\n","slug":"GO语言/运用/内联优化_内存对齐","date":"2024-10-12T02:28:09.083Z","categories_index":"GO语言","tags_index":"技术","author_index":"upstreamboat"},{"id":"516f488d0899eefbc39ef09d7fd24821","title":"空结构体","content":"空结构体\n空结构体的使用场景：【 https://developer.aliyun.com/article/1230762】\n\n实现  Set  集合类型\n用于通道信号\n作为方法接收器\n\n\n空结构体不占用内存，字节大小为 0\n\n所有空结构体地址相同：\n\n\n\n\n\n\n\n\n\n在Go语言中，所有针对 size==0 的内存分配，用的都是同一个地址 &amp;zerobase（zerobase是runtime包中的变量）\n\n空结构体比较与变量逃逸\n\n未逃逸时，空结构体比较：false。\n\n\n\n\n\n\n\n\n\n\n因为编译器自动优化代码，直接将比较表达式转成 false 常量，实际并没有进行比较如果关闭编译优化，让其进行比较，则结果为 true\n\n变量逃逸到堆时，空结构体比较：true。\n\n还是有些地方没搞懂，强记结论：逃逸，比较地址为 true；未逃逸，比较地址为 false**。**\n\nCode\n\n\n123456789// 未逃逸，编译优化a := &amp;struct&#123;&#125;&#123;&#125;b := &amp;struct&#123;&#125;&#123;&#125;// 因为代码进行了编译优化，所以地址相等，但结果不相等println(a, b, a == b) // go run main.go: 0xc000055f40 0xc000055f40 false// 关闭编译优化-N，结果便相等了println(a, b, a == b) // go run -gcflags &quot;-m -N -l&quot; main.go: 0xc000055f1f 0xc000055f1f true\n\n1234567a := struct&#123;&#125;&#123;&#125;b := struct&#123;&#125;&#123;&#125;println(&amp;a, &amp;b, a == b)   // go run -gcflags &quot;-m -N -l&quot; main.go: 0xc000055f1e 0xc000055f1e trueprintln(&amp;a, &amp;b, &amp;a == &amp;b) // go run -gcflags &quot;-m -N -l&quot; main.go: 0xc000055f1e 0xc000055f1e false// 不知道为啥这里为false？\n\n\ntxt不知道为啥这里为 false\n12345678910111213141516171819202122232425262728// 逃逸a := struct&#123;&#125;&#123;&#125;b := struct&#123;&#125;&#123;&#125;x := struct&#123;&#125;&#123;&#125;y := struct&#123;&#125;&#123;&#125;m := [10]struct&#123;&#125;&#123;&#125;n := [10]struct&#123;&#125;&#123;&#125;o := [10]struct&#123;&#125;&#123;&#125;p := [10]struct&#123;&#125;&#123;&#125;// 空结构体对象，不占用内存空间，直接使用go内部变量zerobase的地址，因此它们的地址是相同的。//println(&amp;x, &amp;y, &amp;o, &amp;p) // 0xc000065eff 0xc000065eff 0xc000065eff 0xc000065eff\t// 没有变量发生逃逸//println(&amp;a == &amp;b) // false//println(&amp;x == &amp;y) // false//println(&amp;a == &amp;x) // false//println(&amp;m == &amp;n) // false//println(&amp;o == &amp;p) // false//println(&amp;n == &amp;p) // false// 使用了fmt.Printf后，x、y、o、p将逃逸到了堆上，但是a、b、m、n则开辟在栈上。fmt.Printf(&quot;%p,%p,%p,%p\\n&quot;, &amp;x, &amp;y, &amp;o, &amp;p) // 0x5f73a0,0x5f73a0,0x5f73a0,0x5f73a0println(&amp;a == &amp;b)                           // falseprintln(&amp;x == &amp;y)                           // trueprintln(&amp;a == &amp;x)                           // falseprintln(&amp;m == &amp;n)                           // falseprintln(&amp;o == &amp;p)                           // trueprintln(&amp;n == &amp;p)                           // false\n","slug":"GO语言/运用/空结构体","date":"2024-10-12T02:28:09.066Z","categories_index":"GO语言","tags_index":"技术","author_index":"upstreamboat"},{"id":"b300acae605253324e173dcf841400a6","title":"map实现 Set 集合","content":"map 实现 Set 集合在 Go 语言中，虽然没有内置 Set 集合类型，但是我们可以利用 map 类型来实现一个 Set 集合。由于 map 的 key 具有唯一性，我们可以将元素存储为 key，而 value 没有实际作用，为了节省内存，我们可以使用空结构体作为 value 的值。\n1234567891011121314151617181920212223242526272829303132333435363738394041424344454647package mainimport &quot;fmt&quot;type Set[K comparable] map[K]struct&#123;   &#125;func (s Set[K]) Add(val K) &#123;   s[val] = struct&#123;   &#125;&#123;   &#125;&#125;func (s Set[K]) Remove(val K) &#123;   delete(s, val)&#125;func (s Set[K]) Contains(val K) bool &#123;   _, ok := s[val]   return ok&#125;func main() &#123;   set := Set[string]&#123;   &#125;   set.Add(&quot;陈明勇&quot;)   fmt.Println(set.Contains(&quot;陈明勇&quot;)) // true   set.Remove(&quot;陈明勇&quot;)   fmt.Println(set.Contains(&quot;陈明勇&quot;)) // false&#125;\n","slug":"GO语言/运用/map实现 Set 集合","date":"2024-10-12T02:28:09.017Z","categories_index":"GO语言","tags_index":"技术","author_index":"upstreamboat"},{"id":"e29ae464d621fed07faf5e91c32ff035","title":"类型转换--隔代转换","content":"类型转换–隔代转换12345678910111213141516171819202122232425262728293031type MyInt int64type Ta *int64type Tb *MyIntfunc Test070901(t *testing.T) &#123;var a Tavar b Tb//a = Ta(b) // error: 直接转换是不允许的。//x := (*int64)(b)  // error: 直接转换是不允许的。// 但是间接转换是允许的。y := (*MyInt)(b)x := (*int64)(y)a = x           // 等价于下一行a = (*int64)(y) // 等价于下一行a = (*int64)((*MyInt)(b)) // 正确的转换，也就是说：不允许隔代转换_ = a&#125;\n","slug":"GO语言/运用/类型转换--隔代转换","date":"2024-10-12T02:28:08.999Z","categories_index":"GO语言","tags_index":"技术","author_index":"upstreamboat"},{"id":"65dcb41ccb2b7348744094a414c03b53","title":"换行自动插入分号","content":"换行自动插入分号go 编译器的特性：在某些换行处自动插入分号\n1234567891011121314151617181920212223242526272829func Test070801(t *testing.T) &#123;switch False() &#123;// 这里的大括号换行了，代码就相当于switch False(); &#123;// switch条件表达式缺失时，默认是true，所以又相当于switch False(); true &#123;case true:fmt.Println(&quot;true&quot;)case false:fmt.Println(&quot;false&quot;)&#125;&#125;func False() bool &#123;return false&#125;// 输出：// true\n\n123456789101112131415161718192021222324func Test070801(t *testing.T) &#123;switch False()&#123;case true:fmt.Println(&quot;true&quot;)case false:fmt.Println(&quot;false&quot;)&#125;&#125;func False() bool &#123;return false&#125;// 输出：// false\n","slug":"GO语言/运用/换行自动插入分号","date":"2024-10-12T02:28:08.986Z","categories_index":"GO语言","tags_index":"技术","author_index":"upstreamboat"},{"id":"7c71614bf2ff20dbc5184b9c2a0f2d06","title":"打印斐波那契数列","content":"打印斐波那契数列1234567891011121314151617181920212223242526272829// 递归函数打印：0,1,1,2,3,5,8......func calculateFibonacci(n int) (result int) &#123;if n &lt; 2 &#123;return n&#125;result = calculateFibonacci(n-2) + calculateFibonacci(n-1)return&#125;func main() &#123;//递归函数: 打印Fibonacci数列for i := 0; i &lt; 10; i++ &#123;print(calculateFibonacci(i), &quot;\\t&quot;)&#125;println()&#125;\n","slug":"GO语言/运用/打印斐波那契数列","date":"2024-10-12T02:28:08.961Z","categories_index":"GO语言","tags_index":"技术","author_index":"upstreamboat"},{"id":"d10ea42c1ce664119ee09c3435f4ddbf","title":"交叉编译","content":"交叉编译\ngo 程序直接编译后是无法在其它系统运行的，需要交叉编译\n参考\n注意：windows 下进行编译时要 cmd，不能用 powershell\n\n1234// 如果要编译为其它平台，需要修改env。可能还需要额外设置CGO_ENABLED=0go env -w GOOS=windowsgo env -w GOARCH=amd64go build -o myApp\n","slug":"GO语言/运用/交叉编译","date":"2024-10-12T02:28:08.947Z","categories_index":"GO语言","tags_index":"技术","author_index":"upstreamboat"},{"id":"48f4f35d1dec4436bd9374417da9efa8","title":"字节切片原样写入文件","content":"字节切片原样写入文件将字节切片原样写入文件：\n123// 原数据b := []byte&#123;26, 5, 18, 3, 8, 150, 1&#125;s := fmt.Sprintf(&quot;%v&quot;, b)\n\n\n\n\n\n代码\n文件中结果\n\n\n\n测试 1\nfile.WriteString(s)\n[26 5 18 3 8 150 1]\n\n\n测试 2\nfile.Write(b)\n\u001a\u0005\u0012\u0003\b \u0001\n\n\n测试 3\nfile.Write(json.marshal(b))\n&quot;GgUSAwiWAQ==&quot;\n\n\n测试 4\nfile.Write(json.marshal(s))\n[26 5 18 3 8 150 1]\n\n\n\n\n\n\n\n\n\n\n\n可见只有测试 1 是正确的\n","slug":"GO语言/运用/字节切片原样写入文件","date":"2024-10-12T02:28:08.937Z","categories_index":"GO语言","tags_index":"技术","author_index":"upstreamboat"},{"id":"61905ffd46add556f1be34610df1a4c5","title":"关于文件读取的坑","content":"关于文件读取的坑打开文件123456789file, err := os.OpenFile(&quot;./input.txt&quot;, os.O_CREATE|os.O_RDWR, os.ModePerm)if err != nil &#123;    panic(fmt.Sprintf(&quot;Open file error: %s&quot;, err))&#125;defer file.Close()\n\n读取文件\n\n\n\n\n\n\n\n\n使用 bytes.Buffer 是可以正常读取的\n123b := &amp;bytes.Buffer&#123;&#125;_, err = b.ReadFrom(file)fmt.Println(b.Bytes())\n\n\n\n\n\n\n\n\n\n\n但是使用 file.Read 读不出来东西，也没有报错\n123456789srcData := make([]byte, 0)n, err := file.Read(srcData)if err != nil &#123;    panic(fmt.Sprintf(&quot;readInput error: %s&quot;, err))&#125;\n\n\n\n\n\n\n\n\n\n\nfile.Read 正确的写法：（原因是因为 read 每次读取固定长度的字节，如果切片长度为 0 ，那么读取的就是 0 个字节）\n1234567891011121314151617181920212223srcData := make([]byte, 0)for &#123;    buf := make([]byte, 10)    _, err = file.Read(buf)    if err != nil &#123;        if err == io.EOF &#123;            break        &#125;        panic(fmt.Sprintf(&quot;readInput error: %s&quot;, err))    &#125;    srcData = append(srcData, buf...)&#125;\n\n文件读写\n简单读\n\n1234567891011121314151617181920212223// lazy 将球员详细信息从文件加载到内存func (m *massInfos) lazy() &#123;m.once.Do(func() &#123;data, err := os.ReadFile(&quot;resource/game/playerMassInfo.json&quot;)if err != nil &#123;global.GVA_LOG.Fatal(&quot;加载球员详细信息失败&quot;, zap.Error(err))&#125;if err = json.Unmarshal(data, m); err != nil &#123;global.GVA_LOG.Fatal(&quot;解析球员详细信息失败&quot;, zap.Error(err))&#125;&#125;)&#125;\n\n\n缓冲读\n  12345678910111213141516171819202122232425262728293031func readInput3() []string &#123;inputFile, err := os.Open(&quot;./dataId2.txt&quot;)if err != nil &#123;fmt.Println(&quot;os.Open error: &quot;, err)return nil&#125;defer inputFile.Close()buf := &amp;bytes.Buffer&#123;&#125;_, err = buf.ReadFrom(inputFile)if err != nil &#123;fmt.Println(&quot;buf.ReadFrom error: &quot;, err)return nil&#125;dataIds := strings.Split(buf.String(), &quot;,&quot;)return dataIds&#125;\n\n序列化后写\n\n\n1234567891011121314151617181920212223242526272829303132333435// writeOutput 输出写入文件func writeOutput() &#123;jsonData, err := json.MarshalIndent(&amp;result, &quot;&quot;, &quot;  &quot;)if err != nil &#123;fmt.Println(&quot;json.Marshal error: &quot;, err)return&#125;outputFile, err := os.OpenFile(&quot;../resource/game/playerMassInfo.json&quot;, os.O_CREATE|os.O_RDWR|os.O_TRUNC, 0777)if err != nil &#123;fmt.Println(&quot;OpenFile error: &quot;, err)return&#125;defer outputFile.Close()_, err = outputFile.Write(jsonData)if err != nil &#123;fmt.Println(&quot;file.Write error: &quot;, err)&#125;&#125;\n","slug":"GO语言/运用/关于文件读取的坑","date":"2024-10-12T02:28:08.922Z","categories_index":"GO语言","tags_index":"技术","author_index":"upstreamboat"},{"id":"7d5dd673ed6b043bd52abfc3df092197","title":"解决并发中的数据竞争","content":"解决并发中的数据竞争\n发生竞争的例子：\n  1234567891011121314151617181920212223242526272829func Test01(t *testing.T) &#123;    sum := int32(0)    wg := sync.WaitGroup&#123;&#125;    for i := 0; i &lt; 1000; i++ &#123;        wg.Add(1)        go func() &#123;        sum++ // 多个协程会争抢sum，导致结果不如预期            wg.Done()        &#125;()    &#125;    wg.Wait()    t.Log(sum)&#125;// 预期结果1000// 实际结果996\n\n避免竞争\n\n\n\n法一：设置为单核 CPU\n1runtime.GOMAXPROCS(1)\n\n法二：使用 atomic 原子操作\n1atomic.AddInt32(&amp;sum, 1)\n\n法三：加互斥锁\n1lock := sync.Mutex&#123;&#125;\n\n","slug":"GO语言/运用/解决并发中的数据竞争","date":"2024-10-12T02:28:08.885Z","categories_index":"GO语言","tags_index":"技术","author_index":"upstreamboat"},{"id":"ffad629c88d3973ffcc37250426c5ddb","title":"关于gorm参数问题","content":"关于 gorm 参数问题\n\n\n\n\n\n\n\n\n\n\nvar user *models.User\nvar user *models.User &#x3D; &amp;models.User{}\nvar user models.User &#x3D; models.User{}\n\n\nglobal.App.DB.First(&amp;user, id)\nok\nok\nok\n\n\nglobal.App.DB.First(user, id)\nerror（because user is nil）\nok\nerror（because user is unadressable）\n\n\n","slug":"GO语言/运用/关于gorm参数问题","date":"2024-10-12T02:28:08.867Z","categories_index":"GO语言","tags_index":"技术","author_index":"upstreamboat"},{"id":"4fd198b7eacb73f09ceb8fc86c69789a","title":"自定义类型可以有方法","content":"自定义类型可以有方法\n自定义类型有两种：\n\n结构体\n别名\n\n\n自定义类型可以有方法：    ​go 中非引用类型的变量在声明后便已经分配内存了，可以直接使用 ​\n  123456789101112131415161718//type IT struct &#123;&#125;type IT intfunc (t *IT) fun01() &#123;    println(&quot;p-fun01&quot;)&#125;func Test1356(t *testing.T) &#123;    var a IT    fmt.Println(a)    a.fun01()  // go中非引用类型的变量在声明后便已经分配内存了，因此可以调用方法&#125;\n\n","slug":"GO语言/运用/自定义类型可以有方法","date":"2024-10-12T02:28:08.854Z","categories_index":"GO语言","tags_index":"技术","author_index":"upstreamboat"},{"id":"88143d9759619260f83f1d39234583ee","title":"切片扩容机制","content":"切片扩容机制\n学习（扩容机制从视频 4min 开始）学习 2\n\n总结：：\n\n第一步：计算容量\n\n1234567891011121314var needCap int     // 所需容量var oldCap int      // 当前容量var newCap int      // 扩容后新容量var threshold = 256  // 默认阈值if needCap &gt; oldCap*2 &#123;\tnewCap = needCap&#125; else if oldCap &lt; threshold &#123;\tnewCap = oldCap * 2&#125; else if oldCap &gt;= threshold &#123;\tfor newCap &lt; needCap &#123;\t\tnewCap += (newCap + 3*threshold) / 4\t&#125;&#125;\n\ntxt- 如果所需容量大于当前容量的两倍，则使用所需容量\n- 如果当前容量小于阈值（默认 256），则将容量翻倍\n- 如果当前容量大于等于阈值（默认 256），则进行公示运算，直到新容量大于所需容量\n第二步：内存对齐\n\n\n\n\n\n\n\n\n\n\n注意：这里计算得到的新容量不一定就是真正的容量，因为还需要进行“内存对齐”操作 ：\n\n内存管理模块在分配内存时都是 8 的偶数倍，如：8、16、32、48、64、80…例如，当新容量&#x3D;5，5*8&#x3D;40，32&lt;40&lt;48，故，实际容量&#x3D;48（即 6 个字节，而不是 5 个字节）\n\n\n例子：\n123i1 := []int&#123;1, 2&#125;i1 = append(i1, 3, 4, 5)fmt.Println(cap(i1))  // cap = 6\n\n由切片扩容带来的陷阱：\n12345678910111213141516171819func Test01(t *testing.T) &#123;a := []int&#123;1, 2&#125;foo(a)fmt.Printf(&quot;Test01(): a=%v cap(a)=%v &amp;a[0]=%p\\n&quot;, a, cap(a), &amp;a[0])&#125;func foo(a []int) &#123;a = append(a, 1)a[0] = 200fmt.Printf(&quot;foo(): a=%v cap(a)=%v &amp;a[0]=%p\\n&quot;, a, cap(a), &amp;a[0])&#125;\n\n输出：foo(): a&#x3D;[200 2 1] cap(a)&#x3D;4 &amp;a[0]&#x3D;0xc000018240Test01(): a&#x3D;[1 2] cap(a)&#x3D;2 &amp;a[0]&#x3D;0xc00000a330\n解析：切片 a 是引用类型，传递的是指针，但是 foo()中修改 a 值并未对 Test01()的 a 产生影响，而且二者地址也不一样。这是因为切片 a 容量只有 2，在 foo()中 append 后发生扩容，指向的底层数组改变了，所以修改 foo 的 a 对原切片无影响。\n\n\n","slug":"GO语言/运用/切片扩容机制","date":"2024-10-12T02:28:08.838Z","categories_index":"GO语言","tags_index":"技术","author_index":"upstreamboat"},{"id":"190cfd3d8a5d6fa37d4aa68b376ffe75","title":"oauth2","content":"oauth2参考教程参考代码\n\n创建 Manager 实例：manage.NewDefaultManager()\n\n\n\n\n\n\n\n\n\n配置 Manager 参数（该代码文件此处略过）Manager 接口映射：\n\n\n\n\n\n\n\n\n\n\nMustTokenStorage、MapClientStorage 等\n\n\n创建 Server 实例：server.NewServer(server.NewConfig(), manager)\n\n\n\n\n\n\n\n\n\n配置 Server 参数：\n\nSetAllowedGrantTypeSetAllowedResponseType\n\n\n\n\n\n\n\n\n\n\n配置处理函数：\n\n\n\n\n\n\n\n\n\n\nSetClientInfoHandlerSetUserAuthorizationHandlerSetPasswordAuthorizationHandlerSetAllowGetAccessRequest\n\n\n创建 HTTP 监听服务：\n\n\n\n\n\n\n\n\n\n授权请求处理：http.HandleFunc(&quot;/oauth2/authorize&quot;, function1)令牌请求处理：http.HandleFunc(&quot;/oauth2/token&quot;, function2)\n\n\n","slug":"GO语言/运用/oauth2","date":"2024-10-12T02:28:08.811Z","categories_index":"GO语言","tags_index":"技术","author_index":"upstreamboat"},{"id":"104a04f019093d49c64f9c53c970de59","title":"读取net.conn","content":"读取 net.connbufio.NewReader(conn)\nio.ReadAll(conn)\nconn.Read(dataByte)\nnew(bytes.Buffer).ReadFrom(conn)\n","slug":"GO语言/运用/读取net.conn","date":"2024-10-12T02:28:08.801Z","categories_index":"GO语言","tags_index":"技术","author_index":"upstreamboat"},{"id":"b45dbc450e5bc065731c9485342bab81","title":"Fatal、panic、Exit的区别","content":"Fatal、panic、Exit 的区别\nos.Exit()：程序退出，defer 不会执行\nlog.Fatal()：打印日志，程序退出，defer 不会执行\npanic()：函数停止，栈中的 defer 陆续执行，程序退出\n\n","slug":"GO语言/运用/Fatal、panic、Exit的区别","date":"2024-10-12T02:28:08.793Z","categories_index":"GO语言","tags_index":"技术","author_index":"upstreamboat"},{"id":"a68516acfce98009045c4d56a3a6c1f1","title":"测试--性能","content":"测试–性能定义Benchmark：基准测试：通过测试 CPU 和内存的效率问题，来评估被测试代码的性能\n命令go test -bench=Benchmark1 -benchmem -run=none -count=3 -benchtime=3s -cpu=1 go test 执行当前目录下的单元测试go test -bench=. 加上 bench 表示也会执行性能测试\n例：go test -bench=Benchmark1 -benchmem -run=none -count=3 -benchtime=3s -cpu=1\n\n-bench：匹配性能测试\n\n\n\n\n\n\n\n\nbench 和 run 后面都是匹配格式，不是具体名称，如-bench&#x3D;Benchmark1，可以匹配 Benchmark1、Benchmark11、Benchmark12 等。-bench=.：表示匹配所有\n\n-benchmem：显示内存分配大小和分配次数\n-run=none：表示匹配名称符合格式 none 的单元测试方法\n\n\n\n\n\n\n\n\n因为一般单元测试方法不会命名为 none，所以便可以排除掉所有的单元测试，从而只运行性能测试\n\n-count：该测试方法重复执行次数\n-benchtime=3s：该测试方法执行时间（时间越长，循环次数越多）\n\n\n\n\n\n\n\n\n-benchtime=100x：表示执行 100 次\n\n-cpu=1：指定 cpu 核数\n\n标准性能测试12345678910111213141516171819func Benchmark1(b *testing.B) &#123;b.ReportAllocs() // 开启内存统计b.ResetTimer() // 重置计时器，防止前面代码干扰// b.N是基准测试框架提供的，Go会根据系统情况生成，不用用户设定，表示循环的次数，因为需要反复调用测试的代码，才可以评估性能for i := 0; i &lt; b.N; i++ &#123;  // 测试时间默认是1秒，也就是说循环会执行1秒，1秒的循环次数便是b.N// do somethingfmt.Sprint(&quot;性能测试&quot;)  // 除了这句是需要测试的代码，其它都是标准格式&#125;b.StopTimer() // 停止计时器，防止后面代码干扰&#125;\n\n并发性能测试123456789101112131415161718192021func Benchmark2(b *testing.B) &#123;b.ResetTimer()runtime.GOMAXPROCS(12)  // 指定并发线程数b.RunParallel(func(pb *testing.PB) &#123;for pb.Next() &#123;// do somethingfmt.Sprint(&quot;并发性能测试&quot;)&#125;&#125;)b.StopTimer()&#125;\n","slug":"GO语言/运用/测试--性能","date":"2024-10-12T02:28:08.785Z","categories_index":"GO语言","tags_index":"技术","author_index":"upstreamboat"},{"id":"ff294b41f6454d72b979d968dd4769d6","title":"测试","content":"测试\nTestMain：固定的测试写法，相当于钩子函数，并不是测试 main()的\n\n1234567891011func TestMain(m *testing.M) &#123;fmt.Println(&quot;before&quot;)            // 测试程序运行前要做的事resultCode := m.Run()            // 运行fmt.Println(&quot;after&quot;, resultCode) // 测试程序结束后要做的事os.Exit(resultCode)              // 退出&#125;\n\n\n测试 main()\n\n123456789101112131415161718192021func Test000(t *testing.T) &#123;wg := sync.WaitGroup&#123;&#125;wg.Add(1)// 启动maingo main() // 因为main启动后会处于持续监听状态，所以需要使用协程time.Sleep(5 * time.Second) // 预留main启动时间// 要做的事global.GVA_LOG.Info(&quot;fuck&quot;) // 启动后便可以正常调用了wg.Wait()     // 不Done()，保持阻塞t.Log(&quot;exit&quot;) // 无法到达的代码&#125;\n\n\n测试函数中可以跑子测试\n\n12345func Test071901(t *testing.T) &#123;t.Run(&quot;fuck&quot;, Test071902)&#125;\n","slug":"GO语言/运用/测试","date":"2024-10-12T02:28:08.766Z","categories_index":"GO语言","tags_index":"技术","author_index":"upstreamboat"},{"id":"dd722656cd65c110c67a2adf5b28eecf","title":"值、引用传递","content":"值、引用传递\n值传递\n\n123456789101112131415func swap(a, b int) &#123;var temp intprintln(&quot;--swap: &quot;)println(&amp;a, &amp;b)  //地址与main()中的地址不一样，是将实际参数的值进行了拷贝temp = aa = bb = temp&#125;\n\n\n引用传递\n\n123456789101112131415161718192021222324252627282930313233func swap2(a, b *int) &#123;var temp intprintln(&quot;--swap2: &quot;)println(&amp;a, &amp;b)println(&amp;*a, &amp;*b)  //地址与main()中的地址一样，直接修改实际参数的值temp = *a*a = *b*b = temp&#125;func main() &#123;a, b := 1, 2println(&amp;a, &amp;b)swap(a, b) // 值传递：函数内的操作不会改变a、b本身的值。传递时其实是将值拷贝了一份传入进去println(a, &amp;a, b, &amp;b) // 交换失败，结果：1 0xc000051f38 2 0xc000051f30swap2(&amp;a, &amp;b)         // 引用传递：函数内的操作可以改变a、b本身的值println(a, &amp;a, b, &amp;b) // 交换成功，结果：2 0xc000051f38 1 0xc000051f30&#125;\n","slug":"GO语言/运用/值、引用传递","date":"2024-10-12T02:28:08.749Z","categories_index":"GO语言","tags_index":"技术","author_index":"upstreamboat"},{"id":"ca25cbdb297165570ca5c6b0f9026538","title":"调用本地包","content":"调用本地包方法一、可以将本地包放入 SDK 的 src 目录下，即可调用方法二、\n\n创建本地包\n\n创建本地文件\n在命令行执行语句：go mod init 名称\n执行完上面语句后会创建一个 go.mod 文件。注意：执行上面语句的时候，当前目录位置是否错误。\n包名、模块名、目录名随意\n\n\n连接本地包\n\n编辑原程序的 go.mod（注意这里不是本地包里的 go.mod），添加依赖 require、repalce，格式如下：\n\n\n\n\n\n\n\n\n\n\n获取依赖名：需要先给 packTest 创建模块文件，即 go.mod\n 123require (   pckTest v1.22.1)\n\n\n\n\n\n\n\n\n\n\n将依赖名指向本地包\n 123replace (\tpckTest =&gt; D:\\Code\\GolandProjects\\helloword\\pckTest)\n\n\n可以连接到模块名，也可以连接到包名，调用时都是通过包名调用\n\n\n\n","slug":"GO语言/运用/调用本地包","date":"2024-10-12T02:28:08.733Z","categories_index":"GO语言","tags_index":"技术","author_index":"upstreamboat"},{"id":"5c8a0474d0d497359d76757037b0b5f8","title":"string","content":"string\nstring 类型底层是一个只读的 byte 数组\nstring 类型会分配 16 个字节的内存内存大小可用 unsafe.sizeof()获得，注意它和 len()是不一样的\ngolang 编码格式为 utf8，utf8 使用 14 个字节表示一个 unicode 字符1 个英文字符占 1 个字节，1 个中文字符占 3 个字节rune（int32）类型用来表示一个 unicode 字符对应的整数值，因为 utf8 一个字符是 14 个字节，rune 正好可以容纳\n遍历字符串要使用 range\nCode\n\n12345678910111213141516171819202122232425func Test071001(t *testing.T) &#123;str := &quot;Golang梦工厂&quot;fmt.Printf(&quot;size=%v\\n&quot;, unsafe.Sizeof(str))   // 分配内存16字节fmt.Printf(&quot;len=%v\\n&quot;, len(str))              // 字节长度15fmt.Printf(&quot;rune len=%v\\n&quot;, len([]rune(str))) // 字符长度9for k, v := range str &#123;fmt.Printf(&quot;%v: %v (%T)\\n&quot;, k, v, v) // 遍历字符&#125;fmt.Println(&quot;----------------------&quot;)for i := 0; i &lt; len(str); i++ &#123;fmt.Printf(&quot;%v: %v (%T)\\n&quot;, i, str[i], str[i]) // 遍历字节&#125;&#125;\n\n输出结果\n12345678910111213141516171819202122232425262728// size=16// len=15// runelen=9// 0:71(int32)// 1:111(int32)// 2:108(int32)// 3:97(int32)// 4:110(int32)// 5:103(int32)// 6:26790(int32)// 9:24037(int32)// 12:21378(int32)// -----------------------------// 0:71(uint8)// 1:111(uint8)// 2:108(uint8)// 3:97(uint8)// 4:110(uint8)// 5:103(uint8)// 6:230(uint8)// 7:162(uint8)// 8:166(uint8)// 9:229(uint8)// 10:183(uint8)// 11:165(uint8)// 12:229(uint8)// 13:142(uint8)// 14:130(uint8)\n","slug":"GO语言/基础/string","date":"2024-10-12T02:26:58.714Z","categories_index":"GO语言","tags_index":"技术","author_index":"upstreamboat"},{"id":"5fe51bea965d1cf766e7673df4ca914f","title":"库--gjson","content":"库–gjson直接获取 json 中字段内容，无需序列化github.com&#x2F;tidwall&#x2F;gjson\n","slug":"GO语言/基础/库--gjson","date":"2024-10-12T02:26:58.690Z","categories_index":"GO语言","tags_index":"技术","author_index":"upstreamboat"},{"id":"41abb34d9ed07e2f1a572226070d62d0","title":"库--zap","content":"库–zap无需细究内容，需要使用 zap 时直接复制即可\n123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187package initializationimport (    &quot;ginchat/global&quot;    &quot;github.com/natefinch/lumberjack&quot;    &quot;go.uber.org/zap&quot;    &quot;go.uber.org/zap/zapcore&quot;    &quot;os&quot;    &quot;path/filepath&quot;    &quot;time&quot;)var (    level   zapcore.Level // zap 日志等级    options []zap.Option  // zap 配置项)func InitializeLog() &#123;\t// 1、设置日志等级    setLogLevel()    // 设置是否输出文件名和行号    if global.App.Config.Log.ShowLine &#123;        options = append(options, zap.AddCaller())    &#125;    // 2、创建编码器    encoder := setEncoder()    // 设置输出位置：这里设置了两个位置，分别是文件和控制台    writeSyncerToFile := getLogWriter()    writeSyncerToStdout := zapcore.AddSync(os.Stdout)    // 3、创建zap核心    core := getZapCore(encoder, writeSyncerToFile, writeSyncerToStdout)    // 创建zap    global.App.ZapLog = zap.New(core, options...).Sugar()&#125;func setLogLevel() &#123;    switch global.App.Config.Log.Level &#123;    case &quot;debug&quot;:        level = zap.DebugLevel        options = append(options, zap.AddStacktrace(level))    case &quot;info&quot;:        level = zap.InfoLevel    case &quot;warn&quot;:        level = zap.WarnLevel    case &quot;error&quot;:        level = zap.ErrorLevel        options = append(options, zap.AddStacktrace(level))    case &quot;dpanic&quot;:        level = zap.DPanicLevel    case &quot;panic&quot;:        level = zap.PanicLevel    case &quot;fatal&quot;:        level = zap.FatalLevel    default:        level = zap.InfoLevel    &#125;&#125;func setEncoder() zapcore.Encoder &#123;    var encoder zapcore.Encoder    // 创建编码器配置    encoderConfig := zap.NewProductionEncoderConfig()    // 设置时间格式    encoderConfig.EncodeTime = func(time time.Time, encoder zapcore.PrimitiveArrayEncoder) &#123;        encoder.AppendString(time.Format(&quot;[&quot; + &quot;2006-01-02 15:04:05.000&quot; + &quot;]&quot;))    &#125;    // 设置“等级”显示样式：大写+颜色    //encoderConfig.EncodeLevel = zapcore.LowercaseColorLevelEncoder    // 写入文件的日志颜色会无法显示    encoderConfig.EncodeLevel = func(l zapcore.Level, encoder zapcore.PrimitiveArrayEncoder) &#123;        encoder.AppendString(&quot;local&quot; + &quot;.&quot; + l.String())    &#125;    // 根据配置创建编码器    if global.App.Config.Log.Format == &quot;json&quot; &#123;        encoder = zapcore.NewJSONEncoder(encoderConfig)    &#125; else &#123;        encoder = zapcore.NewConsoleEncoder(encoderConfig)    &#125;    return encoder&#125;// 使用 lumberjack 作为日志写入器func getLogWriter() zapcore.WriteSyncer &#123;    stSeparator := string(filepath.Separator)    stRootDir, _ := os.Getwd()    stLogFilePath := stRootDir + stSeparator + &quot;log&quot; + stSeparator + time.Now().Format(&quot;2006-01-02&quot;) + &quot;.log&quot;    file := &amp;lumberjack.Logger&#123;        Filename:   stLogFilePath,        MaxSize:    global.App.Config.Log.MaxSize,        MaxBackups: global.App.Config.Log.MaxBackups,        MaxAge:     global.App.Config.Log.MaxAge,        Compress:   global.App.Config.Log.Compress,    &#125;    return zapcore.AddSync(file)&#125;// 扩展 Zapfunc getZapCore(encoder zapcore.Encoder, writeSyncer ...zapcore.WriteSyncer) zapcore.Core &#123;    core := zapcore.NewCore(        encoder,        zapcore.NewMultiWriteSyncer(writeSyncer...),        level,    )    return core&#125;\n","slug":"GO语言/基础/库--zap","date":"2024-10-12T02:26:58.682Z","categories_index":"GO语言","tags_index":"技术","author_index":"upstreamboat"},{"id":"d7434239378216dfafb37dc4b2b89c73","title":"库--casbin","content":"库–casbin\n创建权限配置来源 adapter（db 或者 file）\n 1adapter, err := gormadapter.NewAdapterByDB(global.App.DB)\n创建配置模板 model（file 或者模板字符串）\n 方法一：模板字符串\n 123456789101112131415model,err:=model.NewModelFromString(`[request_definition]r=sub,obj,act[policy_definition]p=sub,obj,act[policy_effect]e=some(where(p.eft==allow))[matchers]m=r.sub==p.sub&amp;&amp;r.obj==p.obj&amp;&amp;r.act==p.act`)e,_=casbin.NewEnforcer(model,adapter)\n\n 方法二：文件  创建examples/rbac_model.conf文件，将上述模板字符串写在文件中\n 1e, _ = casbin.NewEnforcer(&quot;examples/rbac_model.conf&quot;, adapter)\n\n使用\n 123456789101112// Load the policy from DB.e.LoadPolicy()// Check the permission.//e.Enforce(&quot;alice&quot;, &quot;data1&quot;, &quot;read&quot;)// Modify the policy.// e.AddPolicy(...)// e.RemovePolicy(...)// Save the policy back to DB.//e.SavePolicy()\n\n","slug":"GO语言/基础/库--casbin","date":"2024-10-12T02:26:58.632Z","categories_index":"GO语言","tags_index":"技术","author_index":"upstreamboat"},{"id":"2a28425a1a7d4e14f42cf293b79ac333","title":"Gorm","content":"Gorm\nsql 预加载 Preload()函数可以优化查询性能，怎么优化的？Preload()：用于查询数据库中有关联的表。会在查询时，将关联表的数据一并查出来学习\n\nPluck() 方法用于从数据库中查询单列，并扫描结果到切片（slice）\n 1234567// 单列查询var ages []int64db.Model(&amp;User&#123;&#125;).Pluck(&quot;age&quot;, &amp;ages)// 多列查询db.Select(&quot;name&quot;, &quot;age&quot;).Scan(&amp;users)db.Select(&quot;name&quot;, &quot;age&quot;).Find(&amp;users)\n\nFind()和 Scan()的区别？参见Find(dest interface&#123;&#125;, conds ...interface&#123;&#125;)：dest 是参选结果接收者，conds 是查询条件\n\n\n\n\n\n\n\n\n\nconds 查询条件也可以直接作为 Where 的参数，常用的参数有两类：String，Struct 或 Map\n First(dest interface&#123;&#125;, conds ...interface&#123;&#125;)：用法与 Find 一致，只是 First 仅返回根据 id 排序后的第一条结果\n\nModel()的参数一般是表对应结构体对象的指针，Table()的参数是数据库中的表名。\n\n*gorm.DB 和*sql.DB 的区别\n\n\n\n\n\n\n\n\n\n*gorm.DB 用于执行 sql 语句的操作*sql.DB 是数据库连接池实例，用于关闭数据库连接、或设置一些连接配置，它由 DB()生成：*sql.DB := *gorm.DB.DB()\n\n代码\n\n\n123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239package testsimport (&quot;fmt&quot;&quot;github.com/gin-gonic/gin&quot;&quot;github.com/gin-gonic/gin/binding&quot;&quot;gorm.io/driver/mysql&quot;&quot;gorm.io/gorm&quot;&quot;net/http&quot;&quot;strconv&quot;&quot;testing&quot;&quot;time&quot;)func TestGorm(t *testing.T) &#123;username := &quot;root&quot;password := &quot;root&quot;host := &quot;127.0.0.1&quot;port := 3306dbName := &quot;myDB&quot;timeout := &quot;10s&quot;dsn := fmt.Sprintf(&quot;%s:%s@tcp(%s:%d)/%s?&quot;+&quot;charset=utf8&amp;parseTime=True&amp;loc=Local&amp;timeout=%s&quot;,username, password, host, port, dbName, timeout)//连接数据库db, err := gorm.Open(mysql.Open(dsn), &amp;gorm.Config&#123;&#125;)if err != nil &#123;panic(&quot;database connect failed&quot;)&#125;//设置数据库的最大连接数等参数sqlDB, _ := db.DB()sqlDB.SetMaxIdleConns(10)sqlDB.SetMaxOpenConns(100)sqlDB.SetConnMaxLifetime(10 * time.Second)/*表结构体通过POST传入JSON数据时：json字段名不区分大小写（不止是首字母的大小写）；如定义时设置了json别名（如下json:&quot;name&quot;、json:&quot;ttt&quot;），则传入的json字段名必须与别名相同（但不区分大小写），而不是与结构体字段名相同；如定义时未设置json别名，则传入的json字段名与结构体字段名相同。*/type List struct &#123; //表名会自动变为复数，如：listsgorm.ModelUserName   string `gorm:&quot;type:varchar(20);not null&quot; json:&quot;name&quot; binding:&quot;required&quot;`User_state string `gorm:&quot;type:varchar(20);not null&quot; json:&quot;state&quot; binding:&quot;required&quot;`Phone      string `gorm:&quot;type:varchar(20);not null&quot; json:&quot;ttt&quot; binding:&quot;required&quot;`Address    string `gorm:&quot;type:varchar(100);column:addr&quot;`&#125;db.AutoMigrate(&amp;List&#123;&#125;) //根据结构体List自动创建表lists，如果表已存在，则会略过route := gin.Default()route.POST(&quot;add&quot;, func(context *gin.Context) &#123;var list Listerr := context.ShouldBindBodyWith(&amp;list, binding.JSON)if err != nil &#123;panic(&quot;bind json failed&quot;)&#125;context.JSON(http.StatusOK, gin.H&#123;&quot;add data&quot;: &quot;ok&quot;&#125;)//增db.Create(&amp;list) //将POST传入的json写入数据库，新增而不是覆盖&#125;)route.DELETE(&quot;/delete/:id&quot;, func(context *gin.Context) &#123;var data []Listid := context.Param(&quot;id&quot;)//如果id不唯一，Find()的结果可能有多行，所以用[]List接收db.Where(&quot;id= ?&quot;, id).Find(&amp;data)if len(data) == 0 &#123;context.String(http.StatusNotFound, &quot;id not exist&quot;)&#125;//删db.Debug().Delete(&amp;data).Where(&quot;id= ?&quot;, id)context.String(http.StatusOK, &quot;ok&quot;)&#125;)route.PUT(&quot;put/:id&quot;, func(context *gin.Context) &#123;var data Listid := context.Param(&quot;id&quot;)db.Select(&quot;id&quot;).Where(&quot;id=?&quot;, id).Find(&amp;data)if data.ID == 0 &#123;context.String(http.StatusNotFound, &quot;id not exist&quot;)&#125; else &#123;//注意：使用Bind及相似函数时，context必须包含请求体err := context.ShouldBindBodyWith(&amp;data, binding.JSON)//err := context.ShouldBindJSON(&amp;data)if err != nil &#123;context.String(http.StatusNotFound, &quot;analyse json failed&quot;)&#125; else &#123;//改err := db.Debug().Where(&quot;id=?&quot;, id).Updates(&amp;data).Errorfmt.Println(err)context.String(http.StatusOK, &quot;ok&quot;)&#125;&#125;&#125;)route.GET(&quot;/get&quot;, func(context *gin.Context) &#123;var data []Listvar total int64//每页显示数量pageSize, _ := strconv.Atoi(context.Query(&quot;pageSize&quot;))//要查询的是第几页page, _ := strconv.Atoi(context.Query(&quot;page&quot;))offset := (page - 1) * pageSize//查db.Debug().Model(data).Count(&amp;total).Limit(pageSize).Offset(offset).Find(&amp;data) //会执行两个sql：count和selectif len(data) == 0 &#123;context.JSON(http.StatusNotFound, gin.H&#123;&quot;code&quot;:    400,&quot;message&quot;: &quot;nothing&quot;,&#125;)&#125; else &#123;context.JSON(http.StatusOK, gin.H&#123;&quot;code&quot;:     200,&quot;message&quot;:  &quot;success&quot;,&quot;pageSize&quot;: pageSize,&quot;page&quot;:     page,&quot;total&quot;:    total,&quot;offset&quot;:   offset,&quot;data&quot;:     data,&#125;)&#125;&#125;)PORT := &quot;8080&quot;route.Run(&quot;:&quot; + PORT)&#125;\n\n\nPreload()\n\n123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230package testsimport (&quot;fmt&quot;&quot;gorm.io/driver/mysql&quot;&quot;gorm.io/gorm&quot;&quot;testing&quot;)/*Preload：1）必须存在外键，默认的外键是“引用的表名+该表唯一索引字段名”2）Preload(&quot;Company&quot;)中的Company是字段名，而不是表名*/func Test071801(t *testing.T) &#123;db := initDB()_ = db.AutoMigrate(&amp;User&#123;&#125;, &amp;Company&#123;&#125;, &amp;Card&#123;&#125;, &amp;Language&#123;&#125;)_ = initCompany(db)_ = initUser(db)_ = initCard(db)_ = initLanguage(db)var u Userdb.Debug().Preload(&quot;Company&quot;).Preload(&quot;Card&quot;).Preload(&quot;Cards&quot;).Preload(&quot;Languages&quot;).Find(&amp;u)t.Log(&quot;-----------------------------&quot;)t.Log(u)/*# 输出：SELECT * FROM `cards` WHERE `cards`.`number` = 1SELECT * FROM `cards` WHERE `cards`.`number` = 1SELECT * FROM `companies` WHERE `companies`.`code` = 1SELECT * FROM `user_languages` WHERE `user_languages`.`user_id` = 1SELECT * FROM `languages` WHERE `languages`.`id` IN (1,2)SELECT * FROM `users`&#123;1 User1 1 &#123;1 1 Company1&#125; &#123;2 Card111 1&#125; [&#123;1 Card1 1&#125; &#123;2 Card111 1&#125;] [&#123;1 Language1 []&#125; &#123;2 Language2 []&#125;]&#125;*/var l Languagedb.Debug().Preload(&quot;Users&quot;).Find(&amp;l)t.Log(&quot;-----------------------------&quot;)t.Log(l)/*# 输出SELECT * FROM `user_languages` WHERE `user_languages`.`language_id` = 1SELECT * FROM `users` WHERE `users`.`id` IN (1,2)SELECT * FROM `languages`&#123;1 Language1 [&#123;1 User1 1 &#123;0 0 &#125; &#123;0  0&#125; [] []&#125; &#123;2 User2 2 &#123;0 0 &#125; &#123;0  0&#125; [] []&#125;]&#125;*/&#125;type Company struct &#123;ID   intCode int `gorm:&quot;unique&quot;` // 因为不是主键，所以要加unique，外键的引用来源必须是唯一索引Name string&#125;type User struct &#123;ID       intName     stringUniqueId int `gorm:&quot;unique&quot;`// 注意下面Company、Card的标签的写法// user表新建一个外键(UniqueId-&gt;Company.Code)Company Company `gorm:&quot;foreignKey:UniqueId;references:Code&quot;`// 一对一的关系，card表新建一个外键fk_users_card(Number-&gt;User.UniqueId)Card Card `gorm:&quot;foreignKey:Number;references:UniqueId&quot;`// 一对多的关系，card表新建一个外键fk_users_cards(Number-&gt;User.ID)，因为Cards没有指定引用来源，所以会默认是user表的ID；Cards     []Card     `gorm:&quot;foreignKey:Number;&quot;`// 多对多的关系，会新建一个关系表user_languages，有两个外键：User.ID、Language.IDLanguages []Language `gorm:&quot;many2many:user_languages;&quot;`&#125;type Card struct &#123;ID     intName   stringNumber int&#125;type Language struct &#123;ID    intName  stringUsers []User `gorm:&quot;many2many:user_languages&quot;` // 多对多的关系，这里也可以写标签&#125;func initCompany(db *gorm.DB) error &#123;err := db.Create(&amp;[]Company&#123;&#123;Code: 1, Name: &quot;Company1&quot;&#125;,&#123;Code: 2, Name: &quot;Company2&quot;&#125;,&#123;Code: 3, Name: &quot;Company3&quot;&#125;,&#123;Code: 4, Name: &quot;Company4&quot;&#125;,&#125;).Errorreturn err&#125;func initUser(db *gorm.DB) error &#123;err := db.Create(&amp;[]User&#123;&#123;Name: &quot;User1&quot;, UniqueId: 1&#125;,&#123;Name: &quot;User2&quot;, UniqueId: 2&#125;,&#123;Name: &quot;User3&quot;, UniqueId: 3&#125;,&#123;Name: &quot;User4&quot;, UniqueId: 4&#125;,&#125;).Errorreturn err&#125;func initCard(db *gorm.DB) error &#123;err := db.Create(&amp;[]Card&#123;&#123;Name: &quot;Card1&quot;, Number: 1&#125;,&#123;Name: &quot;Card111&quot;, Number: 1&#125;,&#123;Name: &quot;Card2&quot;, Number: 2&#125;,&#123;Name: &quot;Card3&quot;, Number: 3&#125;,&#123;Name: &quot;Card4&quot;, Number: 4&#125;,&#125;).Errorreturn err&#125;func initLanguage(db *gorm.DB) error &#123;err := db.Create(&amp;[]Language&#123;&#123;Name: &quot;Language1&quot;&#125;,&#123;Name: &quot;Language2&quot;&#125;,&#123;Name: &quot;Language3&quot;&#125;,&#123;Name: &quot;Language4&quot;&#125;,&#125;).Errorreturn err&#125;func initDB() *gorm.DB &#123;username := &quot;root&quot;password := &quot;root&quot;host := &quot;127.0.0.1&quot;port := 3306dbName := &quot;myDB&quot;timeout := &quot;10s&quot;dsn := fmt.Sprintf(&quot;%s:%s@tcp(%s:%d)/%s?&quot;+&quot;charset=utf8&amp;parseTime=True&amp;loc=Local&amp;timeout=%s&quot;,username, password, host, port, dbName, timeout)//连接数据库db, err := gorm.Open(mysql.Open(dsn), &amp;gorm.Config&#123;&#125;)if err != nil &#123;panic(&quot;database connect failed&quot;)&#125;return db&#125;\n","slug":"GO语言/基础/Gorm","date":"2024-10-12T02:26:58.608Z","categories_index":"GO语言","tags_index":"技术","author_index":"upstreamboat"},{"id":"1844acb7289f08bbbe7bcf325b1cd691","title":"Gin","content":"Gin\n学习：https://www.liwenzhou.com/posts/Go/gin/#c-0-6-0\n\n获取参数：context.Get()：从 Keys 中取数据context.Param(“name”)：从路径中取数据context.Query(“name”)：从查询参数中取数据context.ShouldBindJSON(&amp;user)：从请求体中取数据\n\nnext()和 abort()的区别：next()：暂停执行当前中间件的后续代码，立即调用 下一个中间件 或 主程序 ，并在响应后继续回到此处执行后续代码。abort()：终止其它中间件程序。但不会停止当前的函数。\n\n\n\n\n\n\n\n\n\n例如，有一个验证当前的请求是否是认证过的  Authorization  中间件。如果验证失败(例如，密码不匹配)，调用  Abort  以确保这个请求的其他函数不会被调用。Abort()和 AbortWithStatusJSON()都是中止链的调用，不同之处在于，前者不会返回给前端任何内容，而后者则可以返回给前端一个 JSON 串。\n\nPUT&#x2F;DELETE&#x2F;UPDATE&#x2F;GET&#x2F;OPTIONSOPTIONS：用于获取目的资源所支持的通信选项（简单说就是支持哪种请求方法）\n\n\n\n\n\n\n\n\n\n跨域的情况下，浏览器会首先使用 OPTIONS 方法发起一个预检请求，来获知服务端是否允许该跨域请求\n\n\n123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191package testsimport (&quot;fmt&quot;&quot;github.com/gin-gonic/gin&quot;&quot;log&quot;&quot;net/http&quot;&quot;testing&quot;)func TestGin(t *testing.T) &#123;//设置路由//New()和Default()的区别：Default()会在New()的基础上，集成Logger和Recover，用来打印日志和异常后操作//router := gin.New()router := gin.Default()//路由组：同类请求设为一组，共用组路径//无参数路由//localhost:8080/*router.GET(&quot;/&quot;, func(context *gin.Context) &#123;//context.String(http.StatusOK, &quot;hello world&quot;)context.JSON(http.StatusOK, gin.H&#123;&quot;message&quot;: &quot;hello world&quot;&#125;)&#125;)*///带有路径参数的路由，可以用Param获取参数//localhost:8080/new/小王/22router.GET(&quot;/new/:name/:id&quot;, func(context *gin.Context) &#123;name := context.Param(&quot;name&quot;)id := context.Param(&quot;id&quot;)context.String(http.StatusOK, &quot;hello new world,%s=%v&quot;, name, id)&#125;)//带有查询参数的路由，可以用Query获取参数//localhost:8080/hello?name=小王/*route.GET(&quot;/hello&quot;, func(context *gin.Context) &#123;name := context.Query(&quot;name&quot;)context.JSON(http.StatusOK, gin.H&#123;&quot;message&quot;: &quot;hello &quot; + name&#125;)&#125;)*///设置cookie/*router.GET(&quot;/set-cookie&quot;, func(context *gin.Context) &#123;context.SetCookie(&quot;user&quot;, &quot;jane&quot;, 3600, &quot;/&quot;, &quot;localhost&quot;, false, true)context.String(http.StatusOK, &quot;set cookie&quot;)&#125;)router.GET(&quot;get-cookie&quot;, func(context *gin.Context) &#123;user, err := context.Cookie(&quot;user&quot;)if err == nil &#123;context.String(http.StatusOK, &quot;%s get cookie&quot;, user)&#125; else &#123;context.String(http.StatusNotFound, &quot;cookie not exist&quot;)&#125;&#125;)*///表单处理//发送post请求到localhost:8080/submit-form,在body中添加两个表单元素/*router.POST(&quot;/submit-form&quot;, func(context *gin.Context) &#123;name := context.PostForm(&quot;name&quot;)email := context.PostForm(&quot;email&quot;)context.String(http.StatusOK, &quot;name=%s,email=%s&quot;, name, email)&#125;)*///中间件 + Json处理//中间件（Middleware）是一种在应用程序执行之前或之后再执行的功能组件/*router.Use(middleware1) //使用自定义的中间件LoggerMiddleware打印日志router.Use(middleware2) //注意看执行顺序router.POST(&quot;submit-json&quot;, func(context *gin.Context) &#123;var user Usererr := context.ShouldBindJSON(&amp;user)//err := context.BindJSON(&amp;user)  //与ShouldBindJSON相比，BindJSON会在header中返回一个状态码400if err == nil &#123;context.JSON(http.StatusOK, gin.H&#123;&quot;message&quot;: &quot;analyse json success&quot;, &quot;data&quot;: user&#125;)t.Log(user)&#125; else &#123;context.String(http.StatusNotFound, &quot;analyse json failed&quot;)&#125;&#125;)*///重定向/*router.GET(&quot;/redirect&quot;, func(context *gin.Context) &#123;context.Redirect(http.StatusMovedPermanently, &quot; [https://www.example.com](https://www.example.com)&quot;)&#125;)*///模板渲染//设置模板文件目录router.LoadHTMLGlob(&quot;templates/*&quot;)//在模板文件目录下创建index.tpl文件router.GET(&quot;/template&quot;, func(context *gin.Context) &#123;context.HTML(http.StatusOK, &quot;index.tpl&quot;, gin.H&#123;&quot;name&quot;: &quot;jane&quot;&#125;)&#125;)router.Run(&quot;:8080&quot;) // 监听并在8080端口上启动服务&#125;type User struct &#123;//因为作用域，这里Name和Email的首字母必须大写Name  string `json:&quot;name&quot;`Email string `json:&quot;email&quot;`&#125;func middleware1(c *gin.Context) &#123;log.Print(&quot;1--start&quot;) // 处理请求前的日志记录逻辑c.Next()              //调用下一个中间件或请求处理程序log.Print(&quot;1--end&quot;)   // 处理响应后的日志记录逻辑&#125;func middleware2(c *gin.Context) &#123;fmt.Println(&quot;2--start&quot;)c.Next()fmt.Println(&quot;2--end&quot;)&#125;\n","slug":"GO语言/基础/Gin","date":"2024-10-12T02:26:58.459Z","categories_index":"GO语言","tags_index":"技术","author_index":"upstreamboat"},{"id":"c007e764a72957fafa5b15a6941bd0e2","title":"make、type、range","content":"make、type、range\nmake 仅用于这三种引用类型的初始化：切片 Slice、集合 Map、通道 channel\n1234567s := make([]int, 0, 10)  //分配一个长度为 10 的底层数组，返回一个长度为 0，容量为 10 的切片s2 := []int&#123;1,2,3&#125;  //不使用make()，直接初始化，和数组一样m := make(map[string]int)  //给 map 分配内存空间m2 := map[int]int&#123;1:2, 2:3&#125;  //也可以不使用make()，直接初始化c := make(chan int, 10)  //给 channel 分配的内存空间大小（缓冲容量）为 10\n\nmake 与 new 的区别：\n\n\n\n\n\n\n\n\n\n1）两者都是分配内存，make 只能分配上面三个类型，但是 new 还可以为其它类型分配内存2）make 返回的类型本身，但是 new 返回的是类型的指针\n\ntype 关键字的用途1）定义结构体：type 结构体名 struct&#123;&#125;2）定义接口：type 接口名 interface&#123;&#125;3）类型别名：type str stringvar str1 str = &quot;haha&quot;\n\nrange 可以遍历字符串、数组、切片、集合、通道等\n12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758//字符串str := &quot;abA&quot;for k, v := range str &#123;fmt.Printf(&quot;string[%v] = [%v]\\n&quot;, k, v)&#125;//数组arr := [3]int&#123;1, 2, 3&#125;for k, v := range arr &#123;fmt.Printf(&quot;array[%v] = [%v]\\n&quot;, k, v)&#125;//切片sli1 := []int&#123;1, 2&#125;//var sli = make([]int,2,3)  //也可以使用make()进行声明for k, v := range sli1 &#123;fmt.Printf(&quot;slice[%v] = [%v]\\n&quot;, k, v)&#125;//集合m := map[string]int&#123;&quot;a&quot;: 97, &quot;b&quot;: 98, &quot;A&quot;: 65&#125;for k, v := range m &#123;fmt.Printf(&quot;map[%v] = [%v]\\n&quot;, k, v)&#125;//通道c := make(chan int, 3)c &lt;- 1c &lt;- 2c &lt;- 3close(c) //一定要关闭通道,否则在range中,即便通道中没了数据也会继续等待数据写入,从而造成阻塞for v := range c &#123;  //通道遍历不返回key，只返回value值fmt.Printf(&quot;channel = [%v]\\n&quot;, v)&#125;\n\nrange 和 forrange 对每个迭代值都创建了一个拷贝，而 for 没有&#x2F;&#x2F; 如果每个迭代值内存占用很大，则 for 性能优于 range。&#x2F;&#x2F; 如果每次迭代的值内存占用很小，则两者性能几乎无差异；&#x2F;&#x2F; 如果 range 迭代时忽略值，只返回索引，则两者性能几乎无差异；&#x2F;&#x2F; 如果 range 迭代时，每个迭代值是指针，则两者性能几乎无差异。\n&#x2F;&#x2F; map、chan 只能用 range 遍历\n\n\n","slug":"GO语言/基础/make、type、range","date":"2024-10-12T02:26:58.406Z","categories_index":"GO语言","tags_index":"技术","author_index":"upstreamboat"},{"id":"0d4253f077b5777a177cf6299ae256a6","title":"go module","content":"go module\ngo 包管理进化史：\n\n\n\n\n\n\n\n\n\ngo path -&gt;go vendor -&gt;go module\n\ngo module:\n 启用：\n\n\n\n\n\n\n\n\n\n使用 go path 模式要求工程目录在 GOPATH&#x2F;src 之下使用 go module 模式，项目可以在任意位置，但需要先开启配置：\n\n\n\n\n\n\n\n\n\n\n设置 env 为 GO111MODULE&#x3D;on项目中有 go.mod 文件\n\n 命令：\n\n\n\n\n\n\n\n\n\ngo mod init：生成 go.modgo mod tidy：包整理（多的删去、少的拉取）\n 包存储目录：\n\n\n\n\n\n\n\n\n\n开启 go module 的配置后，执行 go get xxx 下载的包将放入 GOPATH&#x2F;pkg&#x2F;mod 目录，go install xxx 下载的二进制可执行文件将放在 GOPATH&#x2F;bin 目录下\n\n\n","slug":"GO语言/基础/go module","date":"2024-10-12T02:26:58.374Z","categories_index":"GO语言","tags_index":"技术","author_index":"upstreamboat"},{"id":"c206b317444e22659f858ddc5d93929f","title":"go env-02","content":"go env-02go.sum：\n\n","slug":"GO语言/基础/go env-02","date":"2024-10-12T02:26:58.334Z","categories_index":"GO语言","tags_index":"技术","author_index":"upstreamboat"},{"id":"1c0d1fd322f023ce717ccb50775e5247","title":"go env-01","content":"go env-01\n参考\n\ngo 模块文档查阅网址：go.dev：Go 开发人员中心\n\n\n\n\n\n\n\n\n\npkg.go.dev：Go 软件包和模块的新信息资源中心godoc.org：旧资源中心，现在重定向到了 pkg.go.dev\n\ngo env 环境变量详解：\n\n\n\n\n\n\n\n\n\n\n\n\nGO111MODULE\n设置 go 模块支持\ngo 模块可以更好地管理依赖\ngo.mod：描述了当前项目的所有依赖go.sum：详细罗列了当前项目直接或间接依赖的所有模块版本，并写明了那些模块版本的 SHA-256 哈希值，以备 Go 在今后的操作中保证项目所依赖的那些模块版本不会被篡改\n\n\nGOPROXY\n设置模块代理\n在下载依赖包的时候，一般是访问 github 的仓库，国内的环境很容易被墙，所以需要代理。默认：https://proxy.golang.org,direct，推荐：goproxy.cn\nproxy.golang.org：官方模块代理，但是国内无法访问goproxy.cn：七牛云的模块代理，可以快速下载依赖\n\n\nGOSUMDB\n\n用来校验拉取的第三方库是否是完整的\nsum.golang.org：源网站\n\n\nGONOPROXYGONOSUMDBGOPRIVATE\n\n如果当前项目依赖了私有模块，即不是 GOPROXY 可以下载到的模块，需要对此进行设置，而且只设置 GOPRIVATE 即可\n\n\n\nGOMODCACHEGOPATH\n依赖包位置工作区\n都是下载的外部依赖包存位置。只设置 GOPATH 即可\n\n\n\nGOCACHE\n\n此目录存放 go 项目在构建过程中产生的缓存\n\n\n\nGOENV\n\n自定义的 go 环境变量的配置文件\n\n\n\nGOROOT\n\ngo 语言的安装目录\n\n\n\nCGO_ENABLEDGOOSGOARCH\n是否启用 CGO目标操作系统目标系统架构\n这三个在交叉编译时需要设置。如：CGO_ENABLED&#x3D;0GOOS&#x3D;linuxGOARCH&#x3D;amd64\n\n\n\nCGO_CFLAGSCGO_LDFLAGS\n指定头文件位置指定链接库\n这两个都是 C 编译用的\n\n\n\nGOBIN\n存放可执行文件的目录的绝对路径。\n\n\n\n\nGOCHAR\n程序构建环境的目标计算架构的单字符标识。\n\n\n\n\nGOEXE\n可执行文件的后缀。\n\n\n\n\nGOHOSTARCH\n程序所在环境的计算架构\n\n\n\n\nGOHOSTOS\n程序所在环境的操作系统\n\n\n\n\nGORACE\n用于数据竞争检测的相关选项。\n\n\n\n\nGOTOOLDIR\nGo 工具目录的绝对路径。\n\n\n\n\n","slug":"GO语言/基础/go env-01","date":"2024-10-12T02:26:58.303Z","categories_index":"GO语言","tags_index":"技术","author_index":"upstreamboat"},{"id":"89b3df93828c893bd967552f490f0e64","title":"import_init","content":"import&#x2F;initimportimport 时会依次加载目标包的 const、var、init()（这是重点，导入会自动运行 init()，执行时刻为 import 这行代码执行的时刻）\n\n匿名导入：import _ &quot;fmt&quot; &#x2F;&#x2F; 程序会执行 fmt 包下的 init()函数，但无法主动使用该包，例如：fmt.print()会报错\n别名导入：import aa &quot;fmt&quot; &#x2F;&#x2F; 别名，例如：aa.print()\n全导入：import . &quot;fmt&quot; &#x2F;&#x2F; 导入全部方法，可以直接使用，例如：print()\n\ninit()不能被主动调用；同包、同文件中都可以有多个 init()；执行顺序：import语句 &gt; 全局变量 &gt; init() &gt; main()\n\n当执行代码有依赖关系时，即有 import 语句时，执行顺序先内后外：\n\n\n\n\n\n\n\n\n\n最内部全局变量 &gt; 最内部 init &gt; 外部全局变量 &gt; 外部 init &gt; 外部的 main\n123456789101112131415// C.gopackage CCimport &quot;fmt&quot;func init() &#123;    fmt.Println(&quot;C.init&quot;)&#125;var c = setC()func setC() int &#123;    fmt.Println(&quot;C的全局变量&quot;)    return 3&#125;\n\n12345678910111213141516// B.gopackage BBimport &quot;fmt&quot;import _ &quot;awesomeProject/CC&quot;func init() &#123;    fmt.Println(&quot;B.init&quot;)&#125;var b = SetB()func SetB() int &#123;    fmt.Println(&quot;B的全局变量&quot;)    return 2&#125;\n\n1234567891011121314151617181920// D.gopackage mainimport &quot;fmt&quot;import _ &quot;awesomeProject/BB&quot;func init() &#123;    fmt.Println(&quot;D.init&quot;)&#125;var aa = setD()func setD() int &#123;    fmt.Println(&quot;D的全局变量&quot;)    return 1&#125;func main() &#123;    fmt.Println(&quot;D中的main函数&quot;)&#125;\n\n输出结果\n1234567// C的全局变量// C.init// B的全局变量// B.init// D的全局变量// D.init// D中的main函数\n\n当执行代码无依赖关系时，执行顺序为：\n\n\n\n\n\n\n\n\n\nB 的全局变量 &gt; C 的全局变量 &gt; D 的全局变量 &gt; B 的 init &gt; C 的 init &gt; D 的 init &gt; main&#x2F;&#x2F; B、C、D 是按文件名排序\n1234567891011121314151617181920212223242526// D.go（B.go、C.go的代码略）package mainimport &quot;fmt&quot;func init() &#123;fmt.Println(&quot;D.init&quot;)&#125;var aa = setD()func setD() int &#123;fmt.Println(&quot;D的全局变量&quot;)return 1&#125;func main() &#123;fmt.Println(&quot;D中的main函数&quot;)&#125;\n\n输出结果\n1234567// B的全局变量// C的全局变量// D的全局变量// B.init// C.init// D.init// D中的main函数\n\n","slug":"GO语言/基础/import_init","date":"2024-10-12T02:26:58.263Z","categories_index":"GO语言","tags_index":"技术","author_index":"upstreamboat"},{"id":"3f2ed32fdfa2e792bea16be6c66658d9","title":"依赖注入","content":"依赖注入\n参考\n\n依赖注入：一段代码依赖于另一段代码，将后者以参数形式注入到前者，这就是依赖注入控制反转：控制反转是一种程序设计思想，依赖注入是实现这种思想的一种主流方式。\n 12345678910db := NewDB()store := NewStore(db)// 创建store需要依赖NewDB()，将db注入NewStore()中，这就是依赖注入。// 在go中依赖注入通常用来存储实例，比如：type struct Store &#123;\tDB&#125;// 要调用DB的实例，需要通过Store的实例\n\nwire 库：个人感觉不好，不建议使用\n\n\n","slug":"GO语言/基础/依赖注入","date":"2024-10-12T02:26:58.220Z","categories_index":"GO语言","tags_index":"技术","author_index":"upstreamboat"},{"id":"4ac06be8c7a43e5fa8c5ae374f435567","title":"泛型","content":"泛型作用泛型主要用来降低代码重复率\n类型约束定义\n法一：通过接口定义\n123type Interger interface &#123;    ~int | int8 | int16 | int32 | ~int64&#125;\n\n\n\n\n\n\n\n\n\n\n~ 符号用来表示类型集的扩展类型，如 time.Duration 是一个 int64 的类型重定义\n1type  Duration int64\n\n法二：使用时定义\n123func myFun[Interger  ~int | int8 | int16 | int32 | ~int64](a Interger) Interger  &#123;    return a&#125;\n\n泛型使用1234567891011121314151617181920212223242526// 1、函数中使用func F[T Interger](v T) T &#123;    return v&#125;// 2、结构体中使用type S[T Interger] struct &#123;    v T&#125;// 3、接口中使用：注意，使用了泛型的接口，就只能作为类型约束用在泛型参数中type I[T any] interface &#123;    *T&#125;func myFun02[IT I[int]](i IT) IT &#123;    return i&#125;func Test01(t *testing.T) &#123;    f := F[int](3)  // 可以自动推断类型，等价于 &lt;=&gt; f := F(3)    s := S[int]&#123;3&#125;\ta := 3    i := myFun02[*int](&amp;a)  // 等价于 &lt;=&gt; i := myFun02(&amp;a)    t.Log(f, s, *i)&#125;\n\n注意：以下均会报错\n123456789// 方法中不能使用泛型func (s S) Len[T Interger](a T) T &#123;    return a&#125;// 泛型函数中不能定义结构体func F[T Interger](v T)&#123;    type name struct &#123;&#125;&#125;\n\n泛型库\n官方库  https://golang.org/x/exp/constraints 定义基础约束类型，如有符号，无符号，浮点，可对比类型等  https://golang.org/x/exp/maps 实现 map 的各种基础操作，如遍历，拷贝，清空等  https://golang.org/x/exp/slices 实现 slice 的各种基础操作，如是否存在，拷贝，是否相等\n  1234567891011121314151617// 使用举例func Test02(t *testing.T) &#123;    s := []int&#123;1, 2, 3, 4&#125;    // 判断s中是否包含值为2的元素    slices.Contains(s, 2)    // 判断s中是否包含对2取余为0的元素    slices.ContainsFunc(s, func(i int) bool &#123;        return i%2 == 0    &#125;)    // 删除s[0:1]的元素    s = slices.Delete(s, 0, 1)    // 当匿名函数返回true时，删除该元素。i为切片s中各个元素    s = slices.DeleteFunc(s, func(i int) bool &#123;        return i%2 == 0    &#125;)&#125;\n\n三方库  https://golang.design/x/reflect 对象深拷贝  https://github.com/samber/lo slice，map，channel 的各种操作\n\n\n补充一个泛型的知识点\n1234567891011121314151617181920type MyReader interface &#123;&#125;type MySubReader interface &#123;\tMyReader&#125;func F[T any](a T, b T) &#123;&#125;func Test01(t *testing.T) &#123;\tvar r MyReader\tvar rc MySubReader\t// 前置知识：泛型需要相同类型\t// 错误原因：这样写编译器会认为rc的类型就是MySubReader，不是MyReader\tF(r, rc) // error: type MySubReader of rc does not match inferred type MyReader for T\t// 正确写法：这样写编译器会认为rc的类型就是MyReader\tF[MyReader](r, rc) // ok&#125;\n","slug":"GO语言/基础/泛型","date":"2024-10-12T02:26:58.205Z","categories_index":"GO语言","tags_index":"技术","author_index":"upstreamboat"},{"id":"5ce8a35fbf88482d4de619a9c1063a08","title":"协程--CPU、内存","content":"协程–CPU、内存\n虚拟内存\n\n\n\n\n\n\n\n\n用户程序（进程）只能使用虚拟的内存地址来获取数据，系统会将这个虚拟地址翻译成实际的物理地址。操作系统内部会对虚拟内存地址和真实的物理内存地址做映射关系。这里面每一个程序统一使用一套连续虚拟地址，从程序的角度来看，它觉得自己独享了一整块内存，且不用考虑访问冲突的问题。虚拟内存还实现了“读时共享，写时复制”的机制，可以在物理层同一个字节的内存地址被多个虚拟内存空间映射。如果物理内存短暂的供不应求，那么虚拟内存也会从磁盘（硬盘）上虚拟出一定量的空间，挂在虚拟地址上，而且这个动作进程本身是不知道的。\n\nCPU 把虚拟地址给 MMU，MMU 去物理内存中查询页表，得到实际的物理地址。\n进程是资源分配的最小单位（CPU 时间片、内存等资源）\n线程是 CPU 调度执行的最小单位\n线程拥有各自独立的栈空间，其他的内存空间（堆、数据段、代码段、BSS 区）是一起共享的\n占用内存（大概数值）：进程：4G，线程：4M，协程：4K\nCPU 会根据线程数，均衡分配时间片\n线程越多，切换时间成本越大：\n\n\n\n\n\n\n\n\nCPU 在切换执行线程时，也需要耗费时间（性能开销）。主要切换的是内核栈和硬件上下文。因为线程间的栈是独立的，切换时 CPU 的寄存器需要将上一个线程的栈保存；并且 CPU 的 MML 中 Cache 的虚拟-物理内存地址映射，随着线程切换需要更新，新的地址映射需要重新查询页表，查询耗时导致程序变慢。\n\n线程切换需要同时切换用户空间和内核空间（涉及到特权模式，不懂），协程只需要切换用户空间。\n\n","slug":"GO语言/基础/协程--CPU、内存","date":"2024-10-12T02:26:58.161Z","categories_index":"GO语言","tags_index":"技术","author_index":"upstreamboat"},{"id":"cc5db5cd6eeb1aa9cc58dc1a444cc045","title":"协程--图解","content":"协程–图解\n参考\n\n总体图示：\n\nGMP 成员：G：协程（用户线程），乘客M：内核线程，检票口P：协程处理器，检票员全局队列：候车厅本地队列：检票排队\n\nGMP 调度器的 4 个设计策略：\n\n复用线程\n\nwork stealing 机制\n\n\n\n\n\n\n\n\n\n当本线程无可运行的 G 时，尝试从其他线程绑定的 P 偷取 G，而不是销毁线程当 P 的队列中没有 G 时，则会从其它 P 偷取一个 G 来执行。（检票员会喊正在排队的乘客到没人的队列）\n\nhand off 机制\n\n\n\n\n\n\n\n\n\n当本线程因为 G 进行系统调用阻塞时，线程释放绑定的 P，把 P 转移给其他空闲的线程执行当某个 G 阻塞，则当前 P 会转移到一个新的 M 上，继续执行其它 G。（有人闹事，则关闭当前检票口，检票员和排队乘客转移到一个新开的检票口)\n\n\n\n利用并行：GOMAXPROCS 设置 P 的数量，最多有 GOMAXPROCS 个线程分布在多个 CPU 上同时运行\n\n抢占：一个 goroutine 最多占用 CPU 10ms，防止其他 goroutine 被饿死\n\n全局 G 队列：当 P 的本地队列为空时，优先从全局队列获取，如果全局队列为空时则通过 work stealing 机制从其他 P 的本地队列偷取 G\n\n\n\nGMP 的几种场景：&#x2F;&#x2F; M0：程序运行时的第一个线程&#x2F;&#x2F; G0：每个线程 M 中都存有一个 G0（注意 G0 不是存放在队列中），G0 是用来做调度的。例如：从 G1 切换到 G2 时，会先切回到 G0，保存 G1 的栈等调度信息，然后再切换到 G2。&#x2F;&#x2F; 执行线程：有 G、P、M&#x2F;&#x2F; 自旋线程：有 P、M&#x2F;&#x2F; 休眠线程：有 M\n1234567891. 新建 G 时，会放入 P 队列中。若 P 队列满，则放入全局队列中。2. G1 中创建的 G1&#x27;，若无空闲 P，则会优先存放在 P1 队列中；若有，则分配到空闲 P 执行。3. 当 G1 执行完毕，P1 会启用 G0，然后通过 G0 调用本地队列的 G1&#x27;。4. 当本地队列满时，再创建 G，会将 当前 P 队列的靠前一半的 G 与新建的 G 一同存放到全局队列中。5. 新建 G 时，当前运行的 G 会尝试唤醒空闲的 P 和 M，如果被唤醒的 P 队列中没有 G，则被唤醒的 M 会不断寻找 G（此时的 M 称为自旋线程）。    // 自旋线程数量 + 执行线程数量 &lt;= P 数量    // 寻找策略：自旋线程会先去全局队列中获取一批 G（具体获取多少个 G 有个公式）。若全局队列为空，则会从其它 P 队列偷取靠后一半的 G。6. 如果 G 阻塞，则当前 P 会去唤醒一个休眠线程 M 重新绑定，继续执行当前 P 队列中的其它 G。7. 当 G 阻塞结束时，当前 M 会优先去找阻塞前的 P。如果 P 已被占用，则去唤醒空闲 P。如果没有空闲 P，则 G 会被释放到全局队列中等待调用。\n\n","slug":"GO语言/基础/协程--图解","date":"2024-10-12T02:26:58.137Z","categories_index":"GO语言","tags_index":"技术","author_index":"upstreamboat"},{"id":"de4bfe30255df688e3d880102f081573","title":"协程--chan阻塞测试","content":"协程–chan 阻塞测试12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788899091func Test(t *testing.T) &#123;// 1、无缓冲通道：执行读取或写入时会阻塞，必须先开启另一个对应写入或读取通道的线程。另一个线程执行通道语句时也会阻塞，但是不影响主线程的执行。var a int//c := make(chan int)/*go func() &#123;c &lt;- 1&#125;()a = &lt;-c*/ //ok/*go func() &#123;a = &lt;-c&#125;()c &lt;- 1*/ //ok/*a = &lt;-cgo func() &#123;c &lt;- 1&#125;()*/ //false：deadlock/*c &lt;- 1go func() &#123;a = &lt;-c&#125;()*/ //false：deadlock// 2、有缓冲通道：通道有缓冲，直接写入时可以缓冲不阻塞，但如果是先直接读取，还是会阻塞，因为通道中为空，读取不到数据，无法向下继续执行。c := make(chan int, 1)/*c &lt;- 1a = &lt;-c*/ //ok/*a = &lt;-cc &lt;- 1*/ //deadlock/*c &lt;- 1go func() &#123;a = &lt;-c&#125;()*/ //ok/*a = &lt;-cgo func() &#123;c &lt;- 1&#125;()*/ //false：deadlock/*go func() &#123;a = &lt;-c&#125;()c &lt;- 1*/ //ok/*go func() &#123;c &lt;- 1&#125;()a = &lt;-c*/ //okfmt.Print(&quot;here?&quot;)//time.Sleep(2 * time.Second)fmt.Print(a)&#125;\n","slug":"GO语言/基础/协程--chan阻塞测试","date":"2024-10-12T02:26:58.109Z","categories_index":"GO语言","tags_index":"技术","author_index":"upstreamboat"},{"id":"b8351e6b529030bde208c360539354f9","title":"协程--chan引发panic","content":"协程–chan 引发 panic\n关闭一个未初始化的 channel 会引发 panic\n\n关闭一个已关闭的 channel 会引发 panic\n\n向一个已关闭的 channel 发送数据会引发 panic\n 1234567891011var ch chan struct&#123;&#125;close(ch) // 关闭一个未初始化的channel会引发panicch := make(chan struct&#123;&#125;)close(ch)close(ch) // 关闭一个已关闭的channel会引发panicch := make(chan struct&#123;&#125;)close(ch)ch &lt;- struct&#123;&#125;&#123;&#125; // 向一个已关闭的channel发送数据会引发panic\n\n遍历 chan 时，如果不关闭通道，会阻塞线程，引发 panic\n 123456789101112131415func Test071001(t *testing.T) &#123;    ch := make(chan int, 3)    go func() &#123;\t    for i := 0; i &lt; 3; i++ &#123;\t\t    ch &lt;- i\t    &#125;\t    close(ch) // 如果不关闭通道，外层的range遍历完数据后会阻塞，引发panic    &#125;()    for c := range ch &#123;\t    fmt.Println(c)    &#125;&#125;\n\n 如果反过来，将遍历放入协程中，即使不关闭通道也没事。因为协程阻塞不影响主程序的运行\n 12345678910111213func Test071001(t *testing.T) &#123;\tch := make(chan int, 3)\tgo func() &#123;\t\tfor c := range ch &#123;    \t\tfmt.Println(c)\t\t&#125;\t&#125;()\tfor i := 0; i &lt; 3; i++ &#123;\t\tch &lt;- i\t&#125;&#125;\n\n","slug":"GO语言/基础/协程--chan引发panic","date":"2024-10-12T02:26:58.082Z","categories_index":"GO语言","tags_index":"技术","author_index":"upstreamboat"},{"id":"2760989e79e2aad73e5334ce01559db2","title":"协程--chan","content":"协程–chan\ngo 后调用的函数，其返回值会被忽略。\n协程间的通信：\n内存共享\ncontext\nchannel\n\n\n控制协程：\ncontext\nsync.Group()\nchannel\n\n\nchan 关闭后，仍可以读取（读到零值），但不可以写入\n遍历 chan 时，如无数据，则会阻塞；如 chan 关闭，则会退出。\n从 chan 中读：j, ok := &lt;-c &#x2F;&#x2F; 如果接收不到数据,则 ok 为 false\nchan 的实际应用场景\n代码\n\n123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121package mainimport (    &quot;time&quot;)func execute(arr []int) &#123;    for _, i := range arr &#123;        time.Sleep(100 * time.Millisecond)        println(i)    &#125;&#125;func execute2(arr []int, c chan int) &#123;    sum := 0    for _, v := range arr &#123;        sum += v    &#125;    c &lt;- sum&#125;func fibonacci(n int, c chan int) &#123;    x, y := 0, 1    for i := 0; i &lt; n; i++ &#123;        c &lt;- x        x, y = y, x+y    &#125;    close(c) //如果不关闭通道,则在range遍历通道c时会造成阻塞&#125;func execute3() &#123;    var i int    for &#123;        i++        println(i)        time.Sleep(time.Second)    &#125;&#125;func main() &#123;    //并发: goroutine: goroutine间内存共享    /*    arr := []int&#123;111, 222, 333, 444&#125;        arr2 := []int&#123;11, 22, 33, 44&#125;        arr3 := []int&#123;1, 2, 3, 4&#125;        go execute(arr)  //这里excute()没有返回值,而在使用goroutine时,如果有返回值的话,返回值也会被忽略        go execute(arr2)        execute(arr3)    // 注释掉看看        go execute(arr3) //程序已结束,无法被执行*/    //通道: channel: 先入先出的队列,用于多个goroutine间传递消息    /*arr4 := []int&#123;1, 2, 3, 4, 5&#125;    c := make(chan int)    go execute2(arr4[:len(arr4)/2], c) //len()会向下取整    go execute2(arr4[len(arr4)/2:], c)    go execute2(arr4[:1], c)    //execute2(arr4, c)  //加上这行会造成死锁    sum, sum2, sum3 := &lt;-c, &lt;-c, &lt;-c    println(sum, sum2, sum3, sum+sum2+sum3)*/    //通道缓存    /*c := make(chan int, 2) //设置缓存大小为2    c &lt;- 1                 //如果未设置缓存,则此时无法存入数据1    c &lt;- 2                 //如果缓存大小设置为1,则此时无法存入数据2,需要先取出数据1才可继续存入    i := &lt;-c    println(i)    j, ok := &lt;-c //如果接收不到数据,则ok为false    println(j, ok)*/    //遍历通道    /*c := make(chan int, 10)    fibonacci(cap(c), c) //cap(): 获取容量不断遍历通道c，当c中无可读取数据则阻塞等待c被写入；当c关闭则退出遍历    for v := range c &#123;        println(v)    &#125;*/    //执行execute3()循环打印的同时等待用户输入,输入后按enter结束    /*go execute3()    var input string    //fmt.Scan(input)    fmt.Scan(&amp;input)*/    //将execute3()改成匿名函数形式    /*go func() &#123;        var i int        for &#123;            i++            println(i)            time.Sleep(time.Second)        &#125;    &#125;()    var input string    fmt.Scanln(&amp;input)*/    //生产者-消费者并发实例    /*c := make(chan int)    go func(c chan int) &#123;        for &#123;            data := &lt;-c            if data == 0 &#123;                break            &#125;            println(data)        &#125;    &#125;(c)    for i := 1; i &lt; 6; i++ &#123;        c &lt;- i    &#125;    c &lt;- 0*/    //单向通道的几种定义方式    /*var c1 &lt;-chan int      //声明只读通道    var c2 chan&lt;- int      //声明只写通道    c3 := make(&lt;-chan int) //初始化声明只读通道    c4 := make(chan&lt;- int) //初始化声明只写通道    c1 = c3    c2 = c4    println(c1, c2, c3, c4)*/&#125;\n","slug":"GO语言/基础/协程--chan","date":"2024-10-12T02:26:58.055Z","categories_index":"GO语言","tags_index":"技术","author_index":"upstreamboat"},{"id":"8cc002523a8a3e559c8e18f806da49cd","title":"context","content":"context\n用途：\n父协程控制子协程的生命（通过 WithCancel）\n父协程向子协程传递数据（通过 WithValue）。如果 WithValue 中传递 chan，则借助通道可以变相实现子向父传递。\n\n\n创建 context 对象的两种方式：区别\ncontext.Background() &#x2F;&#x2F; 顶级的、无附加值的基本 Context\ncontext.TODO() &#x2F;&#x2F; 暂时的、未确定的 Context\n\n\n\n\n\n\n\n\n这两种都是创建一个 emptyCtx 实例，可以传递给子协程\n\n\n\n传递 key-value 值：\ncontext.WithValue() &#x2F;&#x2F; 从传参的父 context 中，派生出一个携带 key-value 信息的 context\nctx.Value() &#x2F;&#x2F; 获取 ctx 实例中携带的 value，因为是 any 类型，所以需要类型断言下\n\n\n取消执行：\ncontext.WithCancel() &#x2F;&#x2F; 设置手动取消，会返回一个 cancel()，手动执行这个 cancel()后，ctx.Done()便不再为空\ncontext.WithTimeout() &#x2F;&#x2F; 设置超时自动取消。与 WithCancel 相比，会在设置的超时时间到期后，自动调用 cancel()\nWithDeadline() &#x2F;&#x2F; 也是超时自动取消，只不过参数是某个日期时间，而不是持续时间\n\n\n当 cancel()执行后：\nctx.Done() &#x2F;&#x2F; 返回一个在上下文因取消或超时被关闭的通道\nErr() &#x2F;&#x2F; Err 表示在 Done 通道关闭后为何取消此上下文\nDeadline() &#x2F;&#x2F; 返回上下文将被取消的时间(如果有的话)\n\n\n代码\n\n1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071func TestContext(t *testing.T) &#123;    ctx, cancel := context.WithCancel(context.Background())    //ctx, cancel := context.WithTimeout(context.Background(), time.Second * 3)    //ctx, cancel := context.WithDeadline(context.Background(), time.Now().Add(time.Second * 3))    go func(ctx context.Context) &#123;        for range time.Tick(time.Second) &#123;            selectchan &#123;            case &lt;-ctx.Done():  //当cancel()调用后，Done()返回的chan中便有了值，此时读取通道条件便满足，开始执行这个case                t.Log(&quot;time out!&quot;)                return //通过return可以退出deal()协程。如不退出，则会继续循环，直到主协程执行完            default:                println(&quot;--execute--&quot;)            &#125;        &#125;    &#125;(ctx)    time.Sleep(time.Second * 5)    cancel()    t.Log(ctx.Err())    t.Log(ctx.Deadline())    time.Sleep(time.Second * 2)&#125;//WithValue()func TestContextWithValue(t *testing.T) &#123;    ctx := context.Background()    contextWithValue(ctx)    ctx = context.WithValue(ctx, &quot;traceID&quot;, &quot;12345&quot;)    contextWithValue(ctx)&#125;func contextWithValue(ctx context.Context) &#123;    traceID, ok := ctx.Value(&quot;traceID&quot;).(string) //类型断言：是否为字符串，因为在通信过程中类型可能出现不可预知的变化    if ok &#123;        fmt.Println(&quot;traceID=&quot;, traceID)    &#125; else &#123;        fmt.Println(&quot;no traceID&quot;)    &#125;&#125;\n","slug":"GO语言/基础/context","date":"2024-10-12T02:26:57.980Z","categories_index":"GO语言","tags_index":"技术","author_index":"upstreamboat"},{"id":"d559e2cfaddfefc38af859dbdaec5c42","title":"IO","content":"IO\nio.NopCloser()：为已经被读取的请求&#x2F;响应的 body 重新赋值\n\n\n\n\n\n\n\n\n\nioutil.Nopcloser 返回一个 io.ReadCloser,并且 close()方法没有任何操作 no-op.我们在操作 req *http.Request 和 response *http.Response 的时候，有时候需要读取 Body,但是读了之后 Body 里面就被清空了，因比我们需要将读取的内容又重新赋值给 Body。它的类型为 io.Readc1oser。\n1234567func(response *http.Response) error&#123;\tcont,_ := iouti1.ReadAll(response.Body)\tfmt.Println(string(cont))\tresponse.Body = ioutil.Nopcloser(bytes.NewReader(cont))\treturn nil&#125;\n\n代码\n\n\n123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167package testsimport (    &quot;bufio&quot;    &quot;context&quot;    &quot;fmt&quot;    &quot;os&quot;    &quot;testing&quot;    &quot;time&quot;)func TestIO(t *testing.T) &#123;    /*reader := strings.NewReader(&quot;new reader create&quot;)    t.Log(reader.Len())    b := make([]byte, 5)    for &#123;        p, err := reader.Read(b) //最大按照b的长度读取，读取后b的值被覆盖，reader的值减少        //p, err := reader.ReadByte()  //按一个字节长度读取        if err != nil &#123;            if err == io.EOF &#123;                break            &#125;            t.Log(err)            os.Exit(99)        &#125;        t.Log(string(b[:p]))    &#125;*/    //pipe    /*re, wr := io.Pipe()    go func() &#123;        wr.Write([]byte(&quot;adsafd&quot;))        wr.Close()    &#125;()    www := make([]byte, 10)    re.Read(www)    t.Log(string(www))*/    //为什么读取失败？    //fil, _ := os.Create(&quot;D:\\\\test.txt&quot;)    //defer fil.Close()    ////写入文件    //io.WriteString(fil, &quot;asaajja&quot;)    //b, rerr := io.ReadAll(fil)    //dd := make([]byte, 10)    //b, rerr := io.ReadFull(fil, dd)    //t.Log(string(dd), &quot;,&quot;, b, rerr)    fil, _ := os.Open(&quot;D:\\\\test.txt&quot;)    defer fil.Close()    rb := make([]byte, 20)    fil.Read(rb)    t.Log(string(rb))    //re := strings.NewReader(&quot;ddsdsaads&quot;)    ////r := bufio.NewReader(re)  //创建缓冲区    //io.Copy(os.Stdout, re)    //标准输出    //io.WriteString(os.Stdout, &quot;dsas&quot;)    filee, _ := os.Stat(&quot;D:\\\\test.txt&quot;)    t.Log(filee.Mode())    eee := fil.Chmod(0777)    if eee != nil &#123;        t.Log(eee)    &#125;    byt := []byte(&quot;dad&quot;)    ll, errr := fil.Write(byt)    if errr != nil &#123;        t.Log(errr)    &#125;    t.Log(ll, string(byt))&#125;func TestIO2(t *testing.T) &#123;    //注意赋予os.O_RDWR权限，否则无法写入    filee, _ := os.OpenFile(&quot;D:\\\\test.txt&quot;, os.O_RDWR, 0777)    defer filee.Close()    //直接写入文件，会覆盖原内容    //filee.WriteString(&quot;aaaaaa&quot;)    bf := bufio.NewReader(filee)    wf := bufio.NewWriter(filee)    //读取文件，以“=”作为分割，读取的内容包含“=”及“=”前的内容    str, errr := bf.ReadString(&#x27;=&#x27;)    if errr != nil &#123;        t.Log(errr)    &#125;    t.Log(str)    //这里会追加内容而不是覆盖，因为bf读取操作把光标移动到了文件最后    wf.WriteString(&quot;vvvvv&quot;) //如果把这里的写入提到bf读取前面，那么光标会停在写入的最后一个字节后（注意不是文件的最后）    wf.Flush()              //将缓冲中的内容写入文件&#125;\n","slug":"GO语言/基础/IO","date":"2024-10-12T02:26:57.942Z","categories_index":"GO语言","tags_index":"技术","author_index":"upstreamboat"},{"id":"314b1e74b1bdc2924db38ca5d05f8c1a","title":"defer","content":"defer\n参考\n多个 defer 是栈存储，先入后出\n先 return，后 defer（按照代码执行顺序，return 是最后一步，所以后压栈，所以先弹出）\ndefer 最大的功能是 panic 后依然有效\n多个 panic 会被不断覆盖（仅最后一个 panic 有效）\ndefer 压栈会计算形参得到结果以实参入栈defer 虽然是最后执行，但是代码读取 defer 这一行时，便进行了压栈，同时如果 defer 中的函数有参数，会计算参数后压栈放着等待最后执行。\n返回值问题：a. 有名返回值，存储在上层函数栈中b. 无名返回值，存储在本身函数栈中\n例子：\n\n123456789101112131415161718func myFun() int &#123;    a := 1    b := 2\t// 值传递，压栈时传入的a始终为1    defer func(a int) &#123;        b = a        fmt.Printf(&quot;defer: a=%d\\n&quot;, a)    &#125;(a)    a = 3\t// 无名返回值，返回了2    return b&#125;// defer: a=1// myFUn:return: 2\n\n123456789101112131415161718func myFun() (b int) &#123;    a := 1    b = 2\t// 值传递，压栈时传入的a始终为1    defer func(a int) &#123;        b = a        fmt.Printf(&quot;defer: a=%d\\n&quot;, a)    &#125;(a)    a = 3\t// 有名返回值，虽然此时返回了2，但是b的作用域在上层，仍可继续使用，故在defer运算后成了1    return b&#125;// defer: a=1// myFUn:return: 1\n","slug":"GO语言/基础/defer","date":"2024-10-12T02:26:57.883Z","categories_index":"GO语言","tags_index":"技术","author_index":"upstreamboat"},{"id":"0cb0237168fea074f84d3cbb6f01b976","title":"Interface--类型断言","content":"Interface–类型断言作用可用于接口类型转换\n要点只有接口类型的变量能进行类型断言\n格式\n变量 b :&#x3D;变量 a.(类型)\n\n变量 b, ok &#x3D; 变量 a.(类型)\n\n\n\n\n\n\n\n\n\n建议使用第二种格式，因为如果使用第 1 种，出错的话程序直接 panic 了。比如：\n 12//c=context.WithValue(c,&quot;trade&quot;,tradeChannel) // 如果不写这句，便直接获取，使用第1种格式会panictrade,ok: = c.Value(&quot;trade&quot;).(chan interface&#123;&#125;)\n\n代码123456789101112131415161718type AA interface&#123;&#125;func Test1356(t *testing.T) &#123;    var e interface&#123;&#125;    e = &quot;eee&quot;\tresult, ok := e.(string) // 断言成功后，result是string类型    fmt.Println(result, ok)    fmt.Printf(&quot;%T\\n&quot;, result)    var f AA    f = &quot;fff&quot;    result, ok = f.(string)    fmt.Println(result, ok)&#125;\n\n运用switch 对象.(type) {} 用于根据对象类型做不同处理\n","slug":"GO语言/基础/Interface--类型断言","date":"2024-10-12T02:26:57.859Z","categories_index":"GO语言","tags_index":"技术","author_index":"upstreamboat"},{"id":"83ec08d7c30843102113f6d86ff9f083","title":"Interface","content":"Interface\n如果一个结构体实现了接口的所有方法，那么该结构体变实现了该接口，满足里氏替换原则。\n如果结构体 A 是结构体 B 中的字段，那么 A 类似是 B 的父类（注意只是类似，无法里氏替换，其本质是组合），B 可以调用 A 的属性和方法。如果 A 实现了某接口，那么 B 便也是实现了该接口的。\n\n1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889909192939495package mainimport (    &quot;math&quot;)type Geometry interface &#123;    area() float64    perimeter() float64&#125;type Rectangle struct &#123;    width, height float64&#125;func (r Rectangle) area() float64 &#123;    return r.width * r.height&#125;func (r Rectangle) perimeter() float64 &#123;    return 2*r.width + 2*r.height&#125;type Circle struct &#123;    radius float64&#125;func (c *Circle) area() float64 &#123;    return math.Pi * c.radius * c.radius&#125;func (c *Circle) perimeter() float64 &#123;    return 2 * math.Pi * c.radius&#125;/*func main() &#123;    r := Rectangle&#123;width: 1, height: 1&#125;    c := Circle&#123;radius: 1&#125;    fmt.Println(&quot;Rectangle&quot;)    fmt.Println(&quot;Area: &quot;, r.area())    fmt.Println(&quot;Perimeter: &quot;, r.perimeter())    fmt.Println(&quot;\\nCircle&quot;)    fmt.Println(&quot;Area: &quot;, c.area())    fmt.Println(&quot;Perimeter: &quot;, c.perimeter())    var g Geometry    g = r    r.width = 2 //r中的值改变了，但是g中仍然是之前r的值，在下面函数内计算时使用旧的值    fmt.Println(&quot;\\nRectangle after modification&quot;)    fmt.Println(&quot;Area: &quot;, g.area())    fmt.Println(&quot;Perimeter: &quot;, g.perimeter())    g = &amp;c    c.radius = 2 //c中的值改变了，但是g保存的是c中值的地址，在下面函数内计算时会通过地址寻找新的值    fmt.Println(&quot;\\nCircle after modification&quot;)    fmt.Println(&quot;Area: &quot;, g.area())    fmt.Println(&quot;Perimeter: &quot;, g.perimeter())&#125;*/\n","slug":"GO语言/基础/Interface","date":"2024-10-12T02:26:57.839Z","categories_index":"GO语言","tags_index":"技术","author_index":"upstreamboat"},{"id":"3aebc06e8b6daa57452d876cf23759fc","title":"语法--进阶","content":"语法–进阶\n异常处理（defer、panic、recover）\n\n整型和字符串相互转换\n\nos 库\n\n同步 sync（syncGroup、syncMap、select 通道条件语句、runtime）sync.Pool：用于复用对象，以减少频繁的内存分配和垃圾回收带来的性能损耗。参考sync.Mutex：锁\n\n\n\n\n\n\n\n\n\nMutex 是最简单的一种锁类型，同时也比较暴力，当一个 goroutine 获得了 Mutex 后，其他 goroutine 就只能乖乖等到这个 goroutine 释放该 Mutex RWMutex 相对友好些，是经典的单写多读模型atomic 包：原子操作，针对基本数据类型可以使用原子操作来保证并发安全，性能比加锁操作更好\n sync.Map：线程安全的。新增元素性能差，仅为 普通的 map + 锁 的一半；但是查、删性能更好，因为其内部维护了一个 read 结构，查、删时不需要加锁 **sync.Once()**：只执行一次\n\n\n123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195package testsimport (\t&quot;fmt&quot;\t&quot;os&quot;\t&quot;runtime&quot;\t&quot;strconv&quot;\t&quot;sync&quot;\t&quot;testing&quot;\t&quot;time&quot;)//异常处理/*\tdefer\tpanic\trecover*/func TestException(t *testing.T) &#123;//defer后面跟函数调用defer t.Log(&quot;TestException finish&quot;)defer func() &#123;//recover()必须与defer连用。如果未出现panic，则recover()为nilif err:=recover(); err!= nil &#123;t.Log(&quot;recover finish&quot;,err)&#125;&#125;()t.Log(&quot;TestException star&quot;)//遇到panic，程序崩溃，直接运行defer，之后输出panic的信息和打印错误栈轨迹panic(&quot;errro!&quot;)t.Log(&quot;arrive here?&quot;) //无法到达的语句&#125;func TestOS(t *testing.T) &#123;//创建文件fil, err := os.Create(&quot;D:\\\\test.txt&quot;)handleError(err)defer func() &#123;err2 := fil.Close()handleError(err2)&#125;()//&#123;...调用fil的相关函数...&#125;//文件信息filStat, err2 := os.Stat(&quot;D:\\\\test.txt&quot;)handleError(err2)//&#123;...调用filStat的相关函数...&#125;t.Log(filStat.Name())//打开文件//os.Open(&quot;D:\\\\test.txt&quot;)//os.OpenFile(&quot;D:\\\\test.txt&quot;,os.O_RDWR,0777)//修改文件权限//os.Chmod(&quot;D:\\\\test.txt&quot;,0666)//fil.Chmod(0666)//进程id//os.Getpid()&#125;func handleError(err error) &#123;if err != nil &#123;fmt.Println(&quot;error happened&quot;, err)&#125;&#125;func TestSynchronization(t *testing.T) &#123;lock := sync.Mutex&#123;&#125;//rwlock:=sync.RWMutex&#123;&#125;wg := sync.WaitGroup&#123;&#125;sum := 0for i := 0; i &lt; 20; i++ &#123;wg.Add(1)go func() &#123;//runtime的几个函数runtime.Gosched() //先赋予时间片给其它协程//runtime.Goexit()  //退出当前协程，结束前会先执行已注册的defer语句runtime.GOMAXPROCS(1) //选择调度器数量lock.Lock()sum += 1t.Log(&quot;fun: &quot;, sum, &quot; &quot;, i)lock.Unlock()wg.Done()&#125;()&#125;wg.Wait()t.Log(&quot;--finish--&quot;)&#125;//SyncMapfunc TestSyncmap(t *testing.T) &#123;syncM := sync.Map&#123;&#125;syncM.Store(&quot;a&quot;, 97)syncM.Store(&quot;A&quot;, 65)syncM.Load(&quot;a&quot;)syncM.Delete(&quot;A&quot;)syncM.Range(func(key, value any) bool &#123;t.Log(key, &quot; = &quot;, value) //遍历获取的元素顺序不固定return true              //如果为false，则退出遍历&#125;)// LoadOrStore()：如果提供的key存在，则返回已存在的值(Load)，否则保存提供的键值(Store)&#125;//select通道条件语句func TestSelect(t *testing.T) &#123;c := make(chan int)select &#123;case c &lt;- 1: //接收数据成功，则执行这个caset.Log(&quot;write&quot;)case cc, _ := &lt;-c: //读取数据成功，则执行这个caset.Log(cc)default: //都不成功执行这句。但若上面的多个case都成功了，则随机执行上面成功的case中的一个t.Log(&quot;no&quot;)&#125;&#125;\n\nsyncMap 的性能测试：\n1234567891011121314151617181920212223242526272829303132333435363738394041var syncMap *sync.Mapfunc init() &#123;syncMap = &amp;sync.Map&#123;&#125;&#125;func storeSyncMap(k, v int) &#123;syncMap.Store(k, v)&#125;func deleteSyncMap(k int) &#123;syncMap.Delete(k)&#125;func Benchmark1(b *testing.B) &#123;b.ResetTimer()b.RunParallel(func(pb *testing.PB) &#123;r := rand.New(rand.NewSource(time.Now().Unix()))for pb.Next() &#123;k := r.Intn(1000000)storeSyncMap(k, k)&#125;&#125;)b.StopTimer()&#125;\n","slug":"GO语言/基础/语法--进阶","date":"2024-10-12T02:26:57.810Z","categories_index":"GO语言","tags_index":"技术","author_index":"upstreamboat"},{"id":"936cdde37333da2f8449b84496bc5908","title":"语法--基础","content":"语法–基础目录：{ 全局变量、局部变量、几种 print 函数、几种运算符、常量 const 和 iota、指针、条件和循环语句、匿名函数、数组、切片、结构体 }\n123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195package mainimport &quot;fmt&quot;//全局变量/*    全局变量：全包可见；存在未使用的全局变量时可编译通过    局部变量：函数内可见；存在未使用的局部变量时编译报错*/var a_ intvar (    b_ int    c_ int)var d_ = 3//e_ := 4    //报错：初始化声明只可以用在函数中func main() &#123;    //局部变量声明    var a int    var b int //声明时int不可省略    //局部变量初始化    var c = 3.1 //初始化int时可省略    d := 4    //打印    print(a, b, c, d)    println(a, b, c, d)    fmt.Printf(&quot;%d,%v,%.2f,%p\\n&quot;, a, b, c, &amp;d)    //Sprintf: 有返回值的格式化打印    println(fmt.Sprintf(&quot;THIS--%d,%v,%.2f,%p&quot;, a, b, c, &amp;d))    //返回计算结果：+、-、*、/、%    //返回true/false：==、&gt;、&lt;、&gt;=、&lt;=、!=    //返回true/false：&amp;&amp;（同真则真）、||（有真则真）、！（非）    //返回计算结果：&amp;（同1则1）、|（有1则1）、^（同0异1）、&lt;&lt;（等效于*2^n，高位丢弃、低位补0）、&gt;&gt;    //=、&amp;、*    //iota：自增计数器，遇到const声明时重置    const A int = 3    const A1 = iota    const A2 = 2    const A3 = iota    const (        B = 1        C = iota        D = &quot;haha&quot;        E        F = iota        G    )    //指针    var ptr *int    ptr2 := &amp;a    //ptr3 := &amp;A    //报错：常量无法取地址       var ptr4 *int = &amp;b    //println(*ptr) //报错：指针未初始化，无法获取值    println(ptr, ptr2, ptr4, *ptr2, *ptr4)       var ptr5 **int    ptr5 = &amp;ptr2    println(ptr5, *ptr5, **ptr5)    //条件语句    println(&quot;--条件语句--&quot;)    if a &gt; 0 &#123;        println(&quot;a&gt;0&quot;)    &#125; else if a &lt; 0 &#123;        println(&quot;a&lt;0&quot;)    &#125; else &#123;        println(&quot;a=0&quot;)    &#125;    switch a &#123;    case 0:        println(&quot;a==0&quot;)    case 1:        println(&quot;a&gt;=0&quot;)    default:        println(&quot;a&lt;=0&quot;)    &#125;    //a可以放到内部    switch &#123;    case a == 0:        println(&quot;a==0&quot;)    case a == 1:        println(&quot;a&gt;=0&quot;)    default:        println(&quot;a&lt;=0&quot;)    &#125;    //循环    println(&quot;--循环语句--&quot;)    var i int    //LOOP1：    for i = 0; i &lt; 2; i++ &#123;        println(&quot;hehe&quot;)        if i == 1 &#123;            goto LOOP            //goto LOOP1  //小心：如果执行LOOP1，会无限循环        &#125;    &#125;LOOP:    println(&quot;he11he&quot;)    //死循环    for&#123;&#125;    // go中使用的是值传递，函数内操作无法改变实际参数    // 要改变实际参数可以使用引用传递    // 匿名函数    println(&quot;--匿名函数--&quot;)    aa := func() int &#123;        return 3    &#125;    println(aa())    fun1 := fun(aa())    println(fun1(2))    println(&quot;zero--&quot;)    fun11 := fun2()    println(&quot;one--&quot;)    //匿名函数也是需要调用才会执行，且调用时只执行当前匿名函数，不会执行外部函数    println(fun11())    println(&quot;two--&quot;)    println(fun11())    //数组    //数组是值传递    println(&quot;--数组--&quot;)    var arr []int    arr = []int&#123;2, 3&#125;    var arr1 = []int&#123;1, 2, 3&#125;    arr2 := [3]int&#123;1, 2&#125;    println(arr) //只能打印出地址    fmt.Println(arr)    fmt.Println(arr1)    fmt.Println(arr2)    //切片    //切片是引用传递    println(&quot;--切片--&quot;)    sli := []int&#123;1, 2, 3&#125;  //初始化方式1    sli2 := make([]int, 3)  //初始化方式2    fmt.Println(sli)    fmt.Println(sli2)    sli = sli[1:2] //截取元素    fmt.Println(sli)    sli = append(sli, 4) //append()追加元素    fmt.Println(sli)    len := copy(sli2, sli) //copy()将sli复制到sli2中,返回被复制元素个数    fmt.Println(len, sli2)    sli3 := []int&#123;1, 2, 3, 4, 5&#125;    copy(sli3[0:2], sli3[1:3])    fmt.Println(sli3)    sli4 := []int&#123;1, 2, 3, 4, 5&#125;    sli4 = append(sli4[2:3], sli4[0:2]...) //向sli4[2:3]中追加切片    fmt.Println(sli4)    //要打印数组和结构体内容，需要使用fmt.Print    //结构体    println(&quot;--结构体--&quot;)    var s SS    s.name = &quot;xiaoming&quot;    s.age = 18    println(s.name, s.age)    //println(s)  //报错：无法使用println打印，需要使用的是fmt.Println    s2 := SS&#123;name: &quot;q&quot;&#125;    fmt.Println(s2)&#125;func fun(bb int) func(cc int) int &#123;    return func(cc int) int &#123;        return cc + bb    &#125;&#125;func fun2() func() int &#123;    i := 0    println(&quot;执行fun2&quot;)    return func() int &#123;        println(&quot;执行匿名fun&quot;)        i++        return i    &#125;&#125;type SS struct &#123;    name string    age  int&#125;\n","slug":"GO语言/基础/语法--基础","date":"2024-10-12T02:26:57.700Z","categories_index":"GO语言","tags_index":"技术","author_index":"upstreamboat"},{"id":"59a6b28686051f5f0b4e5a6fbd68c9a5","title":"知识点","content":"知识点1. 变量\n自动推断变量类型\n\n全局变量：全包可见；存在未使用的全局变量时可编译通过局部变量：函数内可见；存在未使用的局部变量时编译报错\n\n非引用类型变量：声明后便会分配内存，可以直接使用，默认自动初始化为类型零值。引用类型的变量：不可直接用，必须初始化\n 12var m map[int]intm[1] = 1 // error：assignment to entry in nil map\n变量的初始化声明:=只可以用在函数中\n\n变量类型：声明时不可省略，初始化时可省略\n\n未使用变量为错误\n\n变量运算：\n 1234返回计算结果：`+、-、*、/、% `返回 true/false：`==、&gt;、&lt;、&gt;=、&lt;=、!=`返回 true/false：`&amp;&amp;（同真则真）、||（有真则真）、！（非）`返回计算结果：`&amp;（同 1 则 1）、|（有 1 则 1）、^（同 0 异 1）、&lt;&lt;（等效于2^n，高位丢弃、低位补 0）、&gt;&gt;`\n\n\n\n\n\n\n\n\n\n\n\n位移：y &lt;&lt; n == y * (2^n)，左移 n 位就是乘以 2 的 n 次方，高位丢弃，低位补 0；右移 n 位就是除以 2 的 n 次方\n三目运算符： Go 语言没有三目运算符，所以不支持  ?:  形式的条件判断\n\n 123运算符优先级：(.) &gt; (*、&amp;) &gt; (++、--)p := &amp;t.x // &lt;=&gt; p := &amp;(t.x)*p++ // &lt;=&gt; (*p)++\n\n 12取余运算时，余数总是小于被除数，由此可以设置首尾相接的环。比如一个 0~3 的环，就可以用 n%4 取余得到，每次 n++后，余数都会变：0，1，2，3，0，1，2，3......\n\n数据类型：本质：固定内存大小的别名作用：编译器预算对象(变量)分配的内存空间大小分类：\n\n基本类型：数字、字符串和布尔值\n聚合类型：数组和结构体\n引用类型：切片、映射、通道、指针、函数、接口\n\n\n\n\n\n\n\n\n\n\n对于引用类型的变量，存储的是内存地址，不光要声明它，还要为它分配内存空间引用类型的零值为 nil引用类型是指针传递，特别注意：切片是指针传递（会修改底层数组，因为切片是指向数组的指针）、数组是值传递\n\n当标识符（包括常量、变量、类型、函数名、结构字段等等）以一个大写字母开头，则包外可见，类似 public；如以小写字母开头，则仅包内可见，类似 protected\n\n\n2. 常量\niota：自增计数器，遇到 const 声明时重置\n不指定类型的常量叫 Untyped 常量,可以作不同类型使用\n\n3. 函数\n函数：func myFun()\n\n\n\n\n\n\n\n\n\n直接通过包名调用：包名.myFun()\n 方法：func (c *client) myFun()\n\n\n\n\n\n\n\n\n\n需要通过结构体对象调用：c.myFun()作用：自我总结：1）用来实现接口；2）限制作用域，使其只能被限定对象调用\n\n匿名函数也是需要调用才会执行，且调用时只执行当前匿名函数，不会执行外部函数\n\n\n4. 线程\n使用 go 关键字创建 goroutine 时，被调用函数的返回值会被忽略\ngoroutine 间内存共享\n通道的收发操作在不同的两个 goroutine 间进行. 由于通道的数据在没有接收方处理时，数据发送方会持续阻塞，因此通道的接收必定在另外一个 goroutine 中进行\nChanel：当通道被关闭时，写入通道会引发 panic，读取通道会一直都是类型零值。\n\n\n\n\n\n\n\n\n判断通道是否被关闭的两种方式：\n\n方式一：i, ok :&#x3D; &lt;-ch1 &#x2F;&#x2F; 通道关闭后再取值 ok&#x3D;false\n方式二：for i :&#x3D; range ch2 {fmt.Println(i)} &#x2F;&#x2F; 通道关闭后会退出 for range 循环\n\n\n\n5. 文件\n文件：-rwxrwxrwx，目录：drwxrwxrwx（-代表文件，d 代表目录）\n\n\n\n\n\n\n\n\nrwx：读、写、执行权限-rwx——：文件拥有者的权限；—-rwx—：文件拥有者所在的用户组的权限；——-rwx：其他所有人的权限-rwxrwxrwx，对应 0777；-rw-rwxrwx，对应 0677；-r–rwxrwx，对应 0477；—-rwxrwx，对应 0077\n\n\n6. 其它\nfmt.Sprintf：有返回值的格式化打印\n\n指针未初始化，无法获取值\n\n值传递不会影响到实际参数，引用传递会影响到实际参数\n\n值接收者方法(c client)：会将结构体值拷贝一份，然后对副本进行操作；而指针接收者方法(c *client)：直接操作原始结构体指针所指向的对象。\n\n数组是相同数据类型的集合，结构体是不同数据类型的集合\n\n反射：反射的核心是两个对象，分别是  reflect.Type  和  reflect.Value。 它们分别代表了 go 语言中的类型和值。我们可以通过  reflect.TypeOf  和  reflect.ValueOf  来获取到一个变量的类型和值。\n\n\n\n\n\n\n\n\n\n通过反射可以获取目标的类型、值等，也可以通过反射修改其值，但是修改时要注意：\n\n如对结构体中字段修改，字段需可见（即首字母需要大写）\n当 reflect.ValueOf(目标)时，目标必须是地址。可以调用 elem()返回“地址 Value”指向的“值 Value”。有些方法，是“地址 Type”或“地址 Value”无法访问的，必须转成“值”。\n\n\n标签 tag\n\n示例：mapstructure:&quot;port&quot; json:&quot;port&quot; yaml:&quot;port&quot; binding:&quot;required&quot; valid:&quot;matches([0-9])&quot;\n作用：将数据与对象进行关联，可以进行序列化和反序列化。如：\n\n\n\n\n\n\n\n\nmapstructure：将配置数据读到结构体字段中json：将字段内容写入 jsonyaml：将字段内容写入 yaml 文件gorm:&quot;column:name&quot;：将字段与数据库列名对应需要\n\n\n binding 会在 ShouldBindJSON()时进行检查；valid 会在 govalidator.ValidateStruct()时进行检查\n\nMutex.TryLock：允许在非阻塞模式下获取锁，如果锁已被获取，该函数将直接返回布尔值  false，而不是一直等待锁释放。\n\n切片 slice：切片是引用类型，是指向底层数组的指针，对切片的操作其实是对底层数组的操作。当发生扩容时，该指针地址便会改变，因为扩容是把当前数组内容复制到一个新数组中。\n\n读取 map：map：value, ok := x[&quot;key&quot;] # map 可以返回两个值，值 2 用来判断是否存在 key\n\n\n\n\n\n\n\n\n\n不可以用值 1 判断是否存在 key，因为如果值 1 为类型零值，可能是 key 存在，但其值就是零值\n\nunsafe.Pointer：任意类型的指针。\n\n\n\n\n\n\n\n\n\n一般指针定义时需要指明类型，如*int，而 Pointer 可以和任意类型的指针（或者和 uintptr）相互转换。uintptr：类型是一个整型，用来存储十进制的地址。指针无法进行算术运算，转换为 uintptr 后便可以了，因为它是整型。\n\n无法取地址：常量、字面量、map 中的元素\n\nmap、slice、function 是不可比较类型，其余都是可比较类型。如果要比较结构体、数组，其中的元素必须是可比较类型。结构体比较规则：\n\n\n\n\n\n\n\n\n\n\n属性类型、个数、顺序三者都相同；\n属性中不含有不可以比较的类型。即如果含有 map、slice，则结构体不能用==比较。\n\n\n类型转换数字：强转：float32(num1)字符串：strconv.Atoi(&quot;1&quot;)和 strconv.Itoa(2)接口：详见”接口的类型断言”\n\ngo vet：代码错误检查\n\nresp.Body.Close()：请求响应后应调用该方法，避免内存泄漏\n\nGo 项目程序（不包含 Test 程序）的文件层级无论多深，其当前目录始终是项目根目录\n\ncmd 库：\n123cmd := exec.Command(&quot;git&quot;, &quot;stash&quot;, &quot;list&quot;)err := cmd.Run()        // 无输出运行out, err := cmd.CombinedOutput()        // 有输出运行\n//go:generate 代码 # 当在终端执行 go generate 时，会执行该代码//go:build haha # 写在文件开头，当在终端执行 go build -tags &quot;haha&quot;时，会编译该文件\n\ngo build 未指定包或文件时，会编译当前目录\n\n\n","slug":"GO语言/基础/知识点","date":"2024-10-12T02:26:57.586Z","categories_index":"GO语言","tags_index":"技术","author_index":"upstreamboat"},{"id":"5fde7d8dfbaede438153d7eedc66411c","title":"组件通信","content":"\n\n\n\n\n\n\n\n\npinia\n全局变量\n任意组件通信\n\n\ndefineProps\n1）组件标签的变量、函数2）路由组件的参数\n父子互传\n\n\ndefineEmits\n组件标签的函数（事件）\n子传父\n\n\nmitt\n绑定事件；触发事件\n任意组件通信\n\n\n$attrs\n透传。是 defineProps 的扩展运用。组件标签的变量、函数\n祖先、后代互传\n\n\nslot\n作用域插槽\n子传父\n\n\nslot\n普通插槽\n父传子\n\n\n$refs\n获取所有的子组件实例\n子传父\n\n\n$parent\n获取父组件实例\n父传子\n\n\nprovide、inject\n祖先和后代通信\n祖先、后代互传\n\n\n","slug":"杂学/前端/vue/组件通信","date":"2024-10-12T02:10:21.762Z","categories_index":"vue","tags_index":"技术","author_index":"upstreamboat"},{"id":"6a1259a6bfeaa2e55261e49e8589ab21","title":"slot","content":"作用插槽：组件内部块，可以实现同一块中根据父组件的传入，从而展示不同内容\n用法A.vue：\n123456789101112&lt;template&gt;  &lt;h1&gt;A&lt;/h1&gt;  &lt;A_1&gt;    &lt;template v-slot:s1=aa&gt; 展示区1号 &#123;&#123; aa.x &#125;&#125;&lt;/template&gt;  &lt;/A_1&gt;  &lt;hr&gt;  &lt;A_1&gt;    &lt;template v-slot:s2=bb&gt; 展示区2号 &#123;&#123; bb.y &#125;&#125;&lt;/template&gt;  &lt;/A_1&gt;&lt;/template&gt;\n\nA_1.vue：\n123456789&lt;template&gt;  &lt;h1&gt;A_1&lt;/h1&gt;  &lt;slot name=&quot;s1&quot; x=&quot;fuck&quot; y=&quot;damn&quot;&gt;插槽1位置&lt;/slot&gt;  &lt;hr&gt;  &lt;slot name=&quot;s2&quot; y=&quot;damn&quot;&gt;插槽2位置&lt;/slot&gt;&lt;/template&gt;\n","slug":"杂学/前端/vue/slot","date":"2024-10-12T02:08:12.259Z","categories_index":"vue","tags_index":"技术","author_index":"upstreamboat"},{"id":"dbbbbeddcb97f722aafd87d6cc97502f","title":"$attrs","content":"作用透传，不断向下传递，中间组件加上 v-bind&#x3D;”$attrs”标签\n用法ABC.vue：\n1&lt;BC :a=&quot;1&quot; :sendB=&quot;getB&quot;/&gt;\n\nBC.vue：\n1&lt;C v-bind=&quot;$attrs&quot;/&gt;\n\nC.vue：\n1defineProps([&#x27;a&#x27;, &#x27;sendB&#x27;])\n","slug":"杂学/前端/vue/$attrs","date":"2024-10-12T02:06:18.593Z","categories_index":"vue","tags_index":"技术","author_index":"upstreamboat"},{"id":"c3e29552b457e41cdbaf0b1abd80046b","title":"mitt","content":"作用任意两个组件间通信\n用法emitter.ts：\n1234import mitt from &#x27;mitt&#x27;// 创建emitterexport const emitter = mitt()\n\nA.vue：\n1234567891011import &#123; emitter &#125; from &#x27;@/stores/emitter&#x27;// 绑定事件emitter.on(&quot;send-c&quot;,(value)=&gt;&#123;    console.log(value)&#125;)// 组件卸载时解除事件，以免内存占用onUnmounted(()=&gt;&#123;  emitter.off(&quot;send-c&quot;)&#125;)\n\nB.vue：\n1234import &#123; emitter &#125; from &#x27;@/stores/emitter&#x27;// 触发事件emitter.emit(&quot;send-c&quot;,&quot;ddd&quot;)\n","slug":"杂学/前端/vue/mitt","date":"2024-10-12T02:03:28.003Z","categories_index":"vue","tags_index":"技术","author_index":"upstreamboat"},{"id":"4b83d48791a9710fa03f8d8996ab98d5","title":"defineEmits","content":"defineProps 和 defineEmits：\n\n不同：  1）defineProps 可以接收普通组件的变量标签、函数标签；defineEmits 只接收函数标签  通过变量标签，父组件可以将变量传给子组件，即实现父传子  通过函数标签，父组件可以通过函数的参数获取子组件的变量，即实现子传父  2）defineProps 可以接收路由组件的参数\n\n相同：都可以接收函数标签  定义函数\n  12345function getB(value:string)&#123;  console.log(value)&#125;&lt;Person :num=&quot;1&quot; :sendB=&quot;getB&quot; @send-b=&quot;getB&quot;/&gt;  // 注意：props是：，而Emits是@\n\n  接收\n  12345const props = defineProps([&#x27;num&#x27;,&#x27;sendB&#x27;])props.sendB(&quot;fuck&quot;)const emit = defineEmits([&#x27;send-b&#x27;])emit(&#x27;send-b&#x27;,&quot;damn&quot;)\n\n  defineEmits 还有一种接收方式，但是只能用在 DOM 中：\n  1&lt;button @click=&quot;$emit(&#x27;send-b&#x27;,&#x27;sb&#x27;)&quot;&gt;点一下&lt;/button&gt;\n\n","slug":"杂学/前端/vue/defineEmits","date":"2024-10-12T01:58:13.089Z","categories_index":"vue","tags_index":"技术","author_index":"upstreamboat"},{"id":"9719ec2d673a403aa322d2f3381460fc","title":"defineProps","content":"作用：组件标签上元素，可以通过 defineProps()获得。\ndefineProps 可以接收普通组件标签的元素，也可以接收路由组件的参数（详见 router 篇）\n123456789// App.vue&lt;template&gt;  &lt;Person :a=&quot;aa&quot; :b=&quot;people&quot; /&gt;&lt;/template&gt;&lt;script setup lang=&quot;ts&quot;&gt;let aa = &#x27;fuck&#x27;let bb = &#x27;damn&#x27;&lt;/script&gt;\n\n12345678// Person.vue&lt;template&gt;  &#123;&#123; a &#125;&#125; &#123;&#123; b &#125;&#125;&lt;/template&gt;&lt;script setup lang=&quot;ts&quot;&gt;defineProps([&#x27;a&#x27;, &#x27;b&#x27;])&lt;/script&gt;\n\n注意：这样获得 a、b 只能在 template 中使用，script 中是无法使用的。需要保存到变量中：\n123456789&lt;script setup lang=&quot;ts&quot;&gt;// defineProps([&#x27;a&#x27;, &#x27;b&#x27;])// console.log(a,b)  // error: 找不到a、blet ab = defineProps([&#x27;a&#x27;, &#x27;b&#x27;])console.log(ab.a, ab.b)&lt;/script&gt;\n\n可以通过泛型来约束标签传入的元素类型\n1defineProps&lt;&#123; people:PersonConstraint &#125;&gt;()\n","slug":"杂学/前端/vue/defineProps","date":"2024-10-12T01:52:51.211Z","categories_index":"vue","tags_index":"技术","author_index":"upstreamboat"},{"id":"2a60f77314330572f365b0f5b003c4b8","title":"pinia","content":"作用封装全局变量，用于组件间数据共享。因为是全局变量，一旦被修改，所有地方都变化\n用法1. 创建 pinia12345678910111213141516171819// count.tsimport &#123; defineStore &#125; from &#x27;pinia&#x27;import &#123; ref &#125; from &#x27;vue&#x27;export const useCountStore = defineStore(&#x27;count&#x27;, () =&gt; &#123;  // 这个&#x27;count&#x27;是该store的唯一标识，不可重复  const sum = ref(1)  function updateSum(value: number) &#123;    sum.value += value  &#125;  function computeSum(value: number) &#123;    return sum.value + value  &#125;  return &#123; sum, updateSum, computeSum &#125;&#125;)\n\n2. 启用 pinia1234567import &#123; createPinia &#125; from &#x27;pinia&#x27;const app = createApp(App)const pinia = createPinia()app.use(pinia)\n\n3. 使用 pinia123456789101112131415161718import &#123; useCountStore &#125; from &#x27;@/stores/count&#x27;import &#123; storeToRefs &#125; from &#x27;pinia&#x27;import &#123; useRouter &#125; from &#x27;vue-router&#x27;const router = useRouter()const countStore = useCountStore()// 结构体赋值会丢失响应式，需要使用storeToRefsconst &#123; sum &#125; = storeToRefs(countStore)// countStore.$subscribe相当于watch()，当countStore内容变化时被调用。mutate是本次修改的信息，state是修改后的statecountStore.$subscribe((mutate, state) =&gt; &#123;  console.log(mutate, state)  if (sum.value &gt; 4) &#123;    router.push(&#x27;/news&#x27;)  &#125;&#125;)\n","slug":"杂学/前端/vue/pinia","date":"2024-10-12T01:49:22.361Z","categories_index":"vue","tags_index":"技术","author_index":"upstreamboat"},{"id":"dd5268e651fb95dca6972af9149bc813","title":"生命周期与钩子","content":"1234567891011onBeforeMount(()=&gt;&#123;&#125;)onMounted(()=&gt;&#123;&#125;)onBeforeUpdate(()=&gt;&#123;&#125;)onUpdated(()=&gt;&#123;&#125;)onBeforeUnmount(()=&gt;&#123;&#125;)onUnmounted(()=&gt;&#123;&#125;)\n","slug":"杂学/前端/vue/生命周期与钩子","date":"2024-10-12T01:48:54.561Z","categories_index":"vue","tags_index":"技术","author_index":"upstreamboat"},{"id":"451b8d726459bee081a2a105ec00e945","title":"hooks","content":"123456789101112131415161718// useDog.tsimport axios from &#x27;axios&#x27;import &#123; ref &#125; from &#x27;vue&#x27;export default function() &#123;  const dogs = ref([&#x27;&#x27;])   async function getDog() &#123;    try &#123;      const result = await axios.get(&#x27;https://jsonplaceholder.typicode.com/posts/&#x27;)      dogs.value.push(result.data.message)    &#125; catch (err) &#123;      alert(err)    &#125;  &#125;  return &#123;dogs, getDog&#125;&#125;\n\n12345678910// App.vue&lt;script setup lang=&quot;ts&quot;&gt;import useDog from &#x27;@/hooks/useDog&#x27;let &#123; dogs, getDog &#125; = useDog()getDog()console.log(dogs)&lt;/script&gt;\n","slug":"杂学/前端/vue/hooks","date":"2024-10-12T01:47:56.067Z","categories_index":"vue","tags_index":"技术","author_index":"upstreamboat"},{"id":"cf6c58cf6e0199fa915a4eb514ed86d2","title":"router","content":"路由组件六步走\n创建组件：Detail.vue\n\n创建路由：const routes &#x3D; [{},{}…]\n\n配置路由占位：\n\n配置路由导航：XXX\n\n创建路由器：const router &#x3D; createRouter(xxx,routes)\n\n使用路由器：app.use(router)\n\n\n子路径12345678910&#123;    path: &#x27;/news&#x27;,    component: News,    children: [      &#123;        path: &#x27;detail&#x27;,        component: Detail      &#125;    ]&#125;\n\n参数传递123456789101112&lt;RouterLink:to=&quot;`/news/detail?id=aaa&amp;content=bbb`&quot;&gt;固定查询参数&lt;/RouterLink&gt;&lt;RouterLink:to=&quot;`/news/detail?id=$&#123;n.id&#125;&amp;content=$&#123;n.content&#125;`&quot;&gt;动态查询参数1&lt;/RouterLink&gt;&lt;RouterLink :to=&quot;&#123;      path:&#x27;/news/detail&#x27;,      query:&#123;        id: n.id,        content: n.content      &#125;    &#125;&quot;&gt;动态查询参数2&lt;/RouterLink&gt;\n\n123import &#123; useRoute &#125; from &#x27;vue-router&#x27;const ab = useRoute()&#123;&#123; ab.query.id &#125;&#125;\n\n路径参数：\n1234567891011&lt;RouterLink :to=&quot;`/news/detail/aaa/bbb`&quot;&gt;固定路径参数&lt;/RouterLink&gt;//注意：这里只能使用name，而不能用path&lt;RouterLink\t:to=&quot;&#123;\t\tname: &#x27;detail&#x27;,\t\tparams: &#123; id: n.id,content: n.content &#125;\t&#125;&quot;&gt;    动态路径参数&lt;/RouterLink&gt;\n\n1path:&#x27;detail/:id/:content&#x27;,\n\n123import &#123; useRoute &#125; from &#x27;vue-router&#x27;const ab = useRoute()&#123;&#123; ab.params.id &#125;&#125;\n\n通过 props 传参，可以替换掉 useRoute()代码：\n12345// 路径传参name:&#x27;detail&#x27;,path:&#x27;detail/:id/:content&#x27;,component:Detail,props:true,\n\n1234// 查询传参props(route)&#123;    return route.query&#125;\n\n12// 接收defineProps([&#x27;id&#x27;,&#x27;content&#x27;])\n","slug":"杂学/前端/vue/router","date":"2024-10-12T01:39:55.170Z","categories_index":"vue","tags_index":"技术","author_index":"upstreamboat"},{"id":"6b30ca1d6f90b3c88a0e57ca647706ec","title":"watch","content":"监视【ref】定义的【对象类型】数据，监视的是对象本身的地址值。若想同时监视对象内部属性的变化，需要手动开启深度监视\n12345678910111213141516171819202122232425&lt;script setup lang=&quot;ts&quot;&gt;import &#123; ref, watch &#125; from &#x27;vue&#x27;let sum = ref(&#123;  name: &#x27;Jack&#x27;,  age: 1&#125;)function changeSum() &#123;  sum.value.age += 1&#125;// watch的第一个参数是：被监视的数据// watch的第二个参数是：监视的回调// watch的第三个参数是：配置对象（deep、immediate等等.....）// watch会返回一个函数，调用它可以停止监视const stopWatch = watch(sum, (newValue, oldValue) =&gt; &#123;  console.log(&#x27;sum is &#x27;, newValue, oldValue)  if (newValue.age == 5) &#123;    stopWatch()  &#125;&#125;, &#123; deep: true &#125;)&lt;/script&gt;\n\n若只想监视 ref 对象内部的属性，监视源需要使用箭头函数表示：​()=&gt;sum.value.name​\n123watch(()=&gt;sum.value.name, (newValue, oldValue) =&gt; &#123;  console.log(&#x27;sum is &#x27;, newValue, oldValue)&#125;,&#123;deep:true&#125;)\n\nwatchEffect()无需指明要监视的目标，它会在创建后自动立即调用一次，然后在依赖的目标发生变化时再次调用\n","slug":"杂学/前端/vue/watch","date":"2024-10-12T01:36:55.691Z","categories_index":"vue","tags_index":"技术","author_index":"upstreamboat"},{"id":"e33431be245779e6f5982b9899cac3e4","title":"computed","content":"computed 仅被调用一次。只有当依赖的对象值（即 name、age 的值）发生变化时，才会被再次调用\ncomputed 的返回对象是响应式的\ncomputed 中如果未写有 set()，那么返回对象是只读的\n123456789101112131415161718192021222324252627282930&lt;script setup lang=&quot;ts&quot;&gt;import &#123; computed, ref, toRefs &#125; from &#x27;vue&#x27;let name = ref&lt;string&gt;(&#x27;Jack&#x27;)let age = ref&lt;string&gt;(&#x27;18&#x27;)// nameAge是只读的let nameAge = computed(() =&gt; name.value + age.value)// ageName是可读写的。对ageName的写相当于调用set()let ageName = computed(  &#123;    get() &#123;      return name.value + age.value    &#125;,    set(value) &#123;      const [a,b] = value.split(&quot;_&quot;)      name.value = a      age.value = b    &#125;  &#125;)function changeAgeName()&#123;  ageName.value = &quot;mary_wan&quot;&#125;changeAgeName()&lt;/script&gt;\n","slug":"杂学/前端/vue/computed","date":"2024-10-12T01:34:36.501Z","categories_index":"vue","tags_index":"技术","author_index":"upstreamboat"},{"id":"2ead5051c6ad6150608e700970fcc635","title":"标签ref、$refs、$parent","content":"注意：标签 ref 和 ref()是两种完全不同的东西\n\n放在普通标签上，获取的是整个 DOM 元素\n 1234567891011&lt;template&gt;  &lt;h1 ref=&quot;fuck&quot;&gt; 你好！ &lt;/h1&gt;  &lt;button @click=&quot;showFuck&quot;&gt;click&lt;/button&gt;&lt;/template&gt;&lt;script setup lang=&quot;ts&quot;&gt;let fuck = 0function showFuck() &#123;  console.log(fuck)   // 输出结果：&lt;h1&gt; 你好！ &lt;/h1&gt;&#125;&lt;/script&gt;\n\n放在组件上，获取的是组件实例\n\n变量默认都是私有的，如果一个文件的变量会被外部使用，需要使用 defineExpose()暴露\n\n\n\n\n\n\n\n\n\n\ndefineExpose()相当于把权限 priveate 提升为 public\n 123456// Person.vue&lt;script setup lang=&quot;ts&quot;&gt;let a = 0let b = 1defineExpose(&#123;a,b&#125;)&lt;/script&gt;\n\n 1234567891011// App.vue&lt;script setup lang=&quot;ts&quot;&gt;import Person from &#x27;@/components/Person.vue&#x27;import &#123; ref &#125; from &#x27;vue&#x27;let fuck = ref() // 这里需要定义成ref()对象，否则无法获取a、bfunction showFuck() &#123;  console.log(fuck.value)   // 结果：Proxy(object)&#123;a:0,b:1,__v_skip:true&#125;  console.log(fuck.value.a)   // 结果：0  console.log(fuck.value.b)   // 结果：1&#125;&lt;/script&gt;\n\n\n$refs：获取所有的子组件实例。单个实例直接调用 A1 即可，如要同时获取 A1、A2，可用$refs\n\n 12345678910111213141516// A.vue&lt;template&gt;  &lt;A_1 ref=&quot;A1&quot;  &lt;A_2 ref=&quot;A2&quot; /&gt;`  &lt;button @click=&quot;getSon($refs)&quot;&gt;A click&lt;/button&gt;`&lt;/template&gt;&lt;script&gt;let A1 = ref()let A2 = ref()function getSon(refs) &#123;  for (let refsKey in refs) &#123;    console.log(refs[refsKey])  &#125;&#125;&lt;/script&gt;\n\n\n$parent：获取父组件实例\n\n 12345678910// A_1.vue&lt;script&gt;function getParent(parent:any)&#123;    console.log(parent)&#125;&lt;/script&gt;&lt;template&gt;    &lt;button @click=&quot;getParent($parent)&quot;&gt;A_1 click&lt;/button&gt;&lt;/template&gt;\n\n","slug":"杂学/前端/vue/标签ref、$refs、$parent","date":"2024-10-12T01:21:31.227Z","categories_index":"vue","tags_index":"技术","author_index":"upstreamboat"},{"id":"e094460162e9e8b73de67cb4bbb648b6","title":"ref、reactive","content":"\nref、reactive：创建响应式数据ref：创建基本类型、对象类型（需要.value 取属性）reactive：创建对象类型。注意：重新分配新对象会失去响应式（即无法对 reactive 对象重新整体赋值，可以用 Object.assin()解决）。\n\ntoRefs：响应式对象解构赋值会丢失响应式，需要使用 toRefs(对象)来保持响应式。使用 toRefs 后，解构出的变量值变化时，原对象的值也会跟着变化\n\n整体修改对比：\n 12345// ref 对象整体修改，会产生新对象，地址发生了变化sum.value = &#123;name:&#x27;mary&#x27;,age:2&#125;// reactive 对象整体修改，不会产生新对象，地址未变化Object.assign(sum, &#123;name:&#x27;mary&#x27;,age:2&#125;)\n\n","slug":"杂学/前端/vue/ref、reactive","date":"2024-10-12T01:18:17.533Z","categories_index":"vue","tags_index":"技术","author_index":"upstreamboat"},{"id":"9701f09663d792796faf13208f2a6b15","title":"vue总览","content":"\n\n\n指令\n描述\n\n\n\nv-bind\n用于将 Vue 实例的数据绑定到 HTML 元素的属性上。总结：绑定 对象 到 元素属性 上，就是指数据流向页面。格式：v-bind:属性名。简写：:属性名注意：没有属性名称的 v-bind 会将一个对象的所有属性都作为 attribute 应用到目标元素上。\n\n\nv-if\n用于根据表达式的值来条件性地渲染元素或组件。总结：条件触发。格式：v-if&#x3D;”布尔值”\n\n\nv-show\nv-show 是 Vue.js 提供的一种指令，用于根据表达式的值来条件性地显示或隐藏元素。总结：是否显示元素。格式：v-show&#x3D;”布尔值”\n\n\nv-for\n用于根据数组或对象的属性值来循环渲染元素或组件。总结：循环。格式：v-for&#x3D;”value in 数组&#x2F;对象&#x2F;数值”，数值的话会是循环次数。\n\n\nv-on\n用于在 HTML 元素上绑定事件监听器，使其能够触发 Vue 实例中的方法或函数。总结：监听 元素事件。格式：v-on:事件名。简写：@事件名\n\n\nv-model\n用于在表单控件和 Vue 实例的数据之间创建双向数据绑定。总结：双向绑定，用于 input、select、checkbox 等元素，元素内容 改变 对象内容 也改变。\n\n\nv-if 和 v-show 的区别\ndirective自定义指令\n在 &lt;script setup&gt; 中，任何以 v 开头的驼峰式命名的变量都可以被用作一个自定义指令。比如 vFocus 即可以在模板中以 v-focus 的形式使用。\n\n\n\n\n\n\n\n\n\n注册 (功能指令)： app.directive(&#39;focus&#39;, () =&gt; &#123;&#125;)\n不推荐在组件上使用自定义指令。\nref、reactive创建响应式数据\nref：创建基本类型、对象类型（需要.value 取属性）reactive：创建对象类型。注意：重新分配新对象会失去响应式（即无法对 reactive 对象重新整体赋值，可以用 Object.assin()解决）。toRefs：从响应式对象解构属性会丢失响应式，需要使用 toRefs(对象)来保持响应式。\n\n\n\n\n\n\n\n\n\n使用 toRefs 后，解构出的变量值变化时，原对象的值也会跟着变化\ncomputed计算属性。和普通的方法相比，computer()具有缓存，只有在依赖的属性变化时才会重新计算，否则每次调用都是返回之前计算的值，不会重新计算。\nwatch监听目标变化时，触发动作。监听目标可以是 基本类型、对象类型、对象类型的属性（通过箭头函数实现）、相关数组。\n监听 ref 对象时，不会监听对象的属性，需要手动开启深度监听；但监听 reactive 对象时，自动隐式地开启了深度监听。\n_watchEffect_：自动识别监听目标。\n标签 ref放在 HTML 标签上，取到的就是 DOM 元素。\n放在某个组件标签上，取到的就是该组件的实例对象。但是想要读取该实例对象的属性，需要该组件用 defineExpose 交出相关属性。\nroute\n路由占位，路由组件将被展示在这里：\n\n路由实例：\n  1234567891011121314const routes = [&#123;    path: &#x27;/&#x27;,    name: &#x27;Home&#x27;,    redirect: /home,    // component：    component: Home // 组件写法1：Home是一个组件    component: () =&gt; import(&#x27;@/view/Home.vue&#x27;) // 组件写法2    // 设置参数：    params: &#123;&#125; // 路径参数。注意：无法通过path跳转，需要通过name跳转    query: &#123;&#125; // 查询参数    // 传递参数：注意：使用了props后，需要在接收处使用defineProps()接收。如：Home.vue中代码：defineProps([参数1，参数2])    props: true // 只能用于传params的参数    props(route)&#123;return route.query&#125; // 可以传query或者param（需要route.params）的参数&#125;,&#123;&#125;]\n\n路由导航：\n\n方式一：标签 route-link：\n\n  123&lt;route-link to=&quot;路径&quot;&gt;&lt;route-link :to=&quot;&#123;path:&#x27;路径&#x27;,name:&#x27;名字&#x27;,params:&#123;&#125;&#125;&quot;&gt;&lt;route-link :to=&quot;&#123;path:&#x27;路径&#x27;,name:&#x27;名字&#x27;,query:&#123;&#125;&#125;&quot;&gt;\n\n\n方式二：编程式路由导航：router.push(“路由内容”) &#x2F;&#x2F; 这个路由内容和 to 的内容写法相同replace 无历史记录，push 有历史记录\n\n\nuseRoute、useRouter、createRouter  useRoute：在组件中获取当前路由信息，如获取路径、名称等。  useRouter：获取路由实例，包含路由信息和动态操作，如 router.push(“&#x2F;“)：跳转到根路径  createRouter：创建路由器，存放路由\n  12345// index.js 代码export const router = createRouter(&#123;\thistory: createWebHashHistory(),\troutes,&#125;)\n\n  123// APP.vue 代码import router from &#x27;@/router/index&#x27;app.use(router)\n\n导航守卫  参见\n  12345router.beforeEach((to, from) =&gt; &#123; // to: 即将要进入的目标，from: 当前导航正要离开的路由  // ...  // 返回 false 以取消导航  return false&#125;)\n\nhooks也叫组合式函数，类似于 java 中的封装类，将同类事物封装在一个类中，命名规则：useXxx\nhooks 中的 mouse.js 代码：export function useMouse() &#123; return &#123; 变量 &#125; &#125;\n调用处的代码：const &#123;变量&#125; = useMouse()\npinia集中式状态管理，管理组件间共享数据。其实也是封装，封装全局变量。\n\npinia 仓库 store.ts 中的代码：\n 1234567891011export const usestoreName = defineStore(&quot;storeName&quot;,&#123; //storeName其实用不到\tstate()&#123;return &#123;sum:2&#125;&#125;,\tactions:&#123;updateSum(value)&#123;this.sum+=1&#125;&#125;, // 第三种修改方式，需要在使用处调用updateSum\tgetters:&#123;fun1(state)&#123;return state.sum+1&#125;&#125; // getters与actions相比，是用来获取一些计算后的值&#125;)export const usestoreName = defineStore(&quot;storeName&quot;,()=&gt;&#123;\tlet sum = ref(2)\tupdateSum(value)&#123;this.sum+=1&#125;\tfun1(state)&#123;return state.sum+1&#125;&#125;)\n\n使用处的代码：\n 123456789const myStore = usestoreName()const &#123;mySum&#125; = storeToRefs(myStore)  //如果不用storeToRefs，取出的mySum会丢失响应式。或者干脆直接通过myStore.sum使用myStore.sum = 9  // 第一种修改方式，直接修改myStore.$patch(&#123;sum:9&#125;)  // 第二种修改方式，借助$patch批量修改// $subsrcibe：类似watchmyStore.$subsrcibe((mutate,state)=&gt;&#123;  //mutate是本次修改的信息，state是修改后的state\tconsole.log(mutate,state)&#125;)\n\n组件通信\ndefineProps：接收父组件传来的属性。父传子模式。\n父组件传输属性：（属性值可以是任意类型）\n1&lt;SonComponent :some-attr=&quot;var1&quot; /&gt;\n\n子组件接收属性：（参数可以是数组或对象）\n12const myProps = defineProps([&quot;some-attr&quot;])&lt;p&gt;&#123;&#123; myProps.someAttr &#125;&#125;&lt;/p&gt; // some-attr被自动转换成了someAttr，可以打印myProp对象看出来。\n\ndefineEmits 和$emit：自定义事件，可用于父子组件通信。\n父组件监听事件：（事件名是 some-event，该事件要做的是调用 callback 函数）\n1&lt;SonComponent @some-event=&quot;callback&quot; /&gt;\n\n子组件触发事件：\n\ndefineEmits 方式：（与 defineProps 类似）\n\n12&lt;script setup&gt;const myEmits = defineEmits([&#x27;some-event&#x27;])&lt;/script&gt;&lt;button @click=&quot;myEmits(&#x27;someEvent&#x27;)&quot;&gt;click me&lt;/button&gt;\n\n\n$emit 方式：\n\n1&lt;button @click=&quot;$emit(&#x27;someEvent&#x27;)&quot;&gt;click me&lt;/button&gt; // $emit 只能在 DOM 中使用，无法在 script 中使用``&lt;button @click=&quot;$emit(&#x27;someEvent&#x27;)&quot;&gt;click me&lt;/button&gt; // $emit 只能在 DOM 中使用，无法在 script 中使用\n\ndefineModel：（组件标签上使用 v-model）\n​ 父组件代码：\n12const msg = ref(&#x27;Hello World!&#x27;)&lt;SonComponent v-model=&quot;msg&quot; /&gt;\n\n子组件代码：\n12const myModel = defineModel()&lt;input v-model=&quot;myModel&quot;&gt; // 效果：子组件输入框中内容与父组件中的msg变量双向绑定，一改具改\n\nmitt：第三方自定义事件库\n12345678// 创建mitt：export const emitter = mitt() // 比如：在A.js中创建mitt实例// 监听mitt：emitter.on(&quot;事件名&quot;,(参数)=&gt;&#123; // 要做的事 &#125;) // 比如：然后在B.vue中监听事件，需要先导入mitt实例// 触发mitt：emitter.emit(&quot;事件名&quot;,参数) // 比如：最后在C.vue中触发事件（可以通过@click），需要先导入mitt实例\n\n$attrs：透传，未被接收的属性和事件会被渗透下传，获取方式：$attrs[&quot;属性名&quot;]、$attrs.事件名可以实现祖传孙模式：父传子，子不使用，继续传给孙，孙获取。\n\n$refs（子传父）、$parent（父传子）\n\n依赖注入：祖先和后代（包括子、孙、重孙等）进行通信；非后代无法通信。\n祖组件代码：provide（祖先传数据和方法）\n12const count = ref(0)provide(&#x27;key&#x27;, count)\n\n孙组件代码：inject（后代接收数据和方法）\n1const value = inject(&#x27;key&#x27;, &#x27;这是默认值&#x27;)\n\nslot 插槽：组件内部块，可以实现同一块中根据父组件的传入，从而展示不同内容\n\n普通插槽：\n\n\n\n\n\n\n\n\n\n\n父组件代码：\n1&lt;SonComponent&gt; Click me! &lt;!-- 插槽内容 --&gt;&lt;/SonComponent&gt;\n\n\n\n\n\n\n\n\n\n\n子组件代码：\n1&lt;button class=&quot;fancy-btn&quot;&gt; &lt;slot&gt;&lt;!-- 插槽出口 --&gt;&lt;/slot&gt; &lt;/button&gt;\n\n\n具名插槽：\n\n\n\n\n\n\n\n\n\n\n父组件代码：\n123&lt;SonComponent&gt;&lt;p v-slot:slot1&gt;Click me!&lt;/p&gt; // 这里的v-slot:slot1可以简写成#slot1&lt;/SonComponent&gt;\n\n\n\n\n\n\n\n\n\n\n子组件代码：\n1&lt;slot name=&quot;slot1&quot;&gt;&lt;/slot&gt;\n\n作用域插槽：（可以实现子传父模式）数据在子组件里，但如何呈现由父组件决定\n父组件代码：\n123&lt;SonComponent&gt;&lt;template v-slot:slot1=&quot;sonProps&quot;&gt;&#123;&#123;sonProps.aa&#125;&#125; &#123;&#123;sonProps.bb&#125;&#125;&lt;/template&gt;&lt;/SonComponent&gt;\n\n子组件代码：\n1&lt;slot name=&quot;slot1&quot; :aa=&quot;AA&quot; :bb=&quot;2&quot;&gt;&lt;/slot&gt;\n\n组件配置：defineOptions1234defineOptions(&#123;\tinheritAttrs: false, // 禁止透传\tname: &quot;SonComponent&quot; // 自定义组件名&#125;)\n\n命名规则\n组件名：MyName\n\nHTML 标签和属性名：my-name（这里默认是不分大小写的，所以不能使用驼峰模式）\n\nhooks 名：useXxx\n\n事件名：xx-xx\n\n\n","slug":"杂学/前端/vue/vue总览","date":"2024-10-11T08:23:15.184Z","categories_index":"vue","tags_index":"技术","author_index":"upstreamboat"},{"id":"950d57d7686fa56a02652649dfc2569e","title":"网络协议","content":"分层应用层：HTTP：规定数据的格式\n传输层：TCP&#x2F;UDP：添加端口，通过端口找到对方电脑上的程序，一个程序对应一个端口\n网络层：IP：添加 IP 地址，用于不同网络间通信，通过 IP 地址找到对方所在网络\n数据链路层：以太网协议：添加 MAC 地址，每个网卡对应一个 MAC 地址，同一网络间通过 ARP（广播模式工作）协议通信，通过 MAC 找到对方电脑\nip\nip 地址分类：\nA 类：1.0.0.0~127.255.255.255\nB 类：128.0.0.0~191.255.255.255\nC 类：192.0.0.0~223.255.255.255\n\n\n子网掩码：网络地址 + 主机地址\n\n\n\n\n\n\n\n\n子网掩码必须是连续的 1 和连续的 0 构成，不能交叉\n\n网络地址 &#x3D; IP 地址和子网掩码进行与运算 &#x3D; 当主机号全 0 时的 IP 地址\n主机地址 &#x3D; 当网络号全 0 时的 IP 地址\n\n交换机、路由器网关内网、外网\n网络地址：标识网络本身，无法分配给主机。广播地址：发往广播地址的消息会被所有主机接收到。用于向网络内所有主机发送数据，同样无法分配给主机。\n学习参见\n","slug":"杂学/前端/网络协议","date":"2024-10-11T07:57:38.697Z","categories_index":"前端","tags_index":"技术","author_index":"upstreamboat"},{"id":"20b7dcd73538d1ce1a83f9ed9462da12","title":"http1.1与http2.0","content":"参考\n\nhttp1.0：请求前通过 tcp 三次握手建立连接，请求-响应，tcp 四次挥手断开连接。\n  短连接、无状态：过程短，每次请求都是新的连接。  一次 请求+响应 过程结束后，才可以发送下一个请求。\n\nhttp1.1：设置为 keep-alive，可以保持 tcp 持久连接\n  可以发送多个请求，但是响应还是根据请求的先后顺序进行响应，当前一个响应阻塞，后面的响应都会阻塞。\n\nhttp2.0：请求、响应可以乱序，减少了阻塞等待时间\n  服务端可以主动发送消息、资源  1.1 只压缩了 body，而 2.0 还压缩了 header，且数据采用二进制格式  HTTP2 也是明文的，只不过格式是二进制的，但 HTTP2 都是 https 协议的，跑在 TSL 上面\n\nsocket\n  不是协议，而是 api 接口，用于方便地使用 tcp 或 udp 连接。它是传输层和应用层之间抽象出来的一层，隐藏了底层实现细节。\n\nwebsocket\n  是应用层协议，WebSocke 和 HTTP 一样，都是建立在 TCP 之上，通过 TCP 来传输数据。WebSocket 是双向通信协议，HTTP 是单向协议。WebSocke 借助 http 完成握手后，使用 tcp 完成传输。模仿了 socket 的模式，实现了双向通信的功能，故而命名 websocket。\n\n\n","slug":"杂学/前端/http1.1与http2.0","date":"2024-10-11T07:54:33.884Z","categories_index":"前端","tags_index":"技术","author_index":"upstreamboat"},{"id":"28d5962430952168dc1991678a154079","title":"F12详解","content":"\n元素：\n定位：id,name,Xpath（右键某元素-复制-Xpath）例：//input[@name=&quot;identifier&quot;]\n\n网络：\n\n发起者：请求的发起方式和背景\n\n\n\n\n\n\n\n\n\n\nXHR：表示请求是通过 XMLHttpRequest 对象发起的，通常用于 AJAX 请求。\nFetch：表示请求是通过 Fetch API 发起的，这是现代 JavaScript 用于进行网络请求的标准。\nScript：表示请求是由 JavaScript 脚本发起的，通常是脚本加载或动态生成的请求。\nBeacon：表示请求是通过 Beacon API 发起的，通常用于发送小型、非阻塞的请求，通常用于分析或日志记录。\nOther：表示请求的类型不属于上述类别，可能是浏览器的其他内部请求或未归类的请求。\n\n\n类型：识别不同的资源和请求的性质\n\n\n\n\n\n\n\n\n\n\nDocument：请求的是网页文档，例如 HTML 文件。\nScript：请求的是 JavaScript 文件。\nStylesheet：请求的是 CSS 样式表文件。\nImage：请求的是图像文件，如 PNG、JPEG 等。\nXHR：请求的是通过 XMLHttpRequest 对象发起的 AJAX 请求。\nFetch：请求的是通过 Fetch API 发起的网络请求。\nFont：请求的是字体文件。\nMedia：请求的是音频或视频文件。\nplain：text&#x2F;plain，纯文本文件\nOther：其他类型的请求，不属于上述类别，可能是浏览器内部或特殊的请求。\n\n\n传输：传输指的是网络请求和响应在实际传输过程中所使用的数据量。有一种可能是：响应头+响应体的大小\n\n大小：响应体的大小\n\n\n\n\n","slug":"杂学/前端/F12详解","date":"2024-10-11T07:46:58.649Z","categories_index":"前端","tags_index":"技术","author_index":"upstreamboat"},{"id":"0726a6e1355297f3b351bff13d2e7663","title":"undefined、null","content":"undefined基本类型，表示变量已声明但未赋值、或对象的属性不存在\n123456// 自动赋值为 undefinedlet a;console.log(a);let a = &#123;name:3&#125;;console.log(a.age);// 没有返回值的函数返回的也是 undefinedfunction name(params) &#123;&#125;；console.log(name())；\n\nnull对象类型，表示变量已赋值，值就是空\n12// 手动赋值为 nulllet a =null;console.log(a)\n","slug":"杂学/前端/undefined、null","date":"2024-10-11T07:45:00.339Z","categories_index":"前端","tags_index":"技术","author_index":"upstreamboat"},{"id":"36e5890aed92c11d2d4ce54bc8178724","title":"跨域解决","content":"是什么因为浏览器的同源策略（同协议、ip、port 为同源），导致不同域名不能相互访问。\n\n法一：vue 使用代理解决\n\n1234567891011// vite.config.tsserver: &#123;    host: &#x27;0.0.0.0&#x27;,    proxy: &#123;      &#x27;/api&#x27;: &#123; // 拦截所有/api开头的请求        target: &quot; [http://localhost:8088](http://localhost:8088)&quot;,  // 转发到该地址        changeOrigin: true, // 允许跨域        rewrite: path =&gt; path.replace(/^\\/api/,&#x27;&#x27;), // 去除/api      &#125;    &#125;&#125;\n\n\n法二：后端使用 cors 库解决\n\n12345678910111213141516//  cors.gopackage middlewareimport (\t&quot;github.com/gin-contrib/cors&quot;\t&quot;github.com/gin-gonic/gin&quot;)func Cors() gin.HandlerFunc &#123;\tconfig := cors.DefaultConfig()\tconfig.AllowAllOrigins = true\tconfig.AllowHeaders = []string&#123;&quot;Origin&quot;, &quot;Content-Length&quot;, &quot;Content-Type&quot;, &quot;Authorization&quot;&#125;\tconfig.AllowCredentials = true\tconfig.ExposeHeaders = []string&#123;&quot;New-Token&quot;, &quot;New-Expires-In&quot;, &quot;Content-Disposition&quot;&#125;\treturn cors.New(config)&#125;\n\n12// router.gorouter.Use(middleware.Cors()) // 启用cors中间件\n\n\n法三：nginx 在 location 内配置 header 解决\n\n12// nginx.confadd_header &#x27;Access-Control-Allow-Origin&#x27; &#x27;*&#x27;;\n","slug":"杂学/前端/跨域解决","date":"2024-10-11T07:39:13.117Z","categories_index":"前端","tags_index":"技术","author_index":"upstreamboat"},{"id":"33876cf3e210da358d8e4b065eea88e6","title":"axios","content":"\n代码\n\n123456789101112131415161718192021222324252627282930313233343536373839async function getOne() &#123;  try &#123;    result.value = await axios.get(&#x27;/api/test&#x27;)    console.log(&quot;one&quot;,result.value.data)  &#125; catch (err) &#123;    alert(err)  &#125;&#125;getOne()console.log(&quot;getPing down&quot;)function getTwo() &#123;  try &#123;    result.value = axios.get(&#x27;/api/test&#x27;)    console.log(&quot;two&quot;,result.value.data)  &#125; catch (err) &#123;    alert(err)  &#125;&#125;getTwo()console.log(&quot;getTest down&quot;)\n\n\n结果getPing downtwo undefinedgetTest downone success\n\n解析抛开两个方法的声明，程序其实只有 4 步：\n\n\n\n\n\n\n\n\n\ngetOne()：console.log(&quot;one&quot;,result.value.data)\nconsole.log(&quot;getPing down&quot;)\ngetTwo()：console.log(&quot;two&quot;,result.value.data)\nconsole.log(&quot;getTest down&quot;)\n getOne()中的 axios.get 是 await 的，所以会等待响应才能执行 console.log(“one”,result.value.data)，注意此时它还没有执行， getOne()是 async 异步的，所以可以继续向下执行 console.log(“getPing down”)， getTwo()会立即执行，打印 console.log(“two”,result.value.data)， getTwo()执行完后，会执行 console.log(“getTest down”)，\n 都执行完后，此时 getOne()中的 await 得到响应，开始执行 console.log(“one”,result.value.data)\n\n\n","slug":"杂学/前端/axios","date":"2024-10-11T07:34:32.394Z","categories_index":"前端","tags_index":"技术","author_index":"upstreamboat"},{"id":"9d99a147db531cdfb1c6d31da0274ed8","title":"var、let、const","content":"var、let、const\nvar 变量的声明提升：JS 引擎的工作方式是，先解析代码，获取所有被声明的变量、函数，然后再一行一行地运行。这造成的结果，就是所有的变量、函数的声明语句，都会被提升到代码的开始，这就叫做变量提升（hoisting）。\n变量：会声明提升，但不会赋值，仅表示有了该变量，提前调用值为 undenfined；\n函数：会声明提升，可以提前调用；（但如果是函数表达式，则不会提升，如：var x &#x3D; function(){};）\n类：不会声明提升。&#x2F;&#x2F; ES6 中的 let、const 的声明不提升。\n\n\n\n12345678910111213console.log(a);var a = 1;// 相当于：var a;console.log(a);a = 1// 最后的结果是显示 undefined，表示变量 a 已声明，但还未赋值\n\n\nvar、let、const\nvar：函数级作用域。会声明提升\nlet：块级作用域。不会声明提升\nconst：引用不可改。数组、对象的值是可以改的，但不可重新整体赋值。必须初始化。不会声明提升\n\n\n\n","slug":"杂学/前端/var、let、const","date":"2024-10-11T07:31:46.195Z","categories_index":"前端","tags_index":"技术","author_index":"upstreamboat"},{"id":"f5f2db0c17107814c4314469b669d76d","title":"export default","content":"\n错误：export default a 的含义是将变量 a 的值赋给变量 default 并导出，所以它后面不能跟变量声明语句\n1export default var a = 1;\n\n正确\n12var a = 1;export default a;\n\n正确\n12export default function &#123;&#125;export default function foo() &#123;&#125; // 这两种写法是等价的，虽然方法有名，但该名无效\n\n导入\n1import xxx from &quot;modules&quot;;\n\nexport default和 export 的区别\n\nexport default 不可以跟变量声明，但 export 可以\nexport default 最多只能有一个\nexport default 可以任意名称接收，如 import xxx from ‘modules’；但 export 不可以，如 import {a} from ‘modules’\n\n\n\n","slug":"杂学/前端/export default","date":"2024-10-11T07:28:40.922Z","categories_index":"前端","tags_index":"技术","author_index":"upstreamboat"},{"id":"4ac06be8c7a43e5fa8c5ae374f435567","title":"泛型","content":"定义泛型1234567export interface PersonConstraint &#123;  name: string  age?: number // 加上?表示可有可无&#125;export type PersonConstraints = Array&lt;PersonConstraint&gt;;// 等价于 export type PersonConstraints = PersonConstraint[];\n\n使用泛型123456let human: PersonConstraint = &#123; name: &quot;mary&quot;, age: 18 &#125;;let humanList: PersonConstraints = [\t&#123; name: &quot;mary&quot;, age: 18 &#125;,\t&#123; name: &quot;Jack&quot; &#125;,];\n","slug":"杂学/前端/泛型","date":"2024-10-11T07:27:20.463Z","categories_index":"前端","tags_index":"技术","author_index":"upstreamboat"},{"id":"de437e3b87251a9e707b457d80555637","title":"RestFul API","content":"\nGET：表示读取服务器上的资源\n\nPOST：表示在服务器上创建资源\n\nPUT：表示更新或者替换服务器上的资源\n\nDELETE：表示删除服务器上的资源\n\nPATCH：表示更新&#x2F;修改资源的一部分\n\n\n","slug":"杂学/前端/RestFul API","date":"2024-10-11T07:26:45.280Z","categories_index":"前端","tags_index":"技术","author_index":"upstreamboat"},{"id":"3a8e6e63fbdd2def11226ba33e387dd4","title":"网址定位符","content":"URL 中的#号#代表网页中的一个位置。其右面的字符，就是该位置的标识符。比如，http://www.example.com/index.html#print就代表网页 index.html 的 print 位置。浏览器读取这个 URL 后，会自动将 print 位置滚动至可视区域。\n","slug":"杂学/前端/网址定位符","date":"2024-10-11T07:23:52.862Z","categories_index":"前端","tags_index":"技术","author_index":"upstreamboat"},{"id":"396698571969c3ca7a979dd58d29292b","title":"Cookie、Session、Token","content":"区别cookiecookie 是载体，是一种存储方式，物理表现为一种浏览器端保存的小文本文件。\n\n可以存储在内存中，随着浏览器的关闭而消失；也可以存储在硬盘中，关闭再打开浏览器，cookie 依然有效\n浏览器存储信息方式除了 cookie，还有 local storage 等（按 F12-&gt;应用程序）。\n访问网站时，请求会携带该网站的 cookie；不同网站会有不同的 cookie；同一网站的 cookie 会被后登录的用户覆盖。\n\nsession、tokensession、token 是保存用户信息的字符串。如保存：id、用户名、字体设置、搜索记录、购物车等信息session、token 的作用： ​ 验证用户是否登录、以及区别不同用户 ​ 。（而不是用来认证用户账密是否正确的）\n\n\n\n\n\n\n\n\n\ntxt例如 1：用户的 session、token 能被正确处理，则说明用户已登录，无需再次登录；\n例如 2：之前是张三登录，现在发现登录者是李四，便会将 session 更新为李四的信息。\n\nsession\nsession_id 是区别不同 session 的唯一标识。\n一般浏览器关闭，session 便会消失，但可以通过设置存活时间使得再次打开仍使用上次 session。session 消失意味着内存或数据库中的信息便会清楚。\n\n\ntoken\nToken 是字符串，是自定义的，没有统一结构；JWT 是一个规范，定义了 Token 的结构和生成方式 。（JWT 看似加密，实则是明文）\n签名是通过加密算法+密钥的方式形成的，密钥是每个服务器独有的\n\n\n\n存储位置\n\n\n\nbrowser\nsever\n\n\n\ncookie\ncookie（用户 id、用户名、喜好）\n\n\n\nsession\ncookie（session_id）\n{session_id:”用户 id、用户名、喜好”}\n\n\ntoken\ncookie（token{用户 id、签名}）\n\n\n\n请求过程当用户注册，账密保存在数据库中后，\n\ncookie(id 字符串)\n\n服务器返回 id 字符串 给浏览器，浏览将其保存到 cookie 中；\n访问网站，请求携带 cookie；\n服务器检测到 cookie 存在，便知用户已登录，cookie 中的 id 字符串可知用户是谁。\n\n  缺点：信息不安全；当 cookie 中信息越来越多，请求传输时负担越大\n\ncookie(session_id)\n\n服务器将 session 保存在内存（或 DB、文件）中，用 session_id 做主键；\n服务器返回 session_id 给浏览器，浏览将其保存到 cookie 中；\n访问网站，请求携带 cookie；\n服务器拿到 session_id 在 session 表中查找，能找到便知用户已登录，session 对应信息可知用户是谁。\n\n  缺点：\n\n\n当有 1 亿用户访问 B 站，B 站服务器便需要存储 1 亿个 session；\n当 B 站服务器使用集群时，不同服务器间需要共享 session 才行，否则请求过来其它服务器不识别该用户。（可以用 session 复制或 redis 集群来解决。但还是麻烦了些）\n\n\ncookie(token)\n\n服务器返回 token 给浏览器，浏览将其保存到 cookie 中；\n访问网站，请求携带 cookie；\n服务器校验 token 签名正确，便知用户已登录，token 中的信息可知用户是谁。\n\n  缺点：token 是很长的字符串，对请求也有负担\n\n\n请求过程解释上面所谓的 id 字符串、session、token 其实都是同一类东西，都是用来区别用户的字符串。它们可以依赖 cookie 来传输，也可以放在请求的 body、head 甚至 url 中，只要服务端能正确取出来就行。\n\n\n\n\n\n\n\n\n\n如果要跨域，便不能用 cookie，因为 cookie 是每个网站独有的。\n\n例如：token 一般存储在 local_storage，传输时在 head 中的 Authorization 字段。\n\n关于历史记录、购物车等信息购物车、搜索记录等数据一般存储在 DB 中。虽然也可以存储在 cookie 中，但有三个问题：\n\ncookie 容量小，保存的信息有限；\n切换不同浏览器，会因为没有之前浏览器的 cookie，导致查询不到记录；\n而且 cookie 到期或关闭浏览器后购物车会丢失（cookie 也可以写入硬盘，所以如果是一直用本机浏览器，而且记录数不多的话，也可以用 cookie 存）。\n\n","slug":"杂学/前端/Cookie、Session、Token","date":"2024-10-11T07:13:07.614Z","categories_index":"前端","tags_index":"技术","author_index":"upstreamboat"},{"id":"356790b52760809f94d4f6255c517b3b","title":"localStorage","content":"localStorage将信息存放在本地存储，可以实现关闭浏览器不清理记录。\n操作：\n\n将存放对象的数组打印成字符串：const arrObj = [&#123;对象 1&#125;，&#123;对象 2&#125;] JSON.stringify(arrObj)\n将字符串保存在本地存储中：localStorage.setItem(&quot;objList&quot;,JSON.stringify(arrObj))\n从本地存储中获取信息：JSON.pase(localStorage.getItem(&quot;objList&quot;) as string) | []&#x2F;&#x2F; as string：断言，表明是字符串&#x2F;&#x2F; || []：为什么加“或一个空数组”，因为可能获取不到信息，会是个 null 值\n\n","slug":"杂学/前端/localStorage","date":"2024-10-11T07:09:37.370Z","categories_index":"前端","tags_index":"技术","author_index":"upstreamboat"},{"id":"7a3407ec8ba34c20be717a58f2bd7ba0","title":"JS+ES6+TS","content":"\nES 是语言标准，包含许多语法；JS 遵守这种标准，并且额外有对 DOM 的操作；TS 包含 JS，并且添加了类型检查等特性。\nDOM（文档对象模型）：当网页被加载时，浏览器会创建页面的文档对象模型（Document Object Model），通过它可访问 HTML 文档的所有元素。\n作用：可以使 JS 操作 html。参考\nHTML DOM 对象如： HTML 元素, HTML 文档, window 对象、xmlHttpRequest 对象。\n实例：通过 id 找到 HTML 元素：document.getElementById()通过标签名找到 HTML 元素：document.getElementsByTagName()通过类名找到 HTML 元素：document.getElementsByClassName()\n\n\nvue-cli：vue 项目脚手架，用于创建项目目录等npm：是 Node 的模块管理系统，用于 Node.js 包的发布、传播、依赖控制Node.js：js 运行环境\n关键字：arguments、break、case、catch、class、const、continue、debugger、default、delete、do、else、enum、eval、export、extends、false、finally、for、function、if、implements、import、in、instanceof、interface、let、new、null、package、private、protected、public、return、static、super、switch、this、throw、true、try、typeof、var、void、while、with、yield\nswitch 语句后面的表达式，与 case 语句后面的表示式比较运行结果时，采用的是严格相等运算符===，而不是相等运算符==，这意味着比较时不会发生类型转换。\n\n\n\n\n\n\n\n\n===：严格相等，数据类型和值都相等。\n\nisNaN 只对数值有效，如果传入其他值，会被先转成数值（字符串、数组、对象都会先被转成数值）。\n\n\n\n\n\n\n\n\n比如，传入字符串的时候，字符串会被先转成 NaN，所以最后返回 true，这一点要特别引起注意。也就是说，isNaN 为 true 的值，有可能不是 NaN，而是一个字符串\n\n闭包：JavaScript 中的闭包特性允许内部函数访问外部函数的局部变量。\nJavaScript 的隐式参数是值传递。\n输出数据的方式：window.alert()：弹出警告框。document.write()：方法将内容写到 HTML 文档中。innerHTML：写入到 HTML 元素。console.log()：写入到浏览器的控制台\n数据类型：值类型(基本类型)：字符串（String）、数字(Number)、布尔(Boolean)、空（Null）、未定义（Undefined）、Symbol。引用数据类型（对象类型）：对象(Object)、数组(Array)、函数(Function)，还有两个特殊的对象：正则（RegExp）和日期（Date）\n常用事件：\n\n\n\n\nonchange\nHTML 元素改变\n\n\n\nonclick\n用户点击 HTML 元素\n\n\nonmouseover\n鼠标指针移动到指定的元素上时发生\n\n\nonmouseout\n用户从一个 HTML 元素上移开鼠标时发生\n\n\nonkeydown\n用户按下键盘按键\n\n\nonload\n浏览器已完成页面的加载\n\n\nonunload\n离开页面时被触发\n\n\nonmousedown\n点击鼠标按钮触发\n\n\nonmouseup\n释放鼠标按钮触发\n\n\n\nvoid 关键字：仅计算表达式但是不返回值。\n\n异步函数 async function 中可以使用 await 指令，await 指令后必须跟着一个 Promise\n123456789101112async function asyncFunc() &#123;\ttry &#123;\t\tawait new Promise(function (resolve, reject) &#123;\t\t\tthrow &quot;Some error&quot;; // 或者 reject(&quot;Some error&quot;)\t\t&#125;);\t&#125; catch (err) &#123;\t\tconsole.log(err);\t\t// 会输出 Some error\t&#125;&#125;asyncFunc();\n\naddEventListener()：添加事件监听element.addEventListener(event, function, useCapture);\n\n第一个参数是事件的类型 (如 “click” 或 “mousedown”)\n第二个参数是事件触发后调用的函数\n第三个参数是个布尔值用于描述事件是冒泡还是捕获。该参数是可选的\n冒泡：内部元素的事件会先被触发，然后再触发外部元素\n捕获：外部元素的事件会先被触发，然后才会触发内部元素的事件\n\n\n\n\n解构赋值：就是将数组或对象拆解后赋值。\n\n对象：let &#123; foo, bar &#125; = &#123; foo: &#39;aaa&#39;, bar: &#39;bbb&#39; &#125;;\n\n\n\n\n\n\n\n\n等价于：let &#123; foo: foo, bar: bar &#125; = &#123; foo: &#39;aaa&#39;, bar: &#39;bbb&#39; &#125;;  &#x2F;&#x2F;第一个 foo 是匹配模式，第二个 foo 才是变量名，真正被赋值的是变量，而不是模式。\n\n数组 也是一种特殊对象。  数组：let [a, b, c] = [1, 2, 3];\n字符串 解构时会转换成一种类似数组的对象。  字符串：const [a, b, c, d, e] = &#39;hello&#39;;\n数值和布尔值 解构时会转换成对象。  数值：let &#123;toString: s&#125; = 123;  布尔值：let &#123;toString: s&#125; = true;\n\n\n函数的 length 属性，将返回没有指定默认值的参数个数，且不包括 rest 参数。\n\n箭头函数的 this 绑定定义时所在的作用域；普通函数的 this 指向运行时所在的作用域。\n\n尾调用：一个函数的最后一步，执行另一个函数（可以调用自身，称为尾递归）。注意：最后一步执行的函数不可以参与任何运算，只能是调用而已。\n\n扩展运算符...的作用：\n\n用于数组：...将一个数组转为用逗号分隔的参数序列\n用于对象：...用于取出 参数对象 所有 可遍历属性 然后拷贝到当前对象\n用于函数：...将一个数组，变为参数序列\n\n\n箭头函数：箭头函数内部无法使用 this\n\n相同写法：无参\ngetVar()&#123;return var1&#125;\ngetVar:()=&gt; var1\n\n\n相同写法：有参\nsetVar(newValue)&#123;var1 = 1&#125;\nsetVar:newValue =&gt; &#123;var1 = 1&#125;\nsetVar:(newValue) =&gt; &#123;var1 = 1&#125;\n\n\n\n\n类型声明：冒号 + 类型，可以用来声明变量、参数、返回值。\n123function toString(num: number): string &#123;\treturn String(num);&#125;\n\n泛型：在定义函数时，不决定函数的参数类型，而是让调用者以参数的形式告知，函数的参数应该是什么样的类型。\n123function identity&lt;Type&gt;(arg: Type): Type &#123;\treturn arg;&#125;\n\n","slug":"杂学/前端/JS+ES6+TS","date":"2024-10-11T06:05:48.942Z","categories_index":"前端","tags_index":"技术","author_index":"upstreamboat"},{"id":"7b15f460606fcb4d23e6a93344af8c37","title":"算法","content":"排序下面 3 个平均时间复杂度：O(n^2)\n\n\n\n\n\n\n\n\n\n冒泡：相邻两两交换选择：当前元素与后面所有元素比较，选择出最小值后交换位置插入：当前元素与前面所有元素比较，插入到合适位置。（即：把后面元素插入到前面）\n希尔的平均时间复杂度：O(n^1.3)\n\n\n\n\n\n\n\n\n\n希尔：将数组分成 n（n&#x3D;len&#x2F;2）组，组内进行插入排序；重复：将数组分成 n&#x3D;n&#x2F;2 组，组内插入排序…直到 n&#x3D;1…再对数组整体插入排序一次。\n\n\n为什么不直接用插入排序：因为多次分组后，数组越来越有序，每次插入排序的效率越来越高。当数据量大时，元素交换次数更少。\n希尔排序是插入排序的一种扩展。\n\n\n下面 2 个平均时间复杂度：O(nlog n)\n\n\n\n\n\n\n\n\n\n快速：随机选择一个元素作为参照，比它小的移到它的左边，比它大的移到它的右边。然后对两边分别重复执行该操作，直到两边都只有一个元素。归并：层层向下二分，然后再向上排序合并\n堆排序：将堆顶元素取走存起来，将末尾元素换到堆顶，重新将二叉树调整成堆，再取走堆顶…如此重复多次…\n桶排序：根据数组元素范围，按顺序划分出多个小范围的“桶”，将元素依次放入对应桶内；对各桶内元素排序\n遍历都是针对 图和树（树是一种特殊的图）结构来说的：\ntxt广度优先遍历：也叫层序遍历，按层进行遍历。\n\n深度优先遍历：沿着一条路径走到底，再回退走岔路，没有或走完岔路继续回退走岔路。\n\n先序遍历：首先，遍历根节点； 然后，遍历其左子树； 最后，遍历其右子树\n\n中序遍历：首先，遍历其左子树； 然后，遍历根（父）节点； 最后，遍历其右子树\n\n后序遍历：首先，遍历其左子树； 然后，遍历其右子树； 最后，遍历根（父）节点","slug":"杂学/数据结构/算法","date":"2024-10-11T06:01:50.424Z","categories_index":"数据结构","tags_index":"技术","author_index":"upstreamboat"},{"id":"36feb5f5be8b1bbb0ad32603cb33f232","title":"08-图","content":"多对多关系\n有向图、无向图\n二维数组或链表实现\n","slug":"杂学/数据结构/08-图","date":"2024-10-11T06:00:34.685Z","categories_index":"数据结构","tags_index":"技术","author_index":"upstreamboat"},{"id":"3efb043dafcb75dfdb0d6746e6895a19","title":"07-堆","content":"\n定义\n\n堆是完全二叉树\n有序：堆中某节点的值总是不大于（大顶堆）或不小于（小顶堆）其父节点的值\n内存中通过数组实现\n\n\n优点\n  可以轻易获取最大&#x2F;最小值\n\n操作：\n  向上调整、向下调整：将树调整为符合堆的条件\n\n应用：\n\n堆排序：（假设大顶堆降序排序）\n\n将堆顶元素取走存起来\n\n将末尾元素换到堆顶\n为什么？：因为堆顶空了，得补充一个元素。如果补充的是其它位置元素，就会又空出一个位置，又需要再补。只有是末尾元素，才不需要补。\n\n重新调整成堆。然后重复这三步，这样存起来的元素集合就是排好序的了。\n\n\n\nTop-K：如何取前&#x2F;第 k 大&#x2F;小的元素\n  例如：提取前 3 小的元素？[68, 40, 44, 18, 16, 24]\n  方法一：\n\n取数组前 3 个元素创建一个拥有 3 个节点的大顶堆为什么是大顶堆？：堆顶是 3 个中最大的，这样后面比较时只需要比较一次即可\n拿数组第 4 个元素与堆顶比较，小于堆顶则将堆顶换成第 4 个元素，否则跳过\n如果堆顶发生了交换，调整成堆\n拿数组第 5 个元素继续比较，直到比较完所有。此时堆里的 3 个元素就是最小的 3 个了，依次取出即可\n\n  方法二：\n\n取数组所有元素形成小顶堆\n取出堆顶元素，便是第 1 小的元素\n调整成堆，继续取出堆顶元素，便是第 2 小的元素\n继续调整、取出，便是第 3 小的元素\n\n\n\n\n数组实现堆\n  如堆对应的数组结构：[68, 40, 44, 18, 16, 24]\n  堆为何必须是完全二叉树？\n\n\n\n\n\n\n\n\n\n\n完全二叉树是必然连续的，完美符合数组连续存储的特性；\n\n\n比如：如果不是完全二叉，那么上面数组中的 16 如何判断是 40 的叶子节点，还是 44 的叶子节点呢？\n\n\n\n\n\n\n\n\n\n\n\n可以避免不必要的索引浪费，提高效率\n\n\n比如：为了区分 16 是谁的子节点，就需要在 18 和 16 之间再加一个索引，该索引没有数据便被浪费了\n\n\n参考文档\n\n\n","slug":"杂学/数据结构/07-堆","date":"2024-10-11T05:52:26.741Z","categories_index":"数据结构","tags_index":"技术","author_index":"upstreamboat"},{"id":"28e38fbc3eb81ab51fdb565afb016349","title":"06-树","content":"树有根节点分叉出多个子节点，最后到叶子节点\n\n名词解释  节点的层数（Level）：规定根节点在 1 层，其他任一节点的层数是其父节点的层数加 1；  节点的度（Degree）：节点的子树的个数；  节点的深度：从根节点到该节点的层数（从上向下数）；  节点的高度：从其子树的叶子节点到该节点的层数（从下向上数）；  叶子节点（Leaf）：度为 0 的节点（即树最下方的节点）；  树的度&#x2F;深度&#x2F;高度：最大的节点的度&#x2F;深度&#x2F;高度。\n\n实现  树可以由链表（每个指针指向各个子树）或数组实现\n\n\n二叉树每个节点最多只能有两个子节点，分别称为左右节点\n满二叉树除叶子节点外，所有节点都有两个子节点。同层节点的高度相同。\n完全二叉树\n特性：\n只允许最后一行不满\n叶子节点可以缺失，如果有必须靠左排列（要么左右都没有，但不能只有右节点却没有左节点）\n最后一行的元素之间不能有间隔，即叶子节点之间必须连续\n\n\n\n满二叉树是特殊的完全二叉树\n二叉搜索树（BST，Binary Search Tree）左子节点数据&lt;根节点，右子节点数据&gt;根节点。也称为二叉排序树和二叉查找树\n\n优点：这里的高不一定是最高，只是相对来说更为均衡，没有特别大的短板\n\n树结构中数据都是有序的，查找效率高；\n空间利用率高；\n可以快速获取最大值和最小值\n\n\n缺点：\n\n数据多时，层级变深\n平衡时为 O(log n)，可当数据分布不均匀时，查找时间会变长。极端情况下会变成链表，查找效率就变成了 O(n)\n\n\n遍历数据：\n\n先序遍历：首先，遍历根节点； 然后，遍历其左子树； 最后，遍历其右子树\n中序遍历：首先，遍历其左子树； 然后，遍历根（父）节点； 最后，遍历其右子树\n后序遍历：首先，遍历其左子树； 然后，遍历其右子树； 最后，遍历根（父）节点参考图文\n\n\n\nAVL 树一种平衡树，任何节点的两个子树的高度最大差为 1。\n可以通过 自旋方式 将二叉树转为 AVL 树（如何自旋略）。\n时间复杂度是 O(log n)\n红黑树也是一种平衡树，比 AVL 树平衡度稍弱，但提高了插入&#x2F;删除时的性能\n可以通过 自旋+标红黑色 将二叉树转为红黑树。\n时间复杂度也是 O(log n)\n完全二叉树图示\n非二叉树图示\n","slug":"杂学/数据结构/06-树","date":"2024-10-11T03:51:33.697Z","categories_index":"数据结构","tags_index":"技术","author_index":"upstreamboat"},{"id":"d381f5e99a0356fa4f08900f70fb258e","title":"05-队列","content":"队列\n定义  先进先出的线性表，一端只能进、另一端只能出，平均时间复杂度 O(1)\n\n缺点\n\n读写顺序固定\n\n分类\n\n顺序队列：底层采用的是数组当有元素出队后，顺序队列之前的数组存储空间将无法再被使用，造成了空间浪费，这时可以改进成为循环队列\n链队列：底层采用的是链表两种队列都会有两个额外指针，分别指向队头和队尾\n\n\n特点  根据底层实现不同而不同，如：元素是否同类型、内存是否连续\n\n\n优先队列数据 + 优先级\n","slug":"杂学/数据结构/05-队列","date":"2024-10-11T03:48:38.320Z","categories_index":"数据结构","tags_index":"技术","author_index":"upstreamboat"},{"id":"120683714c6f877b6a195e7852c3478a","title":"04-栈","content":"\n定义  先进后出的线性表，一端封闭、只能一端进出，平均时间复杂度 O(1)\n\n缺点  读写顺序固定\n\n操作\n\n入栈\n出栈\n\n\n分类\n\n顺序栈：底层采用的是数组\n链栈：底层采用的是链表链头是栈顶：因为链表查找需要遍历，如果设置链尾是栈顶，那么每次栈操作都需要遍历整个链表\n\n\n特点  根据底层实现不同而不同，如：元素是否同类型、内存是否连续\n\n\n","slug":"杂学/数据结构/04-栈","date":"2024-10-11T03:47:13.345Z","categories_index":"数据结构","tags_index":"技术","author_index":"upstreamboat"},{"id":"394ebf0bd609d8d89ce568e2036b5731","title":"03-链表","content":"链表\n特点：\n元素类型可以不同\n大小不固定创建链表时，并不会开辟一块固定的内存空间，而是将元素存储在内存中的可用位置，这些位置可能是不连续的，通过指针联系。\n内存地址不连续这样就可以有效利用内存中的非连续空间。\n查找慢，增删改快每次查找都需要从头遍历去依次查找，平均时间复杂度 O(n）；增删改快，平均时间复杂度 O(1)。但每次修改前都需要先进行一次查找，不过修改依然很快，因为查找的效率相对来说比修改快多了。\n\n\n\n单链表\n特点\n\n数据 + 指针（存放下一个元素地址）\n只能单向遍历\n无法回到上一结点\n\n\n头结点  数据域为空、指针域指向第一个元素的地址  如果不设置头结点，那么其它元素都是通过指针操作的，而第一个元素却不是（因为如果不设置头结点，便没有指针指向第一个元素），这样元素的操作方式不统一\n\n头指针  永远指向链表第一个节点（头结点或第一个元素）的位置，用于指明链表的位置，便于后期找到链表\n\n\n双链表\n特点\n前驱指针（前一个地址）+ 数据 + 后继指针（下一个地址）\n可以逆序遍历\n实现更复杂\n占用内存更大\n\n\n\n","slug":"杂学/数据结构/03-链表","date":"2024-10-11T03:42:59.890Z","categories_index":"数据结构","tags_index":"技术","author_index":"upstreamboat"},{"id":"2402de26004c681128feeb782374b176","title":"02-hash表","content":"散列表参考视频\n说明hash 表本质上也是一个数组，创建 hash 表时，也是开辟一块连续内存空间作为 hash 表空间，但却不是顺序连续存入元素。\n图示\n\n\n内存：\n\na,c\n\n\nb\nd,e,f\n\n\n\n内存信息（下标）：\n0\n1\n2\n3\n4\n5\n\n\n特点\n不考虑下标重复的情况，查找、增删改都很快，时间复杂度都为 O(1)\nhash 表中的键不能重复\n数据在内存中不连续\n\n缺点\n空间利用率不高，底层使用的数组中很多单元没有被利用\n元素是无序的，不能按照固定顺序遍历\n\n存储方式内存中存储的是键值对（key-value），下标不再是连续的，而是键的 hash 值  ​ ​hash 值 = hash 函数( 键 )​\n\nhash 函数：将输入参数（通常是字符串或数值）映射成数值（hash 值）的函数。\n\n\n\n\n\n\n\n\n\nhash 函实现形式：除留余数法、直接定址法、平方取中法、折叠法等\n\n这种存储方式会产生两个问题：\n\n\n\n多个不同的键可能得到相同的 hash 值，即同一个下标。称为 hash 冲突\n\n\n\n\n\n\n\n\n\n\n解决法一：链地址法：\n\n所有 hash 值为当前下标的元素形成一个单向链表，链表的头结点存储在 hash 表中(如果该链表过长，还可以转为红黑树存储，或者直接对 hash 表进行扩容）\n\n解决法二：开发寻址法：\n\n\n\n\n\n\n\n\n\n遇到冲突，便去找下一个下标位置看是否为空\n\n\n\n\n通过对键 hash 运算，无法覆盖所有下标，即部分下标位置会空着。造成该 hash 表空间中的内存出现碎片化，出现内存浪费。\n\n\n元素查找方式与数组相同\n","slug":"杂学/数据结构/02-hash表","date":"2024-10-11T02:37:51.582Z","categories_index":"数据结构","tags_index":"技术","author_index":"upstreamboat"},{"id":"4b29c707a8fa743d3a9a3cecae939a88","title":"01-数组","content":"数组说明进程间的内存是独立的，创建数组时，开辟一块连续内存空间作为数组空间，按顺序连续存入元素。\n图示\n\n\n内存：\na\nb\nc\nd\ne\nf\n\n\n\n内存信息（下标）：\n0\n1\n2\n3\n4\n5\n\n\n特点\n查找快，增删改慢\n元素可以重复\n数据在内存中的地址连续\n\n缺点\n元素类型必须相同\n大小固定\n增删改需要进行元素位移，慢且开销大\n\n数组元素查找方式\n通过下标查找：时间复杂度为 O(1)\n\n\n\n\n\n\n\n\n\n定义数组时可以知道数组的首地址：var arr &#x3D; [3]int{1,2,3}要查找下标为 2 的元素，编译器只需要  ​ ​ 元素地址 &#x3D; 首地址 + 数据类型长度 * 下标 ​ ​  即可得到其内存地址直接查找\n\n随机访问：时间复杂度 O(logN)\n\n\n\n\n\n\n\n\n\n二分查找法\n\n\n","slug":"杂学/数据结构/01-数组","date":"2024-10-11T02:32:07.162Z","categories_index":"数据结构","tags_index":"技术","author_index":"upstreamboat"},{"id":"f0285a93d724883c25f231f1938cf9c3","title":"总览","content":"参考 1参考 2参考 3\n注：数据结构中的堆栈与程序运行时的堆栈不是同一个东西\n分类\n线性表（一对一），包括顺序表（数组）、hash 表、链表、栈、队列；\n树结构（一对多），包括普通树，二叉树（完全二叉树（堆）、二叉搜索树、平衡树（AVL 树、红黑树））、B 树 等；\n图存储结构（多对多）；\n\n","slug":"杂学/数据结构/总览","date":"2024-10-11T02:27:40.806Z","categories_index":"数据结构","tags_index":"技术","author_index":"upstreamboat"},{"id":"66e57a4409ad22c1322b5d5381bb37e5","title":"06-知识点","content":"\n外键对应的必须是唯一性索引。比如主键、unique 定义的字段\n\n","slug":"杂学/Mysql/06-知识点","date":"2024-10-11T02:06:20.576Z","categories_index":"Mysql","tags_index":"技术","author_index":"upstreamboat"},{"id":"c0b9ae6ffec5bc9b2d5caca7dc32deb0","title":"05-索引规则","content":"索引使用规则现有联合索引 idx_ename_deptno_comm，索引字段顺序为 ename、deptno、comm\n1. 最左前缀查询时，如索引第一个字段(ename)不存在，则不走索引；如存在跳过字段情况，则被跳过字段(deptno)之后的字段(comm)不走索引。\n\n正常情况（where 后的条件顺序无关）\n  123desc SELECT \\* from emp where ename=&#x27;WJEWTE&#x27;; -- 走索引，索引长度 83desc SELECT \\* from emp where ename=&#x27;WJEWTE&#x27; and deptno=3; -- 走索引，索引长度 88desc SELECT \\* from emp where ename=&#x27;WJEWTE&#x27; and deptno=3 and comm=400; -- 走索引，索引长度 93\n\n异常情况\n  12desc SELECT * from emp where ename=&#x27;WJEWTE&#x27; and comm=400; -- 走索引，索引长度83，说明只有ename走了索引，comm没有走desc SELECT * from emp where deptno=3 and comm=400; -- 不走索引，因为缺少最左前缀字段ename\n\n2、范围查询（&lt;,&gt;）当使用&gt;或&lt;时，会使其右侧不走索引\n\n正常情况\n  12desc SELECT * from emp where ename=&#x27;WJEWTE&#x27; and deptno&gt;3; -- 走索引，索引长度88desc SELECT * from emp where ename=&#x27;WJEWTE&#x27; and deptno&gt;=3 and comm=400; -- 走索引，索引长度93\n\n异常情况\n  1desc SELECT * from emp where ename=&#x27;WJEWTE&#x27; and deptno&gt;3 and comm=400; -- 走索引，索引长度88，说明comm没有走\n\n3. 索引列运算对索引字段进行运算时，会不走索引\n\n异常情况\n  1desc SELECT * from emp where SUBSTR(ename,4,3)=&#x27;WTE&#x27;; -- 不走索引\n\n4. 字符串不加引号字符串类型的表字段存储数字时，虽然不加引号能查出来，但不走索引\n\n正常情况  1desc SELECT * from emp where ename = &#x27;111&#x27; ; -- 走索引\n异常情况  1desc SELECT * from emp where ename = 111 ; -- 不走索引\n\n5. 模糊匹配最左侧有%时，不走索引\n\n正常情况  1desc SELECT * from emp where ename like &#x27;WJ%WT%&#x27; ; -- 走索引\n异常情况  1desc SELECT * from emp where ename like &#x27;%JEWT%&#x27; ; -- 不走索引\n\n6. or 连接只要有一边不走索引，则整个都不走索引\n1desc SELECT * from emp where deptno=3 or comm=300 ;\n\n7. 特殊情况根据数据分布，mysql 会自动优化是否选择索引\n1234desc SELECT * from dept where deptno&gt;9; -- dept&gt;9的数据超过了总数据量的一半，直接全表扫描，不走索引desc SELECT * from dept where deptno&gt;10; -- dept&gt;10的数据不到一半，又走了索引-- 这里的一半，只是预估值；还有，即使查询数据占了总数据量的绝大多数，也未必就一定不走索引的，不知道为什么desc SELECT * from emp where comm=400 ; -- 500万条数据只有一条不是comm=400，但还是走了索引，不知道为什么\n","slug":"杂学/Mysql/05-索引规则","date":"2024-10-11T01:50:26.342Z","categories_index":"Mysql","tags_index":"技术","author_index":"upstreamboat"},{"id":"d837ac5d90753ab8aaca1b36dc2bf2da","title":"04-索引","content":"索引分类聚集索引\n自动生成，有且仅有一个\n\n\n\n\n\n\n\n\n\n1）根据主键自动生成2）主键不存在，根据唯一索引自动生成3）都不存在，生成一个隐藏的聚集索引（无法查看）\n\n叶子节点中的每个 key 存储“id、行数据”\n\n\n非聚集索引\n又叫辅助索引&#x2F;二级索引\n叶子节点中的每个 key 存储“索引列、对应的聚集索引 id”；如涉及回表查询，会根据该 id 在聚集索引中查找\n\n物理空间\n索引占用物理空间，大小根据表信息、字段信息、数据量等不定\n\n视图是虚拟表，不占用物理空间，是一个 sql 的执行结果\n\n查看空间占用\n  12345-- 优化表的统计信息analyze table cfg;-- 查看表的统计信息：包括数据大小、索引大小（需要先执行analyze，否则信息更新不及时）SELECT table_name,table_rows,data_length,index_length from information_schema.`TABLES` where table_name = &quot;cfg&quot;;\n\n相关操作\n查看索引\n\n1show index from emp;\n\n\n自动生成\n\n\n建表时根据主键会自动生成一个主键的索引\n被 uinque 约束的字段也会生成索引\n\n\n创建前缀索引：截取 ename 的前 5 个字符作为索引\n\n1CREATE index idx_ename_5 on emp(ename(5));\n\n索引优化\n尽量符合索引规则\n\n尽量覆盖索引，避免回表查询\n\n\n\n\n\n\n\n\n\n回表查询\n\n\n先在二级索引根据条件字段查到聚集索引的 id，再回到聚集索引根据 id 查找整行数据内容\n写 sql 时应尽量避免出现回表查询\n\n\n  12345desc SELECT ename,comm,deptno from emp where ename=&#x27;WJEWTE&#x27; and deptno=3 and comm=400; -- 不回表，ename,comm,deptno皆是索引idx_ename_deptno_comm的字段desc SELECT empno,ename,comm,deptno from emp where ename=&#x27;WJEWTE&#x27; and deptno=3 and comm=400; -- 不回表，empno是主键，自动生成了聚集索引；ename,comm,deptno皆是索引idx_ename_deptno_comm的字段desc SELECT empno,ename,comm,deptno,job from emp where ename=&#x27;WJEWTE&#x27; and deptno=3 and comm=400; -- 回表查询，需要回表查询job字段\n\n注意事项\n当字段重复内容（又叫基准数或散列程度）过多时，索引便失去了意义\n\n1desc SELECT * from emp where comm=400 ; -- 虽然建立了comm的索引，但comm=400的记录有几百万条，索引没有意义\n","slug":"杂学/Mysql/04-索引","date":"2024-10-11T01:12:20.673Z","categories_index":"Mysql","tags_index":"技术","author_index":"upstreamboat"},{"id":"d8678c04f78a7831628a4e9648b18b4a","title":"03-性能","content":"性能分析–时间慢查询123show global status like &#x27;Com_______&#x27;; -- 显示增删改查的执行次数show VARIABLES like &#x27;slow_query_log&#x27;; -- 显示慢查询日志\n\n\n配置文件在&#x2F;etc&#x2F;my.conf\n\n123set slow_query_log=1 -- 开启慢查询set long_query_time=2 -- 设置sql执行时间超过2s为慢查询\n\n\n日志文件在&#x2F;var&#x2F;lib&#x2F;mysql&#x2F;*-slow.log\n\nprofile通过 profile 查看 sql 的详细执行信息\n123456789select @@have_profiling;select @@profiling;set profiling=1;show profiles;show profile cpu for query 252; -- 通过query_id查看单个sql的详细执行信息\n\n模拟数据123select * from emp where ename=&#x27;aaaabd&#x27;; -- 执行后会在慢查询日志中有记录，也会在profile中有记录select * from emp where empno=&#x27;1364&#x27;; -- 因执行时间&lt;2s，只会在profile中有记录\n\n性能分析–执行计划desc 或 explain：可以显示 sql 的执行计划\n\n\n\n\n\n\n\n\n\n执行结果的 type 字段说明：\n\n\ntype：NULL：不查表\ntype：const：查主键、唯一索引\ntype：ref：查非唯一索引\ntype：index：全索引查询\ntype：all：全表查询\n\n\n123desc select count(1) from emp,dept where emp.deptno=dept.id and dept.id=10;desc SELECT * from dept where id in (select deptno from emp where ename=&#x27;ZAEsaa&#x27;);\n\n\n添加索引 idx*deptno 后，查询性能无变化(因为 deptno 重复数据太多)\n\n123CREATE index idx_deptno on emp(deptno);SELECT * from emp where deptno=2; # 约 2~3sSELECT * from emp where deptno=3; # 约 2~3s\n\n\n添加索引 idx_deptno_ename 后，查询性能明显提升\n\n123CREATE index idx_deptno_ename on emp(deptno,ename);SELECT * from emp where deptno=3 and ename=&#x27;WJEWTE&#x27;;\n\n\n但此时出现以下现象\n\n123desc SELECT * from emp where deptno=2; # 性能无变化 约2~3s（走的是索引idx_deptno）desc SELECT * from emp where deptno=3; # 性能变慢 约26s（因为走错了索引idx_deptno_ename，为什么会走错索引不知道）\n\n\n\n\n\n\n\n\n\n\n解决办法：\n\n指定索引\n\n12345desc SELECT * from emp use index(idx_deptno) where deptno=3; # 建议，实际结果未必是指定的索引desc SELECT * from emp force index(idx_deptno) where deptno=3; # 强制，实际结果一定是指定的索引desc SELECT * from emp ignore index(idx_deptno_ename) where deptno=3; # 忽略，实际结果是其它索引\n\n\n修改索引\n\n12--修改了字段顺序，打破了索引的最左前缀规则，使得上面的sql无法匹配到索引idx_deptno_enameCREATE index idx_ename_deptno on emp(ename,deptno);\n\n\n删除索引\n\n1drop index idx_deptno_ename on emp(deptno,ename);\n\n性能分析–sql 优化1. 插入优化\n使用 load 加载数据文件：比批量插入性能更好\n使用批量插入：比单条插入性能更好。因为单条 sql 每次插入都会开关事务，将多条 sql 合并会减少事务开销\n\n2. 主键优化\n尽量降低主键长度。因为无论是聚集还是非聚集索引，都会存储一份主键 id\n尽量保证顺序插入，可以设置主键自增。因为随机插入时，会发生页分裂\n\n3. order by 优化\n使用覆盖索引，并且为排序字段建立索引。涉及联合索引时，需遵守最左前缀规则（order by 是有顺序的，与 where 不同）\n\n123456-- 这两个sql是不一样，如果索引是idx_empno_ename，那么第二条sql就打破了最左前缀规则select empno,ename from emp order by empno,ename;select empno,ename from emp order by ename,empno;-- where可以与order by一起满足最左前缀select empno,ename from emp where empno = 1 order by ename;\n\n\n索引字段也是有顺序的，排序顺序需要和其相同或相反，但不能是一正一反\n\n12345678select empno,ename from emp order by empno asc, ename asc; -- 正确select empno,ename from emp order by empno desc, ename desc; -- 正确，因为数据会形成链表，只要反向查找即可select empno,ename from emp order by empno asc, ename desc; -- empno会走索引，ename则不会    -- 要想使该sql完全走索引，可以在创建索引时指定排序方式：    create index idex_empno_ename on table emp(empno asc, ename desc);\n\n4. group by 优化（与 order by 类似）\n使用覆盖索引，并且为分组字段建立索引。涉及联合索引时，需遵守最左前缀规则（group by 也是有顺序的）\n\n1234desc SELECT fid,gid,count(*) from bld GROUP BY fid,gid;-- where可以与group by一起满足最左前缀desc SELECT gid,count(*) from bld where fid=1 GROUP BY gid;\n\n5. limit 优化\n通过覆盖索引加子查询形式进行优化\n\n1234567891011-- 此语句耗时很长select * from tb_sku limit 9000000, 10;-- 通过覆盖索引加快速度，直接通过主键索引进行排序及查询select id from tb_sku order by id limit 9000000, 10;-- 下面的语句是错误的，因为 MySQL 不支持 in 里面使用 limit-- select * from tb_sku where id in (select id from tb_sku order by id limit 9000000, 10);-- 通过连表查询即可实现第一句的效果，并且能达到第二句的速度select * from tb_sku as s, (select id from tb_sku order by id limit 9000000, 10) as a where s.id = a.id;\n\n6. update 优化\nupdate 的 where 字段有索引，则是行级锁，此时可以修改其它行数据\nupdate 的 where 字段无索引，则是表锁，此时无法修改该表数据\n\n7. count 优化\ncount(1)：走聚集索引，返回结果填充为 1，然后计算行数\ncount(*)：走聚集索引，返回结果无填充，然后计算行数\ncount(索引字段)：走索引，返回结果为字段内容，若字段设置为 not null，则直接计算行数；若未设置，则去除为 null 的字段再计算行数\ncount(非索引字段)：全表扫描，返回结果为字段内容，若字段设置为 not null，则直接计算行数；若未设置，则去除为 null 的字段再计算行数\ncount(null) &#x3D; 0\n\n","slug":"杂学/Mysql/03-性能","date":"2024-10-11T00:45:57.144Z","categories_index":"Mysql","tags_index":"技术","author_index":"upstreamboat"},{"id":"2e22dd5c70e5e707ab9b420f2d590c06","title":"02-引擎","content":"innodb特点事务、外键、行级锁\n数据存储\nmysql 的数据存储在硬盘文件中，和索引在同一个文件中。\n存储区域划分(从外到内包含多个)：表空间–&gt;段–&gt;区(1M)–&gt;页(16K)–&gt;行\n所有真实数据都是以 B+Tree 的形式存储在聚集索引的叶子节点上\n每个节点都是一个数据页（页是最小指令单元），每页中有多行数据\n\n索引结构：升级版 B+Tree\n二叉树\n\n\n\n\n\n\n\n\n\n缺点：\n\n数据多时，层级会很深\n顺序存储时，形成了单边链表\n\n\n红黑树：自平衡二叉树\n\n\n\n\n\n\n\n\n\n解决了形成单边链表的问题，但是层级依旧很深\n\nB-Tree\n\n\n\n\n\n\n\n\n\n\n一个节点存在多个 Key，每个 key 中都存储“指针、数据”\n参考视频\n解决了层级和单边问题，但是依然存在两个缺点：\n\n越靠近根节点的数据，查询越快；越靠近叶子节点，查询越慢。导致性能不稳定\n数据存储在节点上，不连续，当需要查询某一范围内的数据时，需要不断地进出查询各个节点\n\n\n\n\n\nB+Tree\n\n\n\n\n\n\n\n\n\n\n根节点仅存储指针，不存储数据，即所有的数据都在叶子节点上\n叶子节点存储“指针、数据”，且叶子间形成单向链表\n参考视频\n\n\nMysql 中的升级版 B+Tree：叶子节点间形成循环双向链表\n\n\n","slug":"杂学/Mysql/02-引擎","date":"2024-10-10T09:27:12.374Z","categories_index":"Mysql","tags_index":"技术","author_index":"upstreamboat"},{"id":"f18f55fc5c9e24ee7d616b96f31f5014","title":"01-事务","content":"子查询\n标量子查询\n\n12--根据销售部部门 ID，查询员工信息select * from emp where dept_id = (select id from dept where nane = &#x27;销售部&#x27;)\n\n\n列子查询\n\n\n\n\n\n\n\n\n\n\nall、any（任意，也可以用 some）、in、not in\n12--比财务部所有人工资都高的员工信息select * from emp where salary &gt; all(select salary from emp where dept_id = (select id from dept where name&#x27;财务部&#x27;))\n\n\n行子查询\n\n12--查询与&quot;张无忌”的薪资及直属领导相同的员工信息select * from emp where (salary,managerid)=(select salary,managerid from emp where name =&#x27;张无忌&#x27;)\n\n\n表子查询\n\n\n\n\n\n\n\n\n\n\n\nwhere 后\n\n12--查询与”鹿杖客”，&quot;宋远桥”的职位和薪资相同的员工信息select * from emp where(job,salary) in (select job,salary from emp where name=&#x27;鹿杖客&#x27; or name=&#x27;宋远桥&#x27;)\n\n\n\n\n\n\n\n\n\n\n\nfrom 后\n\n12--查询这部分员工，对应的部门信息select e.*,d.* from (select from emp where entrydate &#x27;2006-01-01&#x27;) e left join dept d on e.dept_id d.id\n\n事务特性：ACID\n原子性（Atomicity）：一个事务中的多个操作是一个整体，要么全部成功，要么全部失败\n\n一致性（Consistency）：事务变更前与事务变更后的数据在整体上是一致的\n\n\n\n\n\n\n\n\n\n比如：现有 A&#x3D;10，B&#x3D;10，则 A+B&#x3D;20；现执行事务将 B 的的钱转给 A，事务后 A&#x3D;15，B&#x3D;5，则依旧是 A+B&#x3D;20；A+B 的整体数据在事务前后是一致的\n\n隔离性（Isolation）：多个事务之间具有一定的隔离性，具体隔离程度有不同级别\n\n持久性（Durability）：事务变更后，数据会持久地保存在数据库中\n\n\n开启事务方法1234--法1：set @@autocommit = 0; --设为于动捉交--法2：start transaction; -- start 或者 begin\n\n事务并发可能引起的问题\n脏读：事务 A 读取到了事务 B 还没有提交的数据\n不可重复读：事务 A 中两次读取数据的结果不同。例如：事务 A 第一次读取数据，然后事务 B 提交了修改数据，事务 A 此时再次读取数据，结果会与第一次读取不同。对于事务 A 自身而言，就会很奇怪，为什么两次读取不一样。\n幻读：事务 A 读取时没有对应数据，但插入时却显示已存在对应数据。例如：数据 1 不存在，事务 A 读取数据 1，读不到；然后事务 B 插入数据 1；此时事务 A 也插入数据 1，会显示数据 1 已存在，对于事务 A 自身而言就像出现了幻觉一样。\n\n数据库的事务隔离级别从上往下，隔离强度逐渐增强，性能逐渐变差\n\n\n\n隔离级别\n脏读\n不可重复读\n幻读\n\n\n\nRead uncommitted\n√\n√\n√\n\n\nRead committed\n×\n√\n√\n\n\nRepeatable Read(默认)\n×\n×\n√\n\n\nSerializable\n×\n×\n×\n\n\n设置事务隔离级别\n查看级别select @@TRANSACTION_isolation\n设置级别set [ session | global ] TRANSACTION isolation level &#123; read UNCOMMITTED | read COMMITTED | REPEATABLE read | serializable &#125;\n\n","slug":"杂学/Mysql/01-事务","date":"2024-10-10T07:34:56.615Z","categories_index":"Mysql","tags_index":"技术","author_index":"upstreamboat"},{"id":"f437416886ea6ecdfb774f42f41fc16a","title":"POJO","content":"DO 数据库对应实体类：nameDO\nDTO 接收前端传入参数：nameDTO\nVO 后端响应给前端：nameVo\nBO 后端自身业务逻辑处理：NameBo\n统称为 POJO\n","slug":"杂学/未分类/POJO","date":"2024-10-10T07:34:14.608Z","categories_index":"未分类","tags_index":"技术","author_index":"upstreamboat"},{"id":"5a1ac8f7ce2fe72478de5e28a4dd163f","title":"环境变量","content":"环境变量优先级用户变量 &gt; 系统变量\nlinux 下配置文件.bashrc：用户环境变量\n&#x2F;etc&#x2F;profile：系统环境变量\n","slug":"杂学/未分类/环境变量","date":"2024-10-10T07:32:34.244Z","categories_index":"未分类","tags_index":"技术","author_index":"upstreamboat"},{"id":"d62d040dfd4c4e9113c3e8f147f56a41","title":"mitmproxy","content":"证书安装\n启动 mimtweb 或 mitmporxy\nwindows 端：设置代理：填写 ip+port；（手机端：网络连接-代理-ip+port）\n打开网址：http://mitm.it/\n\n使用\n手机端：网络连接-代理-ip+port\n本地 windows 端：设置代理\n其它 windows 端：设置网关地址为开启 mitm 服务的电脑 ip\n\n启动命令1234567mitmweb.exe -p 9090 --web-port 9091 --mode socks5# -p：指定代理端口# --web-port：web的端口# --mode：代理协议模式：http（默认）、socks5\n\nmitmproxy 修改响应\n安装  mitmproxy：pip install mitmproxy\n创建  modify_response.py\n\n123456789from mitmproxy import httpdef response(flow: http.HTTPFlow) -&gt; None:    if flow.request.method == &#x27;GET&#x27; and flow.request.host == &#x27;[www.ea.com](http://www.ea.com)&#x27; and flow.request.path.startswith(&#x27;/ea-sports-fc/ultimate-team/web-app/js/&#x27;):        flow.response.content = flow.response.content.decode(encoding=&#x27;utf-8&#x27;).replace(&quot;debugger&quot;, &quot;return&quot;).encode(encoding=&#x27;utf-8&#x27;)        print(&#x27;modify: &#x27; + flow.request.path)\n\n\n启动 mitmproxy，运行脚本：mitmproxy -s modify_response.py\n\n","slug":"杂学/未分类/mitmproxy","date":"2024-10-10T07:26:00.139Z","categories_index":"未分类","tags_index":"技术","author_index":"upstreamboat"},{"id":"a7119afd38af4bcd28d22403fa6c78f9","title":"swagger","content":"\n下载 swagger 包go get -u github.com/swaggo/gin-swagger\n\n1234567891011121314151617181920212223242526272829303132333435363738394041424344454647// 2.导入依赖。注意：一个不能少import (   docs &quot;myProject/docs&quot;   swaggerfiles &quot;github.com/swaggo/files&quot;   ginSwagger &quot;github.com/swaggo/gin-swagger&quot;)// 3.router中集成swaggerfunc ()&#123;route.GET(&quot;/swagger/*any&quot;, ginSwagger.WrapHandler(swaggerfiles.Handler))route.GET(&quot;/api/helloworld&quot;,Helloworld)&#125;// 4.写swagger注解// PingExample godoc// @Summary ping example// @Schemes// @Description do ping// @Tags example// @Accept json// @Produce json// @Success 200 &#123;string&#125; Helloworld// @Router /api/helloworld [get]func Helloworld(g *gin.Context)  &#123;g.JSON(http.StatusOK,&quot;helloworld&quot;)&#125;\n\n\n查看接口\n\n\n\n\n\n\n\n\n需要先打开 goland。specificationKey 在每次重新打开 goland 都会变：网址\n\n\n","slug":"杂学/未分类/swagger","date":"2024-10-10T07:20:01.561Z","categories_index":"未分类","tags_index":"技术","author_index":"upstreamboat"},{"id":"6c57061757defff1e37f9fe3fc744b68","title":"issue、problem、question","content":"issue、problem、questionissue（议题、问题）：某一特定领域、类型的问题\nproblem（难题、问题）：某一具体事件问题，要做的事。比 issue 更具体\nquestion（疑问、问题）：询问、讨论的问题，要说的事。\n","slug":"杂学/未分类/issue、problem、question","date":"2024-10-10T07:16:27.497Z","categories_index":"未分类","tags_index":"技术","author_index":"upstreamboat"},{"id":"f2abfae25e742024c7764769245f7cab","title":"CA证书","content":"\n","slug":"杂学/未分类/CA证书","date":"2024-10-10T07:06:05.694Z","categories_index":"未分类","tags_index":"技术","author_index":"upstreamboat"},{"id":"5657dbaafc65d44bb7226a49ee6df3c8","title":"nginx","content":"使用\n步骤 1：打包 vue 项目：会生成 dist 目录（项目必须打包，无法直接使用）npm run build\n\n步骤 2：修改 nginx.conf\n\n\n123456789101112131415161718192021222324252627    server &#123;        listen  8080; # 监听8080端口，所有8080请求都会被nginx拦截        server_name localhost; # 服务名        location / &#123; # 被拦截的请求如果是&quot;/&quot;，则走下面的配置            root /usr/html/dist; # 设置当前工作目录            index index.html; # 该请求返回的资源：/usr/html/dist/index.html            # try_files $uri $uri/ /index.html; # 尝试寻找要返回的资源：先找        &#125;        location /imgae &#123;            root /usr/html/dist;            # try_files：尝试寻找要返回的资源。            # 如请求127.0.0.1:8080/images/test.gif            # 先找/usr/html/dist/imgae/test.gif，            # 若找不到再找/usr/html/dist/imgae/test.gif/目录下的index文件            # 若找不到最后找index.html            try_files $uri $uri/ /index.html;        &#125;        location /api &#123; # 转发所有的/api开头的请求，到后端服务器            proxy_set_header Host $http_host;            proxy_set_header  X-Real-IP $remote_addr;            proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;            proxy_set_header X-Forwarded-Proto $scheme;            rewrite ^/api/(.*)$ /$1 break;  #重写            proxy_pass [http://127.0.0.1:8888](http://127.0.0.1:8888); # 设置代理服务器的协议和地址    &#125;\n\n\n步骤 3：启动 nginx\n\n12345./nginx # 启动./nginx -t # 检查配置文件是否有语法错误./nginx -s reload # 若配置文件改动，重新加载配置文件./nginx -s quit # 当前任务完成后，退出nginx./nginx -s stop # 直接退出nginx\n","slug":"杂学/未分类/nginx","date":"2024-10-10T06:43:39.241Z","categories_index":"未分类","tags_index":"技术","author_index":"upstreamboat"},{"id":"0fed0bef913e91bf625068542167e100","title":"index","content":"杂学Mysql01-事务02-引擎03-性能04-索引05-索引规则06-知识点\n前端泛型跨域解决网络协议网址定位符axiosCookie、Session、Token[[export default]][[F12详解]][[http1.1与http2.0]][[JS+ES6+TS]][[localStorage]]RestFul APIundefined、nullvar、let、const\nvue$attrscomputeddefineEmitsdefinePropshooksmittpiniaref、reactiverouterslotvue 总览watch标签 ref、$refs、$parent生命周期与钩子组件通信\n数据结构01-数组02-hash 表03-链表04-栈05-队列06-树07-堆08-图算法总览\n未分类windows 激活特殊文件地址hexo 使用POJO环境变量mitmproxyissue、problem、questionswaggerCA 证书nginx设计模式编码术语释义正则表达式位移redisProtobufJWTIdea 快捷键goland 激活Base64 编码\nGO 语言基础扩展运算符协程–chan协程–chan 引发 panic协程–chan 阻塞测试协程–CPU、内存协程–图解依赖注入语法–基础语法–进阶知识点contextdeferGingo env-01go env-02go moduleGormimport_initInterfaceInterface–类型断言IOmake、type、rangestring泛型库–casbin库–gjson库–zap\n问答context.Done()Fori 循环的坑go get 错误解决interface 的 nil 问题main 包下文件不互通map 的 struct 成员不能修改的问题test 文件调用对象 nil变量存放在栈还是堆常量自动匹配类型几种 for 循环的区别序列化不成功问题\n项目代码规范项目层次\n运用chromedpFatal、panic、Exit 的区别fmt 换行才打印http 使用代理map 实现 Set 集合oauth2select-case 随机seleniumSprintftime.NewTicker测试测试–性能创建 client 实例打印斐波那契数列调用本地包读取 net.conn关于 gorm 参数问题关于文件读取的坑换行自动插入分号交叉编译解决并发中的数据竞争空结构体库–local_cache库–rand类型转换–隔代转换目录相关实例内联优化_内存对齐切片扩容机制切片修改问题切片运用响应压缩程度分析易错知识有默认值的结构体值、引用传递装饰器实例自定义类型可以有方法字节切片原样写入文件\n命令dockerdocker-01-命令docker-02-更换镜像仓库docker-03-Dockerfiledocker-04-composedocker-05-volume\ngitgit-01-常用命令git-02-ssh 地址无效git-03-gitlab\nlinuxlinux-01-快捷键linux-02-命令linux-03-shell 脚本linux-04-软硬链接linux-05-虚拟机网络连接模式linux-06-虚拟机修改静态 ip查看进程及其网络信息\n","slug":"index","date":"2024-10-09T07:32:00.252Z","categories_index":"","tags_index":"","author_index":"upstreamboat"},{"id":"deffdaaa2a24a19ee257667b3b36743c","title":"设计模式","content":"适配器通过创建一个中间转换的适配器，来将一个接口改造成用户需要的另一个接口。在不修改现有代码的情况下，使两个不兼容的接口能够工作。\n观察者当发布者的对象有修改，则调用订阅者提供的方法告知它们\n代理模式代码增强，在原代码逻辑前后增加一些代码逻辑。访问者不直接访问目标，通过代理访问。代理持有目标对象。\n1. 分类静态代理：编码时便写定的代理\n动态代理：运行时通过反射获取的代理\n2. 优缺点\n优点：\n\n代理模式在客户端与目标对象之间起到一个中介作用和保护目标对象的作用；\n代理对象可以扩展目标对象的功能；\n代理模式能将客户端与目标对象分离，在一定程度上降低了系统的耦合度，增加了程序的可扩展性：\n\n\n缺点：\n\n静态代理模式会造成系统设计中类的数量增加，但动态代理可以解决这个问题；\n在客户端和目标对象之间增加一个代理对象，会造成请求处理速度变慢；\n增加了系统的复杂度；\n\n\n代理模式与装饰者模式：十分相像但目的不同。代理会严格将访问对象和受控对象分离开来，一个代理仅仅只负责一个类，这与装饰器模式是不同的，对于装饰器模式来说，目标对象就是访问对象所持有的。此外虚拟代理的实现与装饰者模式实现是不同的，虚拟代理一开始并不持有远程服务器的资源对象，而是对域名和文件名进行解析才得到该对象，在我们的代码中我们要么传入一个实例，要么让代理持有一个实例，但在虚拟代理中，我么传入一个虚拟的文件资源，虚拟代理对远程服务器进行解析才会获得真实的对象实例，这一点是不同的。\n\n\n工厂模式为什么要用工厂：\n\n解耦：分离对象的创建和使用。当创建对象的过程改变，不需要到每个使用对象的地方进行修改。\n\n减少代码重复：不需要在使用对象前，都写一堆创建对象的过程的代码。\n\n\n例子：比如：创建数据库对象。\n使用理解：首先，工厂模式是为了解耦：把对象的创建和使用的过程分开。就是 Class A 想调用 Class B，那么 A 只是调用 B 的方法，而至于 B 的实例化，就交给工厂类。\n其次，工厂模式可以降低代码重复。如果创建对象 B 的过程都很复杂，需要一定的代码量，而且很多地方都要用到，那么就会有很多的重复代码。我们可以这些创建对象 B 的代码放到工厂里统一管理。既减少了重复代码，也方便以后对 B 的创建过程的修改维护。（当然，我个人觉得也可以把这些创建过程的代码放到类的构造函数里，同样可以降低重复率，而且构造函数本身的作用也是初始化对象。不过，这样也会导致构造函数过于复杂，做的事太多，不符合设计原则。）\n由于创建过程都由工厂统一管理，所以发生业务逻辑变化，不需要找到所有需要创建 B 的地方去逐个修正，只需要在工厂里修改即可，降低维护成本。同理，想把所有调用 B 的地方改成 B 的子类 B1，只需要在对应生产 B 的工厂中或者工厂的方法中修改其生产的对象为 B1 即可，而不需要找到所有的 new B（）改为 new B1()。\n另外，因为工厂管理了对象的创建逻辑，使用者并不需要知道具体的创建过程，只管使用即可，减少了使用者因为创建逻辑导致的错误。\n举个例子：\n一个数据库工厂：可以返回一个数据库实例，可以是 mysql，oracle 等。\n这个工厂就可以把数据库连接需要的用户名，地址，密码等封装好，直接返回对应的数据库对象就好。不需要调用者自己初始化，减少了写错密码等等这些错误。调用者只负责使用，不需要管怎么去创建、初始化对象。\n","slug":"杂学/未分类/设计模式","date":"2024-10-09T02:09:35.638Z","categories_index":"未分类","tags_index":"技术","author_index":"upstreamboat"},{"id":"2ae7625fefa702e7b0a5f4cd2c057f78","title":"编码","content":"ASICII\n\n\n\n\n\n\n\n\n共 128 个，仅包含一些符号和英文字母\nGBK\n\n\n\n\n\n\n\n\n是字符集也是编码格式包含 ASICII 码，也包含了中文等字符\nUnicode\n\n\n\n\n\n\n\n\n仅是字符集，不是编码格式：因为字符集的编号与存储时的编号不同提供的编码格式有：UTF8、UTF16、UTF32包含 ASICII 码，也包含了中文等字符。但是除了 ASICII 码外，其它字符与 GBK 中的编号一样（这就造成不同编码格式间不认识的情况）\n图示[[编码.png]]\n","slug":"杂学/未分类/编码","date":"2024-10-09T02:09:35.637Z","categories_index":"未分类","tags_index":"技术","author_index":"upstreamboat"},{"id":"03a1af7058cec8bb8efe418ed228e157","title":"正则表达式","content":"\n\n\n修饰符\n含义\n描述\n\n\n\ni\nignore - 不区分大小写\n将匹配设置为不区分大小写，搜索时不区分大小写: A 和 a 没有区别。\n\n\ng\nglobal - 全局匹配\n查找所有的匹配项。\n\n\nm\nmulti line - 多行匹配\n使边界字符  ^  和  $  匹配每一行的开头和结尾，记住是多行，而不是整个字符串的开头和结尾。\n\n\ns\n特殊字符圆点  .  中包含换行符  \\n\n默认情况下的圆点  .  是匹配除换行符  \\n  之外的任何字符，加上  s  修饰符之后, .  中包含换行符 \\n。\n\n\nu\nunicode - Unicode 模式，用来正确处理大于\\uFFFF 的 Unicode 字符，ES6 新增\n\n\n\ny\nsticky - 粘连匹配，ES6 新增\ny 匹配时不会跳过任何字符。g 会跳过字符直到找到可匹配项。单单一个 y 修饰符对 match 方法，只能返回第一个匹配，必须与 g 修饰符联用，才能返回所有匹配。‘a1a2a3’.match(&#x2F;a\\d&#x2F;y) &#x2F;&#x2F; [“a1”]‘a1a2a3’.match(&#x2F;a\\d&#x2F;gy) &#x2F;&#x2F; [“a1”, “a2”, “a3”]\n\n\nv\nUnicode 属性类（\\p{…}）的运算，ES6 新增\n差集运算：[A–B]，交集运算：[A&amp;&amp;B]\n\n\nd\n这个修饰符可以让 exec()、match()的返回结果添加 indices 属性，在该属性上面可以拿到匹配的开始位置和结束位置，ES2022 新增。\n多组匹配：const text &#x3D; ‘zabbcdef’;const re &#x3D; &#x2F;ab+(cd(ef))&#x2F;d;const result &#x3D; re.exec(text);result.indices &#x2F;&#x2F;结果：[ [1, 8], [4, 8], [6, 8] ]  &#x2F;&#x2F;一组 abcdef，二组 cdef，三组 ef，注意结束位置是 8 而不是 7，代表下一个位置。\n\n\n","slug":"杂学/未分类/正则表达式","date":"2024-10-09T02:09:35.636Z","categories_index":"未分类","tags_index":"技术","author_index":"upstreamboat"},{"id":"4d09615970c0252d811bab714e63121f","title":"术语释义","content":"单点登录和多点登录\n\n\n\n\n\n\n\n\n单点登录：就是在多个系统中，用户只需一次登录，各个系统即可感知该用户已经登录。多点登录：同一账号可以在不同终端同时登录，同时收发信息。\n\n多点登录限制（禁止用户多点在线）：一个端同 1 一个账号只能登录一个实例\n\n粘包和拆包\n\n\n\n\n\n\n\n\n粘包：如果一次请求发送的数据量比较小，没达到缓冲区大小，TCP 则会将多个请求合并为同一个请求进行发送，这就形成了粘包问题。拆包：如果一次请求发送的数据量比较大，超过了缓冲区大小，TCP 就会将其拆分为多次发送，这就是拆包。\n\n粘包的处理办法：\n\n\n发送端将每个包都封装成固定的长度，比如 100 字节大小。如果不足 100 字节可通过补 0 或空等进行填充到指定长度；\n发送端在每个包的末尾使用固定的分隔符，例如\\r\\n。如果发生拆包需等待多个包发送过来之后再找到其中的\\r\\n 进行合并；例如，FTP 协议；\n将消息分为头部和消息体，头部中保存整个消息的长度，只有读取到足够长度的消息之后才算是读到了一个完整的消息。\n\n\n\n大端小端已知：数据一定是从内存的低地址依次向高地址读取和写入的。\n\n\n\n\n\n\n\n\n\n大端模式，即低地址存放高位字节数小端存储，即低地址存储低位字节数\ndocker参考\n代理Nginx 就可以实现反向代理（Nginx 的 3 大功能：Web 服务器/反向代理/负载均衡）。\n\n\n\n\n\n\n\n\n\n正向代理：我们平时需要访问国外的浏览器是不是很慢，比如我们要看推特，看 GitHub 等等。我们直接用国内的服务器无法访问国外的服务器，或者是访问很慢。所以我们需要在本地搭建一个服务器来帮助我们去访问。那这种就是正向代理。(浏览器中配置代理服务器)反向代理：那什么是反向代理呢。比如：我们访问淘宝的时候，淘宝内部肯定不是只有一台服务器，它的内部有很多台服务器，那我们进行访问的时候，因为服务器中间 seSsion 不共享，那我们是不是在服务器之间访问需要频繁登录，那这个时候淘宝搭建一个过渡服务器，对我们是没有任何影响的，我们是登录一次，但是访问所有，这种情况就是反向代理。对我们来说，客户端对代理是无感知的，客户端不需要任何配置就可以访问，我们只需要把请求发送给反向代理服务器，由反向代理服务器去选择目标服务器获取数据后，再返回给客户端，此时反向代理服务器和目标服务器对外就是一个服务器，暴露的是代理服务器地址，隐藏了真实服务器的地址。（在服务器中配置代理服务器）\n序列化和反序列化\n\n\n\n\n\n\n\n\n序列化：将 数据结构或对象 转换为一个可以存储或传输的 字节流或字符串 的过程。对象 –&gt; 字符串反序列化（Deserialization）：则是将其恢复的过程。字符串 –&gt;对象\nviper\n\n\n\n\n\n\n\n\n一种配置解决方案，功能是用来监控、读取、修改配置文件，读取、修改环境变量等。支持 yaml、json 等格式的配置文件。说白了就是一个包，里面有些函数可以调用去实现读取配置的功能。\nyaml\n\n\n\n\n\n\n\n\n一种语言，只是因为其语法格式特殊，常被用来写配置文件。参考\n高内聚低耦合\n\n\n\n\n\n\n\n\n耦合：模块间的相互联系。低耦合可以避免改一处而动多处的情况。内聚：模块内部的联系。高内聚将相互联系的东西聚在一块，即一个模块只完成一个功能。\n分布式和集群\n\n\n\n\n\n\n\n\n分布式：一个大模块分出多个功能，分别由不同的服务器处理。常用分布式服务有：zookeeper集群：一个大功能，由多个服务器共同处理。比如：多服务器共同处理许多用户的请求以减轻单个服务器的压力\n跨域参考\n原码反码补码\n\n\n\n\n\n\n\n\n原码：将最高位作为符号位(0 表示正，1 表示负)，其它数字位代表数值本身的绝对值的数字表示方式。反码：如果是正数，则表示方法和原码一样：如果是负数，符号位不变，其余各位取反，则得到这个数字的反码表示形式。补码：如果是正数，则表示方法和原码一样；如果是负数，则将数字的反码加上 1（相当于将原码数值位取反然后在最低位加 1）总结：正数的原码、反码、补码完全一样，只有负数需要按照以上规则计算。\n开闭原则\n\n\n\n\n\n\n\n\n一个软件实体如类、模块和函数应该对扩展开放、对修改关闭。简单的说就是在修改需求的时候，应该尽量通过扩展来实现变化，而不是通过修改已有代码来实现变化。\n依赖倒转原则\n\n\n\n\n\n\n\n\n将两个模块之间的依赖关系倒置为依赖抽象类或接口\n\n高层模块不应该依赖于低层模块，二者都应该依赖于抽象；\n抽象不应该依赖于细节，细节应该依赖于抽象。\n\n依赖：是指如果一个模块 A 使用另一个模块 B，我们称模块 A 依赖模块 B。低层模块：在应用程序中，有一些低层次的类，这些类实现了一些基本的或初级的操作，我们称之为低层模块；高层模块：另外，有一些高层次的类，这些类封装了某些复杂的逻辑，这些类我们称之为高层模块。\n\n高层次模块要完成自己封装的功能，就必须要使用低层模块，于是高层模块就依赖于低层模块。\n\n里氏替换原则通过父类声明调用方法与直接通过子类声明调用方法的预期执行结果相同。\n123456789101112131415// 1、子类声明指向子类实现var intelCard IntelCard = IntelCard&#123;&#125;intelCard.display() // 执行结果为：Intel card// 2、父类声明指向子类实现var card Card = IntelCard&#123;&#125;card.display() // 执行结果为：Intel card// 两者执行结果一致， 满足里氏替换原则// 如果父类声明拥有自己的方法实现，则里氏替换可能会不满足。但在 golang 中里氏替换原则一定是满足的，因为不存在父类/接口声明拥有自己的方法实现\n\n多路复用\n\n\n\n\n\n\n\n\n一个对象为多个对象提供服务文件描述符：一个文件或一个 socket 句柄的的索引位置参考 1 参考 2\n","slug":"杂学/未分类/术语释义","date":"2024-10-09T02:09:35.635Z","categories_index":"未分类","tags_index":"技术","author_index":"upstreamboat"},{"id":"d237b180598f612014a8905b584c2b3f","title":"位移","content":"左移运算一律在右端补 0，右移运算一律在左端补符号数(负数符号位为 1 就补 1，正数符号位为 0 就补 0)\n在计算机内存当中，负数一律按照补码的形式进行存储；\n负数是不能在原码的基础上进行操作的，需要首先转化成补码才能进行移位运算，并且运算的结果并不是直接结果，还是需要将其转化为原码才能当做运算结果输出！其中不要忘记了加上负号！\n","slug":"杂学/未分类/位移","date":"2024-10-09T02:09:35.633Z","categories_index":"未分类","tags_index":"技术","author_index":"upstreamboat"},{"id":"eb5f3adb17521be888d5fac1c7b84dc0","title":"redis","content":"定义\n\n\n\n\n\n\n\n\nnosql，非关系型数据库数据以 键值对 形式存储在 内存 中\n\n值的类型：字符串(String)、哈希(Hash)、列表(list)、集合(sets)、有序集合(sorted sets)等一个 string 类型的值最大能存储 512MB\n\n特点\n支持事务：不是原子性的，只是批量的命令执行，命令出错不会影响下一个命令\n\n支持设置过期时间，可以减少大量占用内存空间\n\n\n\n\n\n\n\n\n\n减少内存空间占用的策略：定期删除 + 惰性删除 + 内存淘汰\n\n\n定期删除：定期随机选择一部分数据，删除其中过期时间到达的数据弊端：有些数据过期时间很长；有些已过期数据始终不被随机选中\n惰性删除：数据被查询时，若过期时间到达则删除弊端：有些始终不被查询的数据会被忽略\n内存淘汰：当内存不足时，给定一些方案（具体哪些方案略）让使用者去选择如何处理\n\n\n\n支持持久化：可以将内存中的数据保存到磁盘中  两种方式：\n\nRDB：多长时间内触发多少次更新（增删改）后，写入.rdb 文件\nAOF：每次更新都记录操作日志，在断电重启后，执行日志文件来恢复数据\n\n\n内置了发布&#x2F;订阅模式\n\n单线程模型简化了并发控制的复杂性\n\n高可用：\n\n主从复制：一个主节点有多个从节点，将主节点的数据复制给从节点，保持数据一致性。可以通过从节点来备份数据或分担读请求，提高数据的可用性和系统的伸缩性\n\n哨兵模式：哨兵是 redis 中运行的一个线程，它有三个功能：\n\n监控：会不断地发送命令来检查节点是否正常\n通知：如果某节点挂了，哨兵会通过发布&#x2F;订阅模式通知其它节点\n故障转移：主节点挂了，会将一个子节点升为主节点，原来的主节点降为从节点\n\n\n\n\n\n异常情况\n缓存穿透：查询不存在的数据。因 redis 中不存在，便会去数据库找，但数据库中也不存在，所以本次请求后数据无法写入 redis，下一次请求还会继续越过 redis 去找数据库。\n\n缓存击穿：某热点数据（高访问频率数据）到期被删除，然后突然收到多个访问该数据的请求，因 redis 中已删除，故请求都会去到数据库中查找，redis 便失去了缓存的意义。\n\n缓存雪崩：缓存击穿的升级版，大量数据被删除，然后大量请求过来，直接把数据库干趴了。  解决方案：过期时间均匀分布（随机生成过期时间） + 热点数据永不过期\n\n参考视频\n\n\nRedis Pipeline学习\n\n目的  优化批量操作，将多个命令一次性发送，减少网络通信次数。但是服务端拿到 N 个命令后，还是依次执行的\n特点  无法保证原子性\n\n","slug":"杂学/未分类/redis","date":"2024-10-09T02:09:35.632Z","categories_index":"未分类","tags_index":"技术","author_index":"upstreamboat"},{"id":"3bbead949023bae81c3a3a0f1356f7e4","title":"Protobuf","content":"定义Protocol Buffer 用于序列化结构化数据。和 json\\xml 最大的区别是：json\\xml 都是基于文本格式，ProtoBuf 是二进制格式。\n特点：体积更小，从而传输更快，省电省流量。\n为什么体积小：\n\n\n\n\n\n\n\n\n\n\n利用 Varint 原理压缩数据；\n同时使用 Tag - Value (Tag - Length - Value)的编码结构的实现，减少了分隔符的使用，数据存储更加紧凑。\n\n学习教程\n原理一. 对正数数值编码varint 编码：将整数序列化成变长字节。用以压缩。如小型整数，可以用更少字节数表示。\n编码方式：\n\n\n\n\n\n\n\n\n\n小端排序；\n每个字节取 7 位作为数据内容，加上一个最高有效位。\n最高有效位：为 1 表示数据没完后面还有，为 0 则表示这是当前数据最后一个字节；\n\n\n\n过程：\n将被编码数转换为二进制表示\n\n从低位到高位按照 7 位 一组进行划分\n\n将大端序转为小端序，即以分组为单位进行首尾顺序交换\n\n\n\n\n\n\n\n\n\n因为 protobuf 使用是小端序，所以需要转换一下\n\n给每组加上最高有效位(最后一个字节高位补 0，其余各字节高位补 1)组成编码后的数据。\n\n最后转成 10 进制\n\n\n二. 对负数编码：ZigZag 编码三. 对 message 编码存储字段编号和类型、字段值。长度固定，无需分隔符\nkey+value 形式：value 是 varint 编码；key 是如下：\n1(field_number&lt;&lt;3)|wire_type\n\n例子：\n\n当 field_num 为 1~15 时，用一个字节存储，以 08 为例，二进制为 0000 1000，\n\n四. 对字符串类型编码key + length + value 形式。key、length 最后也都要进行 varint 编码。\n","slug":"杂学/未分类/Protobuf","date":"2024-10-09T02:09:35.631Z","categories_index":"未分类","tags_index":"技术","author_index":"upstreamboat"},{"id":"56e366077d0e4b724da421159ab2428d","title":"JWT","content":"定义参考\n生成 token123456789101112131415161718192021222324252627282930313233/*生成 Token 三步走：\t1）设置 claim\t2）对 claim 进行加密\t3）签发密钥*/func (jwtService *jwtService) CreateToken(GuardName string, user JwtUser) (tokenData TokenOutPut, err error, token *jwt.Token) &#123;\t//设置 claim\tcustomClaims := CustomClaims&#123;\t\tStandardClaims: jwt.StandardClaims&#123;\t\tExpiresAt: time.Now().Unix() + global.App.Config.Jwt.JwtTtl,\t\tId:        user.GetUid(),\t\tIssuer:    GuardName, // 用于在中间件中区分不同客户端颁发的 token，避免 token 跨端使用\t\t//token 生效时间\t\tNotBefore: time.Now().Unix() - 10000,\t\t&#125;,\t&#125;\t//对 claim 进行加密\ttoken = jwt.NewWithClaims(jwt.SigningMethodHS256, customClaims)\t//签发密钥\ttokenStr, err := token.SignedString([]byte(global.App.Config.Jwt.Secret))\ttokenData = TokenOutPut&#123;\t\ttokenStr,\t\tint(global.App.Config.Jwt.JwtTtl),\t\tTokenType,\t&#125;\treturn&#125;\n\n解析 token123456789101112//ParseWithClaims(参 1，参 2，参 3)：参 1 是生成的 token，参 2 是 claim 用来存放解析后的数据，参 3 是回调函数用来提供密钥token, err := jwt.ParseWithClaims(\ttokenStr,\t&amp;services.CustomClaims&#123;&#125;,\tfunc(token *jwt.Token) (interface&#123;&#125;, error) &#123;\t\treturn []byte(global.App.Config.Jwt.Secret), nil\t&#125;,)//获取 claimclaims := token.Claims.(*services.CustomClaims)\n\n为什么用 redis 存储 token？\n\n\n\n\n\n\n\n\n\nredis 的响应速度非常快；\ntoken 有时效性，而 redis 天然支持设置过期时间；\n登录信息一般不需要长效储存，所以可以减少 DB 的压力，直接用 redis。\n\n","slug":"杂学/未分类/JWT","date":"2024-10-09T02:09:35.630Z","categories_index":"未分类","tags_index":"技术","author_index":"upstreamboat"},{"id":"2cdebd0fd70d7852b3b959fd1433d2e9","title":"Idea快捷键","content":"\n\n\n键\n作用\n说明\n\n\n\n对象+.\n\n\n\n\nCtrl + Alt + L\n格式化代码\n\n\n\nctrl + -\n收缩代码块\n\n\n\nctrl + &#x3D;\n展开代码块\n\n\n\nctrl +shift +-\n收缩全部代码块\n\n\n\nCtrl + Alt + Shift + J\n同时选中同名\n编辑-查找-XXX\n\n\nctrl + shift + u\n选中变为大小写\n编辑-XXX\n\n\nctrl space\n代码补全\ntab 替换，enter 插入\n\n\nctrl shift space\n智能补全\n\n\n\nctrl alter m\n将代码段封装成方法\n\n\n\n","slug":"杂学/未分类/Idea快捷键","date":"2024-10-09T02:09:35.628Z","categories_index":"未分类","tags_index":"技术","author_index":"upstreamboat"},{"id":"4b90b4ab49a8f2a105fc22744850a324","title":"goland激活","content":"步骤\n查看安装教程\n下载工具和激活码注意：先执行脚本，然后再将激活码粘贴到 idea 中才行。\n\n总地址：可忽略此地址，执行上面步骤即可。（地址来源：公众号“纪亿派”回复“Goland”）\n注意！直接淘宝买即可，上面的方法麻烦且时效短！\n","slug":"杂学/未分类/goland激活","date":"2024-10-09T02:09:35.627Z","categories_index":"未分类","tags_index":"技术","author_index":"upstreamboat"},{"id":"2ecc7f07d9333ce1c15aa54e6e01fe04","title":"Base64编码","content":"一般用来传输图标、验证码图片等微小文件。\n\n优点\n\n\n\n\n\n\n\n\n\n\n通用性：Base64 编码的结果是 ASCII 字符串，这是一种通用的字符集，可以在几乎所有系统中被解析。兼容性：HTTP 协议是文本协议，一些非 ASCII 字符在传输过程中可能出现问题。Base64 编码将二进制数据转换成纯文本，避免了这个问题。数据封装：有时候，我们可能需要将文件和其他数据（如文本、JSON 等）一起发送。Base64 编码可以让我们把文件编码成字符串，并和其他数据一起发送。\n\n缺点\n\n\n\n\n\n\n\n\n\n\n体积增大：Base64 编码会使数据体积增大约 33%，因为每 3 个字节的数据需要用 4 个字节的 Base64 字符来表示。CPU 使用率：编码和解码 Base64 需要 CPU 资源，大量的 Base64 编码&#x2F;解码可能会影响性能\n","slug":"杂学/未分类/Base64编码","date":"2024-10-09T02:09:35.626Z","categories_index":"未分类","tags_index":"技术","author_index":"upstreamboat"}]
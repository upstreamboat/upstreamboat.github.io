{"title":"协程--图解","uid":"cc5db5cd6eeb1aa9cc58dc1a444cc045","slug":"GO语言/基础/协程--图解","date":"2024-10-12T02:26:58.137Z","updated":"2024-10-19T08:23:48.843Z","comments":true,"path":"api/articles/GO语言/基础/协程--图解.json","keywords":null,"cover":"/images/cover/5.png","content":"<h1 id=\"协程–图解\"><a href=\"#协程–图解\" class=\"headerlink\" title=\"协程–图解\"></a>协程–图解</h1><ol>\n<li><p><a href=\"https://www.yuque.com/aceld/golang/srxd6d\">参考</a></p>\n</li>\n<li><p>总体图示：<br><img src=\"/%E5%8D%8F%E7%A8%8B--%E5%9B%BE%E8%A7%A3_1.png\" alt=\"Image-1\"></p>\n</li>\n<li><p>GMP 成员：<br>G：协程（用户线程），乘客<br>M：内核线程，检票口<br>P：协程处理器，检票员<br>全局队列：候车厅<br>本地队列：检票排队</p>\n</li>\n<li><p>GMP 调度器的 4 个设计策略：</p>\n<ul>\n<li><p><strong>复用线程</strong></p>\n<ol>\n<li><p>work stealing 机制</p>\n<blockquote><span class=\"custom-blockquote-svg\"><svg width=\"24\" height=\"24\" viewBox=\"0 0 24 24\" fill=\"\" xmlns=\"http://www.w3.org/2000/svg\" data-reactroot=\"\">\n<path fill=\"\" d=\"M22 12C22 6.5 17.5 2 12 2C6.5 2 2 6.5 2 12C2 17.5 6.5 22 12 22C13.8 22 15.5 21.5 17 20.6L22 22L20.7 17C21.5 15.5 22 13.8 22 12Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\" undefined=\"1\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M17 8.5C15.23 8.97 14.07 10.84 14.01 13.27C14 13.33 14 13.4 14 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M9 8.5C7.23 8.97 6.07 10.84 6.01 13.27C6 13.33 6 13.4 6 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\"></path>\n</svg>\n</span><p>当本线程无可运行的 G 时，尝试从其他线程绑定的 P 偷取 G，而不是销毁线程<br>当 P 的队列中没有 G 时，则会从其它 P 偷取一个 G 来执行。（检票员会喊正在排队的乘客到没人的队列）</p></blockquote>\n</li>\n<li><p>hand off 机制</p>\n<blockquote><span class=\"custom-blockquote-svg\"><svg width=\"24\" height=\"24\" viewBox=\"0 0 24 24\" fill=\"\" xmlns=\"http://www.w3.org/2000/svg\" data-reactroot=\"\">\n<path fill=\"\" d=\"M22 12C22 6.5 17.5 2 12 2C6.5 2 2 6.5 2 12C2 17.5 6.5 22 12 22C13.8 22 15.5 21.5 17 20.6L22 22L20.7 17C21.5 15.5 22 13.8 22 12Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\" undefined=\"1\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M17 8.5C15.23 8.97 14.07 10.84 14.01 13.27C14 13.33 14 13.4 14 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M9 8.5C7.23 8.97 6.07 10.84 6.01 13.27C6 13.33 6 13.4 6 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\"></path>\n</svg>\n</span><p>当本线程因为 G 进行系统调用阻塞时，线程释放绑定的 P，把 P 转移给其他空闲的线程执行<br>当某个 G 阻塞，则当前 P 会转移到一个新的 M 上，继续执行其它 G。（有人闹事，则关闭当前检票口，检票员和排队乘客转移到一个新开的检票口)</p></blockquote>\n</li>\n</ol>\n</li>\n<li><p><strong>利用并行</strong>：GOMAXPROCS 设置 P 的数量，最多有 GOMAXPROCS 个线程分布在多个 CPU 上同时运行</p>\n</li>\n<li><p><strong>抢占</strong>：一个 goroutine 最多占用 CPU 10ms，防止其他 goroutine 被饿死</p>\n</li>\n<li><p><strong>全局 G 队列</strong>：当 P 的本地队列为空时，优先从全局队列获取，如果全局队列为空时则通过 work stealing 机制从其他 P 的本地队列偷取 G</p>\n</li>\n</ul>\n</li>\n<li><p>GMP 的几种场景：<br>&#x2F;&#x2F; M0：程序运行时的第一个线程<br>&#x2F;&#x2F; G0：每个线程 M 中都存有一个 G0（注意 G0 不是存放在队列中），G0 是用来做调度的。例如：从 G1 切换到 G2 时，会先切回到 G0，保存 G1 的栈等调度信息，然后再切换到 G2。<br>&#x2F;&#x2F; 执行线程：有 G、P、M<br>&#x2F;&#x2F; 自旋线程：有 P、M<br>&#x2F;&#x2F; 休眠线程：有 M</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">1. 新建 G 时，会放入 P 队列中。若 P 队列满，则放入全局队列中。</span><br><span class=\"line\">2. G1 中创建的 G1&#x27;，若无空闲 P，则会优先存放在 P1 队列中；若有，则分配到空闲 P 执行。</span><br><span class=\"line\">3. 当 G1 执行完毕，P1 会启用 G0，然后通过 G0 调用本地队列的 G1&#x27;。</span><br><span class=\"line\">4. 当本地队列满时，再创建 G，会将 当前 P 队列的靠前一半的 G 与新建的 G 一同存放到全局队列中。</span><br><span class=\"line\">5. 新建 G 时，当前运行的 G 会尝试唤醒空闲的 P 和 M，如果被唤醒的 P 队列中没有 G，则被唤醒的 M 会不断寻找 G（此时的 M 称为自旋线程）。</span><br><span class=\"line\">    // 自旋线程数量 + 执行线程数量 &lt;= P 数量</span><br><span class=\"line\">    // 寻找策略：自旋线程会先去全局队列中获取一批 G（具体获取多少个 G 有个公式）。若全局队列为空，则会从其它 P 队列偷取靠后一半的 G。</span><br><span class=\"line\">6. 如果 G 阻塞，则当前 P 会去唤醒一个休眠线程 M 重新绑定，继续执行当前 P 队列中的其它 G。</span><br><span class=\"line\">7. 当 G 阻塞结束时，当前 M 会优先去找阻塞前的 P。如果 P 已被占用，则去唤醒空闲 P。如果没有空闲 P，则 G 会被释放到全局队列中等待调用。</span><br></pre></td></tr></table></figure></li>\n</ol>\n","text":"协程–图解 参考 总体图示： GMP 成员：G：协程（用户线程），乘客M：内核线程，检票口P：协程处理器，检票员全局队列：候车厅本地队列：检票排队 GMP 调度...","permalink":"/post/GO语言/基础/协程--图解","photos":[],"count_time":{"symbolsCount":"1.3k","symbolsTime":"1 mins."},"categories":[{"name":"GO语言","slug":"GO语言","count":77,"path":"api/categories/GO语言.json"}],"tags":[{"name":"技术","slug":"技术","count":168,"path":"api/tags/技术.json"}],"toc":"<ol class=\"toc\"><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" href=\"#%E5%8D%8F%E7%A8%8B%E2%80%93%E5%9B%BE%E8%A7%A3\"><span class=\"toc-text\">协程–图解</span></a></li></ol>","author":{"name":"upstreamboat","slug":"blog-author","avatar":"images/favicon/favicon.ico","link":"/","description":"nothing to say","socials":{"github":"https://github.com/upstreamboat","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{"bilibili":{"icon":"/images/favicon/bilibili.svg","link":"https://www.bilibili.com/"},"chatgpt":{"icon":"/images/favicon/chatgpt.svg","link":"https://chatgpt.com/"}}}},"mapped":true,"hidden":false,"prev_post":{"title":"协程--CPU、内存","uid":"5ce8a35fbf88482d4de619a9c1063a08","slug":"GO语言/基础/协程--CPU、内存","date":"2024-10-12T02:26:58.161Z","updated":"2024-10-19T08:23:51.602Z","comments":true,"path":"api/articles/GO语言/基础/协程--CPU、内存.json","keywords":null,"cover":"/images/cover/5.png","text":"协程–CPU、内存 虚拟内存 用户程序（进程）只能使用虚拟的内存地址来获取数据，系统会将这个虚拟地址翻译成实际的物理地址。操作系统内部会对虚拟内存地址和真实的物...","permalink":"/post/GO语言/基础/协程--CPU、内存","photos":[],"count_time":{"symbolsCount":674,"symbolsTime":"1 mins."},"categories":[{"name":"GO语言","slug":"GO语言","count":77,"path":"api/categories/GO语言.json"}],"tags":[{"name":"技术","slug":"技术","count":168,"path":"api/tags/技术.json"}],"author":{"name":"upstreamboat","slug":"blog-author","avatar":"images/favicon/favicon.ico","link":"/","description":"nothing to say","socials":{"github":"https://github.com/upstreamboat","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{"bilibili":{"icon":"/images/favicon/bilibili.svg","link":"https://www.bilibili.com/"},"chatgpt":{"icon":"/images/favicon/chatgpt.svg","link":"https://chatgpt.com/"}}}}},"next_post":{"title":"协程--chan阻塞测试","uid":"de4bfe30255df688e3d880102f081573","slug":"GO语言/基础/协程--chan阻塞测试","date":"2024-10-12T02:26:58.109Z","updated":"2024-10-19T08:23:47.054Z","comments":true,"path":"api/articles/GO语言/基础/协程--chan阻塞测试.json","keywords":null,"cover":"/images/cover/5.png","text":"协程–chan 阻塞测试12345678910111213141516171819202122232425262728293031323334353637383...","permalink":"/post/GO语言/基础/协程--chan阻塞测试","photos":[],"count_time":{"symbolsCount":"1k","symbolsTime":"1 mins."},"categories":[{"name":"GO语言","slug":"GO语言","count":77,"path":"api/categories/GO语言.json"}],"tags":[{"name":"技术","slug":"技术","count":168,"path":"api/tags/技术.json"}],"author":{"name":"upstreamboat","slug":"blog-author","avatar":"images/favicon/favicon.ico","link":"/","description":"nothing to say","socials":{"github":"https://github.com/upstreamboat","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{"bilibili":{"icon":"/images/favicon/bilibili.svg","link":"https://www.bilibili.com/"},"chatgpt":{"icon":"/images/favicon/chatgpt.svg","link":"https://chatgpt.com/"}}}}}}
[{"title":"设计模式","path":"/2024/10/09/杂学/未分类/设计模式/","content":"适配器通过创建一个中间转换的适配器，来将一个接口改造成用户需要的另一个接口。在不修改现有代码的情况下，使两个不兼容的接口能够工作。 观察者当发布者的对象有修改，则调用订阅者提供的方法告知它们 代理模式代码增强，在原代码逻辑前后增加一些代码逻辑。访问者不直接访问目标，通过代理访问。代理持有目标对象。 1. 分类静态代理：编码时便写定的代理 动态代理：运行时通过反射获取的代理 2. 优缺点 优点： 代理模式在客户端与目标对象之间起到一个中介作用和保护目标对象的作用； 代理对象可以扩展目标对象的功能； 代理模式能将客户端与目标对象分离，在一定程度上降低了系统的耦合度，增加了程序的可扩展性： 缺点： 静态代理模式会造成系统设计中类的数量增加，但动态代理可以解决这个问题； 在客户端和目标对象之间增加一个代理对象，会造成请求处理速度变慢； 增加了系统的复杂度； 代理模式与装饰者模式：十分相像但目的不同。代理会严格将访问对象和受控对象分离开来，一个代理仅仅只负责一个类，这与装饰器模式是不同的，对于装饰器模式来说，目标对象就是访问对象所持有的。此外虚拟代理的实现与装饰者模式实现是不同的，虚拟代理一开始并不持有远程服务器的资源对象，而是对域名和文件名进行解析才得到该对象，在我们的代码中我们要么传入一个实例，要么让代理持有一个实例，但在虚拟代理中，我么传入一个虚拟的文件资源，虚拟代理对远程服务器进行解析才会获得真实的对象实例，这一点是不同的。 工厂模式为什么要用工厂： 解耦：分离对象的创建和使用。当创建对象的过程改变，不需要到每个使用对象的地方进行修改。 减少代码重复：不需要在使用对象前，都写一堆创建对象的过程的代码。 例子：比如：创建数据库对象。 使用理解：首先，工厂模式是为了解耦：把对象的创建和使用的过程分开。就是 Class A 想调用 Class B，那么 A 只是调用 B 的方法，而至于 B 的实例化，就交给工厂类。 其次，工厂模式可以降低代码重复。如果创建对象 B 的过程都很复杂，需要一定的代码量，而且很多地方都要用到，那么就会有很多的重复代码。我们可以这些创建对象 B 的代码放到工厂里统一管理。既减少了重复代码，也方便以后对 B 的创建过程的修改维护。（当然，我个人觉得也可以把这些创建过程的代码放到类的构造函数里，同样可以降低重复率，而且构造函数本身的作用也是初始化对象。不过，这样也会导致构造函数过于复杂，做的事太多，不符合设计原则。） 由于创建过程都由工厂统一管理，所以发生业务逻辑变化，不需要找到所有需要创建 B 的地方去逐个修正，只需要在工厂里修改即可，降低维护成本。同理，想把所有调用 B 的地方改成 B 的子类 B1，只需要在对应生产 B 的工厂中或者工厂的方法中修改其生产的对象为 B1 即可，而不需要找到所有的 new B（）改为 new B1()。 另外，因为工厂管理了对象的创建逻辑，使用者并不需要知道具体的创建过程，只管使用即可，减少了使用者因为创建逻辑导致的错误。 举个例子： 一个数据库工厂：可以返回一个数据库实例，可以是 mysql，oracle 等。 这个工厂就可以把数据库连接需要的用户名，地址，密码等封装好，直接返回对应的数据库对象就好。不需要调用者自己初始化，减少了写错密码等等这些错误。调用者只负责使用，不需要管怎么去创建、初始化对象。","tags":["技术"],"categories":["杂学"]},{"title":"编码","path":"/2024/10/09/杂学/未分类/编码/","content":"ASICII 共 128 个，仅包含一些符号和英文字母 GBK 是字符集也是编码格式包含 ASICII 码，也包含了中文等字符 Unicode 仅是字符集，不是编码格式：因为字符集的编号与存储时的编号不同提供的编码格式有：UTF8、UTF16、UTF32包含 ASICII 码，也包含了中文等字符。但是除了 ASICII 码外，其它字符与 GBK 中的编号一样（这就造成不同编码格式间不认识的情况） 图示[[编码.png]]","tags":["技术"],"categories":["杂学"]},{"title":"正则表达式","path":"/2024/10/09/杂学/未分类/正则表达式/","content":"修饰符 含义 描述 i ignore - 不区分大小写 将匹配设置为不区分大小写，搜索时不区分大小写: A 和 a 没有区别。 g global - 全局匹配 查找所有的匹配项。 m multi line - 多行匹配 使边界字符 ^ 和 $ 匹配每一行的开头和结尾，记住是多行，而不是整个字符串的开头和结尾。 s 特殊字符圆点 . 中包含换行符 默认情况下的圆点 . 是匹配除换行符 之外的任何字符，加上 s 修饰符之后, . 中包含换行符 。 u unicode - Unicode 模式，用来正确处理大于\\uFFFF 的 Unicode 字符，ES6 新增 y sticky - 粘连匹配，ES6 新增 y 匹配时不会跳过任何字符。g 会跳过字符直到找到可匹配项。单单一个 y 修饰符对 match 方法，只能返回第一个匹配，必须与 g 修饰符联用，才能返回所有匹配。‘a1a2a3’.match(&#x2F;a\\d&#x2F;y) &#x2F;&#x2F; [“a1”]‘a1a2a3’.match(&#x2F;a\\d&#x2F;gy) &#x2F;&#x2F; [“a1”, “a2”, “a3”] v Unicode 属性类（\\p{…}）的运算，ES6 新增 差集运算：[A–B]，交集运算：[A&amp;&amp;B] d 这个修饰符可以让 exec()、match()的返回结果添加 indices 属性，在该属性上面可以拿到匹配的开始位置和结束位置，ES2022 新增。 多组匹配：const text &#x3D; ‘zabbcdef’;const re &#x3D; &#x2F;ab+(cd(ef))&#x2F;d;const result &#x3D; re.exec(text);result.indices &#x2F;&#x2F;结果：[ [1, 8], [4, 8], [6, 8] ] &#x2F;&#x2F;一组 abcdef，二组 cdef，三组 ef，注意结束位置是 8 而不是 7，代表下一个位置。","tags":["技术"],"categories":["杂学"]},{"title":"术语释义","path":"/2024/10/09/杂学/未分类/术语释义/","content":"单点登录和多点登录 单点登录：就是在多个系统中，用户只需一次登录，各个系统即可感知该用户已经登录。多点登录：同一账号可以在不同终端同时登录，同时收发信息。 多点登录限制（禁止用户多点在线）：一个端同 1 一个账号只能登录一个实例 粘包和拆包 粘包：如果一次请求发送的数据量比较小，没达到缓冲区大小，TCP 则会将多个请求合并为同一个请求进行发送，这就形成了粘包问题。拆包：如果一次请求发送的数据量比较大，超过了缓冲区大小，TCP 就会将其拆分为多次发送，这就是拆包。 粘包的处理办法： 发送端将每个包都封装成固定的长度，比如 100 字节大小。如果不足 100 字节可通过补 0 或空等进行填充到指定长度； 发送端在每个包的末尾使用固定的分隔符，例如\\r 。如果发生拆包需等待多个包发送过来之后再找到其中的\\r 进行合并；例如，FTP 协议； 将消息分为头部和消息体，头部中保存整个消息的长度，只有读取到足够长度的消息之后才算是读到了一个完整的消息。 大端小端已知：数据一定是从内存的低地址依次向高地址读取和写入的。 大端模式，即低地址存放高位字节数小端存储，即低地址存储低位字节数 docker参考 代理Nginx 就可以实现反向代理（Nginx 的 3 大功能：Web 服务器/反向代理/负载均衡）。 正向代理：我们平时需要访问国外的浏览器是不是很慢，比如我们要看推特，看 GitHub 等等。我们直接用国内的服务器无法访问国外的服务器，或者是访问很慢。所以我们需要在本地搭建一个服务器来帮助我们去访问。那这种就是正向代理。(浏览器中配置代理服务器)反向代理：那什么是反向代理呢。比如：我们访问淘宝的时候，淘宝内部肯定不是只有一台服务器，它的内部有很多台服务器，那我们进行访问的时候，因为服务器中间 seSsion 不共享，那我们是不是在服务器之间访问需要频繁登录，那这个时候淘宝搭建一个过渡服务器，对我们是没有任何影响的，我们是登录一次，但是访问所有，这种情况就是反向代理。对我们来说，客户端对代理是无感知的，客户端不需要任何配置就可以访问，我们只需要把请求发送给反向代理服务器，由反向代理服务器去选择目标服务器获取数据后，再返回给客户端，此时反向代理服务器和目标服务器对外就是一个服务器，暴露的是代理服务器地址，隐藏了真实服务器的地址。（在服务器中配置代理服务器） 序列化和反序列化 序列化：将 数据结构或对象 转换为一个可以存储或传输的 字节流或字符串 的过程。对象 –&gt; 字符串反序列化（Deserialization）：则是将其恢复的过程。字符串 –&gt;对象 viper 一种配置解决方案，功能是用来监控、读取、修改配置文件，读取、修改环境变量等。支持 yaml、json 等格式的配置文件。说白了就是一个包，里面有些函数可以调用去实现读取配置的功能。 yaml 一种语言，只是因为其语法格式特殊，常被用来写配置文件。参考 高内聚低耦合 耦合：模块间的相互联系。低耦合可以避免改一处而动多处的情况。内聚：模块内部的联系。高内聚将相互联系的东西聚在一块，即一个模块只完成一个功能。 分布式和集群 分布式：一个大模块分出多个功能，分别由不同的服务器处理。常用分布式服务有：zookeeper集群：一个大功能，由多个服务器共同处理。比如：多服务器共同处理许多用户的请求以减轻单个服务器的压力 跨域参考 原码反码补码 原码：将最高位作为符号位(0 表示正，1 表示负)，其它数字位代表数值本身的绝对值的数字表示方式。反码：如果是正数，则表示方法和原码一样：如果是负数，符号位不变，其余各位取反，则得到这个数字的反码表示形式。补码：如果是正数，则表示方法和原码一样；如果是负数，则将数字的反码加上 1（相当于将原码数值位取反然后在最低位加 1）总结：正数的原码、反码、补码完全一样，只有负数需要按照以上规则计算。 开闭原则 一个软件实体如类、模块和函数应该对扩展开放、对修改关闭。简单的说就是在修改需求的时候，应该尽量通过扩展来实现变化，而不是通过修改已有代码来实现变化。 依赖倒转原则 将两个模块之间的依赖关系倒置为依赖抽象类或接口 高层模块不应该依赖于低层模块，二者都应该依赖于抽象； 抽象不应该依赖于细节，细节应该依赖于抽象。 依赖：是指如果一个模块 A 使用另一个模块 B，我们称模块 A 依赖模块 B。低层模块：在应用程序中，有一些低层次的类，这些类实现了一些基本的或初级的操作，我们称之为低层模块；高层模块：另外，有一些高层次的类，这些类封装了某些复杂的逻辑，这些类我们称之为高层模块。 高层次模块要完成自己封装的功能，就必须要使用低层模块，于是高层模块就依赖于低层模块。 里氏替换原则通过父类声明调用方法与直接通过子类声明调用方法的预期执行结果相同。 123456789101112131415// 1、子类声明指向子类实现var intelCard IntelCard = IntelCard&#123;&#125;intelCard.display() // 执行结果为：Intel card// 2、父类声明指向子类实现var card Card = IntelCard&#123;&#125;card.display() // 执行结果为：Intel card// 两者执行结果一致， 满足里氏替换原则// 如果父类声明拥有自己的方法实现，则里氏替换可能会不满足。但在 golang 中里氏替换原则一定是满足的，因为不存在父类/接口声明拥有自己的方法实现 多路复用 一个对象为多个对象提供服务文件描述符：一个文件或一个 socket 句柄的的索引位置参考 1 参考 2","tags":["技术"],"categories":["杂学"]},{"title":"位移","path":"/2024/10/09/杂学/未分类/位移/","content":"左移运算一律在右端补 0，右移运算一律在左端补符号数(负数符号位为 1 就补 1，正数符号位为 0 就补 0) 在计算机内存当中，负数一律按照补码的形式进行存储； 负数是不能在原码的基础上进行操作的，需要首先转化成补码才能进行移位运算，并且运算的结果并不是直接结果，还是需要将其转化为原码才能当做运算结果输出！其中不要忘记了加上负号！","tags":["技术"],"categories":["杂学"]},{"title":"redis","path":"/2024/10/09/杂学/未分类/redis/","content":"定义 nosql，非关系型数据库数据以 键值对 形式存储在 内存 中 值的类型：字符串(String)、哈希(Hash)、列表(list)、集合(sets)、有序集合(sorted sets)等一个 string 类型的值最大能存储 512MB 特点 支持事务：不是原子性的，只是批量的命令执行，命令出错不会影响下一个命令 支持设置过期时间，可以减少大量占用内存空间 减少内存空间占用的策略：定期删除 + 惰性删除 + 内存淘汰 定期删除：定期随机选择一部分数据，删除其中过期时间到达的数据弊端：有些数据过期时间很长；有些已过期数据始终不被随机选中 惰性删除：数据被查询时，若过期时间到达则删除弊端：有些始终不被查询的数据会被忽略 内存淘汰：当内存不足时，给定一些方案（具体哪些方案略）让使用者去选择如何处理 支持持久化：可以将内存中的数据保存到磁盘中 两种方式： RDB：多长时间内触发多少次更新（增删改）后，写入.rdb 文件 AOF：每次更新都记录操作日志，在断电重启后，执行日志文件来恢复数据 内置了发布&#x2F;订阅模式 单线程模型简化了并发控制的复杂性 高可用： 主从复制：一个主节点有多个从节点，将主节点的数据复制给从节点，保持数据一致性。可以通过从节点来备份数据或分担读请求，提高数据的可用性和系统的伸缩性 哨兵模式：哨兵是 redis 中运行的一个线程，它有三个功能： 监控：会不断地发送命令来检查节点是否正常 通知：如果某节点挂了，哨兵会通过发布&#x2F;订阅模式通知其它节点 故障转移：主节点挂了，会将一个子节点升为主节点，原来的主节点降为从节点 异常情况 缓存穿透：查询不存在的数据。因 redis 中不存在，便会去数据库找，但数据库中也不存在，所以本次请求后数据无法写入 redis，下一次请求还会继续越过 redis 去找数据库。 缓存击穿：某热点数据（高访问频率数据）到期被删除，然后突然收到多个访问该数据的请求，因 redis 中已删除，故请求都会去到数据库中查找，redis 便失去了缓存的意义。 缓存雪崩：缓存击穿的升级版，大量数据被删除，然后大量请求过来，直接把数据库干趴了。 解决方案：过期时间均匀分布（随机生成过期时间） + 热点数据永不过期 参考视频","tags":["技术"]},{"title":"Protobuf","path":"/2024/10/09/杂学/未分类/Protobuf/","content":"定义Protocol Buffer 用于序列化结构化数据。和 json\\xml 最大的区别是：json\\xml 都是基于文本格式，ProtoBuf 是二进制格式。 特点：体积更小，从而传输更快，省电省流量。 为什么体积小： 利用 Varint 原理压缩数据； 同时使用 Tag - Value (Tag - Length - Value)的编码结构的实现，减少了分隔符的使用，数据存储更加紧凑。 学习教程 原理一. 对正数数值编码varint 编码：将整数序列化成变长字节。用以压缩。如小型整数，可以用更少字节数表示。 编码方式： 小端排序； 每个字节取 7 位作为数据内容，加上一个最高有效位。 最高有效位：为 1 表示数据没完后面还有，为 0 则表示这是当前数据最后一个字节； 过程： 将被编码数转换为二进制表示 从低位到高位按照 7 位 一组进行划分 将大端序转为小端序，即以分组为单位进行首尾顺序交换 因为 protobuf 使用是小端序，所以需要转换一下 给每组加上最高有效位(最后一个字节高位补 0，其余各字节高位补 1)组成编码后的数据。 最后转成 10 进制 二. 对负数编码：ZigZag 编码三. 对 message 编码存储字段编号和类型、字段值。长度固定，无需分隔符 key+value 形式：value 是 varint 编码；key 是如下： 1(field_number&lt;&lt;3)|wire_type 例子： 当 field_num 为 1~15 时，用一个字节存储，以 08 为例，二进制为 0000 1000， 四. 对字符串类型编码key + length + value 形式。key、length 最后也都要进行 varint 编码。","tags":["技术"],"categories":["杂学"]},{"title":"JWT","path":"/2024/10/09/杂学/未分类/JWT/","content":"定义参考 生成 token123456789101112131415161718192021222324252627282930313233/*生成 Token 三步走：\t1）设置 claim\t2）对 claim 进行加密\t3）签发密钥*/func (jwtService *jwtService) CreateToken(GuardName string, user JwtUser) (tokenData TokenOutPut, err error, token *jwt.Token) &#123;\t//设置 claim\tcustomClaims := CustomClaims&#123; StandardClaims: jwt.StandardClaims&#123; ExpiresAt: time.Now().Unix() + global.App.Config.Jwt.JwtTtl, Id: user.GetUid(), Issuer: GuardName, // 用于在中间件中区分不同客户端颁发的 token，避免 token 跨端使用 //token 生效时间 NotBefore: time.Now().Unix() - 10000, &#125;,\t&#125;\t//对 claim 进行加密\ttoken = jwt.NewWithClaims(jwt.SigningMethodHS256, customClaims)\t//签发密钥\ttokenStr, err := token.SignedString([]byte(global.App.Config.Jwt.Secret))\ttokenData = TokenOutPut&#123; tokenStr, int(global.App.Config.Jwt.JwtTtl), TokenType,\t&#125;\treturn&#125; 解析 token123456789101112//ParseWithClaims(参 1，参 2，参 3)：参 1 是生成的 token，参 2 是 claim 用来存放解析后的数据，参 3 是回调函数用来提供密钥token, err := jwt.ParseWithClaims(\ttokenStr,\t&amp;services.CustomClaims&#123;&#125;,\tfunc(token *jwt.Token) (interface&#123;&#125;, error) &#123; return []byte(global.App.Config.Jwt.Secret), nil\t&#125;,)//获取 claimclaims := token.Claims.(*services.CustomClaims) 为什么用 redis 存储 token？ redis 的响应速度非常快； token 有时效性，而 redis 天然支持设置过期时间； 登录信息一般不需要长效储存，所以可以减少 DB 的压力，直接用 redis。","tags":["技术"],"categories":["杂学"]},{"title":"Idea快捷键","path":"/2024/10/09/杂学/未分类/Idea快捷键/","content":"键 作用 说明 对象+. Ctrl + Alt + L 格式化代码 ctrl + - 收缩代码块 ctrl + &#x3D; 展开代码块 ctrl +shift +- 收缩全部代码块 Ctrl + Alt + Shift + J 同时选中同名 编辑-查找-XXX ctrl + shift + u 选中变为大小写 编辑-XXX ctrl space 代码补全 tab 替换，enter 插入 ctrl shift space 智能补全 ctrl alter m 将代码段封装成方法","tags":["技术"],"categories":["杂学"]},{"title":"goland激活","path":"/2024/10/09/杂学/未分类/goland激活/","content":"步骤 查看安装教程 下载工具和激活码注意：先执行脚本，然后再将激活码粘贴到 idea 中才行。 总地址：可忽略此地址，执行上面步骤即可。（地址来源：公众号“纪亿派”回复“Goland”） 注意！直接淘宝买即可，上面的方法麻烦且时效短！","tags":["技术"],"categories":["杂学"]},{"title":"Base64编码","path":"/2024/10/09/杂学/未分类/Base64编码/","content":"一般用来传输图标、验证码图片等微小文件。 优点 通用性：Base64 编码的结果是 ASCII 字符串，这是一种通用的字符集，可以在几乎所有系统中被解析。兼容性：HTTP 协议是文本协议，一些非 ASCII 字符在传输过程中可能出现问题。Base64 编码将二进制数据转换成纯文本，避免了这个问题。数据封装：有时候，我们可能需要将文件和其他数据（如文本、JSON 等）一起发送。Base64 编码可以让我们把文件编码成字符串，并和其他数据一起发送。 缺点 体积增大：Base64 编码会使数据体积增大约 33%，因为每 3 个字节的数据需要用 4 个字节的 Base64 字符来表示。CPU 使用率：编码和解码 Base64 需要 CPU 资源，大量的 Base64 编码&#x2F;解码可能会影响性能","tags":["技术"],"categories":["杂学"]},{"title":"切片修改问题","path":"/2024/10/09/GO语言/运用/切片修改问题/","content":"切片传递修改的正确处理方式1234567891011121314151617181920212223242526272829303132333435// 方式一（推荐）func TestTwo(t *testing.T) &#123;\tvar aa = make([]int, 0)\taa = twoSet(aa)\tt.Log(&quot;result:&quot;, aa) // result:[1]&#125;func twoSet(aa []int) []int &#123;\taa = append(aa, 1)\treturn aa&#125;// 方式二func TestOne(t *testing.T) &#123;\tvar aa = make([]int, 0)\toneSet(&amp;aa)\tt.Log(&quot;result:&quot;, aa) // result:[1]&#125;func oneSet(aa *[]int) &#123;\t*aa = append(*aa, 1)&#125; 错误写法12345678910111213141516// 错误写法func TestTwo(t *testing.T) &#123;\tvar aa = make([]int, 0)\ttwoSet(aa)\tt.Log(&quot;result:&quot;, aa) // result:[]&#125;func twoSet(aa []int) &#123;\taa = append(aa, 1)&#125; 对错误分析12345678910111213141516171819202122232425262728293031323334353637383940func TestThree(t *testing.T) &#123;\t// 创建一个 slice\tslice1 := make([]int, 1, 3)\tmyAppend(slice1)\tfmt.Printf(&quot;数组地址: %p\\t，数组指针: %p\\t，切片地址: %p &quot;, &amp;slice1[0], slice1, &amp;slice1)\tfmt.Println(&quot;result: &quot;, slice1) // result: [2]\tprintArray(slice1)&#125;func myAppend(slice2 []int) &#123;\tslice2 = append(slice2, 1) // 分析：slice2改变了底层数组内容，但是slice1读取不到\tslice2[0] = 2 // 分析：slice2改变了底层数组内容，并且slice1中能读取到。\tfmt.Printf(&quot;数组地址: %p\\t，数组指针: %p\\t，切片地址: %p &quot;, &amp;slice2[0], slice2, &amp;slice2) // 分析：地址改变了，说明该slice2是一个拷贝对象\tfmt.Println(&quot;myAppend: &quot;, slice2) // myAppend: [2 1]&#125;// 打印切片对应的底层数组中的内容func printArray(slice []int) &#123;\t// 获取底层数组的反射值\tsliceValue := reflect.ValueOf(slice)\t// 通过反射获取底层数组的指针\tarrayPtr := sliceValue.Pointer()\t// 计算底层数组的地址和元素大小\telementSize := int(sliceValue.Type().Elem().Size())\tcapacity := sliceValue.Cap()\tfor i := 0; i &lt; capacity; i++ &#123; // 计算元素地址 elementAddr := arrayPtr + uintptr(i)*uintptr(elementSize) // 使用 reflect.Value 读取元素值 elemValue := reflect.NewAt(sliceValue.Type().Elem(), unsafe.Pointer(elementAddr)).Elem() fmt.Printf(&quot;Element at index %d: %d &quot;, i, elemValue.Interface())\t&#125;&#125; 输出 数组地址: 0xc0000141c8 ，数组指针: 0xc0000141c8 ，切片地址: 0xc000008198myAppend: [2 1]数组地址: 0xc0000141c8 ，数组指针: 0xc0000141c8 ，切片地址: 0xc000008180result: [2]Element at index 0: 2Element at index 1: 1Element at index 2: 0 分析为什么修改的值能被外层的 slice 读取到，另一个追加的值却读取不到？slice2 = append(slice2, 1) &#x2F;&#x2F; 这里需要注意：一旦 append 时导致扩容，那么底层数组就不再是原来的底层数组了slice2[0] = 2 解：因为 slice2 和 slice 虽然不是同一个对象，但其指向的底层数组是同一个，所以 slice2 追加及修改元素后，底层数组的内容也被改变了。当外层 slice 读取时，其实此时底层数组中是有两个值的，但是因为 slice 的 len&#x3D;1，所以只能读取到第一个元素。","tags":["技术"],"categories":["GO","切片"]},{"title":"nn","path":"/wiki/fuck/nn.html","content":"NN"},{"title":"mm","path":"/wiki/fuck/mm.html","content":"MM"},{"title":"aa","path":"/wiki/hello/aa.html","content":"fuck22 默认打开的代码折叠框代码块 题目1这是答案 1题目2这是答案 2题目3这是答案 3 图片代码块12let x = 123print(&quot;hello world&quot;)"},{"title":"bb","path":"/wiki/hello/bb.html","content":"fuckbb"},{"title":"cc","path":"/wiki/hello/cc.html","content":"fuckcc"},{"title":"a","path":"/wiki/stellar/a.html","content":"fuck2"},{"title":"b","path":"/wiki/stellar/b.html","content":"fuck3"},{"title":"index","path":"/wiki/stellar/index.html","content":"fuck"}]